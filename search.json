[{"title":"Apollo r5.5.0 代码解读 之 混合A星算法调试工具","url":"/2021/09/18/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E6%B7%B7%E5%90%88A%E6%98%9F%E7%AE%97%E6%B3%95%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","content":"这篇博客介绍了 Apollo r5.5.0 中混合 A* 路径规划算法的调试工具实现。通过 C++ 类封装障碍物与结果容器，并通过 extern “C” 接口实现 Python 与 C++ 的调用对接。文中还详细解析了关键参数如 step_size、delta_t 等对轨迹质量与计算效率的影响，并展示了不同配置下的可视化效果，帮助读者深入理解混合 A* 算法的内部机制与调试方法。\n\n 代码分析\n在hybrid_a_star_wrapper.cc定义了两个类，用于存储障碍物(HybridAObstacleContainer)和计算结果(HybridAResultContainer)。\n// hybrid_a_star_wrapper.ccclass HybridAObstacleContainer &#123; public:  HybridAObstacleContainer() = default;  // 输入是double类型的指针，所以可以是一个数列  void AddVirtualObstacle(double* obstacle_x, double* obstacle_y,                          int vertice_num) &#123;    std::vector&lt;common::math::Vec2d&gt; obstacle_vertices;    for (int i = 0; i &lt; vertice_num; i++) &#123;      common::math::Vec2d vertice(obstacle_x[i], obstacle_y[i]);      obstacle_vertices.emplace_back(vertice);    &#125;    obstacles_list.emplace_back(obstacle_vertices);  &#125;  const std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt;&amp;  // 返回障碍物线段集合  GetObstaclesVerticesVec() &#123;    return obstacles_list;  &#125; private:  std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt; obstacles_list;&#125;;\n\n如果是Box障碍物，则输入五个点，第一个点和最后一个点一致。\n// hybrid_a_star_wrapper.ccclass HybridAResultContainer &#123; public:  HybridAResultContainer() = default;  void LoadResult() &#123;    // 输出结果    x_ = std::move(result_.x);    y_ = std::move(result_.y);    phi_ = std::move(result_.phi);    v_ = std::move(result_.v);    a_ = std::move(result_.a);    steer_ = std::move(result_.steer);  &#125;  std::vector&lt;double&gt;* GetX() &#123; return &amp;x_; &#125;  std::vector&lt;double&gt;* GetY() &#123; return &amp;y_; &#125;  std::vector&lt;double&gt;* GetPhi() &#123; return &amp;phi_; &#125;  std::vector&lt;double&gt;* GetV() &#123; return &amp;v_; &#125;  std::vector&lt;double&gt;* GetA() &#123; return &amp;a_; &#125;  std::vector&lt;double&gt;* GetSteer() &#123; return &amp;steer_; &#125;  HybridAStartResult* PrepareResult() &#123; return &amp;result_; &#125; private:  HybridAStartResult result_;  std::vector&lt;double&gt; x_;  std::vector&lt;double&gt; y_;  std::vector&lt;double&gt; phi_;  std::vector&lt;double&gt; v_;  std::vector&lt;double&gt; a_;  std::vector&lt;double&gt; steer_;&#125;;\n 类C和C++的混合编成\nextern &quot;C&quot; &#123; &#125;的真实目的是实现 类C 和 C++ 的混合编程。在C源文件中的语句前面加上extern &quot;C&quot;，表明它按照 类C 的编译和连接规约来编译和连接，而不是C的编译的连接规约。这样在 类C 的代码中就可以调用C++的函数or变量等。（注：我在这里所说的类C，代表的是跟C语言的编译和连接方式一致的所有语言）\n// hybrid_a_star_wrapper.ccextern &quot;C&quot; &#123;// 创建混合A星解决器指针HybridAStar* CreatePlannerPtr() &#123;  apollo::planning::PlannerOpenSpaceConfig planner_open_space_config_;  // 导入配置参数  CHECK(apollo::cyber::common::GetProtoFromFile(      FLAGS_hybrid_a_star_test_config_filename, &amp;planner_open_space_config_))      &lt;&lt; &quot;Failed to load open space config file &quot;      &lt;&lt; FLAGS_hybrid_a_star_test_config_filename;  AERROR &lt;&lt; FLAGS_hybrid_a_star_test_config_filename;  return new HybridAStar(planner_open_space_config_);&#125;// 创建装载输入障碍物容器，返回指针类型HybridAObstacleContainer* CreateObstaclesPtr() &#123;  return new HybridAObstacleContainer();&#125;// 创建装载计算结果容器，返回指针类型HybridAResultContainer* CreateResultPtr() &#123;  return new HybridAResultContainer();&#125;// 往障碍物容器里面添加障碍物函数void AddVirtualObstacle(HybridAObstacleContainer* obstacles_ptr,                        double* obstacle_x, double* obstacle_y,                        int vertice_num) &#123;  obstacles_ptr-&gt;AddVirtualObstacle(obstacle_x, obstacle_y, vertice_num);&#125;// 关键函数，输入混合A星解决器以及其他条件进行轨迹计算bool Plan(HybridAStar* planner_ptr, HybridAObstacleContainer* obstacles_ptr,          HybridAResultContainer* result_ptr, double sx, double sy, double sphi,          double ex, double ey, double ephi, double* XYbounds) &#123;  std::vector&lt;double&gt; XYbounds_(XYbounds, XYbounds + 4);  return planner_ptr-&gt;Plan(sx, sy, sphi, ex, ey, ephi, XYbounds_,                           obstacles_ptr-&gt;GetObstaclesVerticesVec(),                           result_ptr-&gt;PrepareResult());&#125;// 结果输出函数，将结果分解到对应的数列集里面void GetResult(HybridAResultContainer* result_ptr, double* x, double* y,               double* phi, double* v, double* a, double* steer,               size_t* output_size) &#123;  result_ptr-&gt;LoadResult();  size_t size = result_ptr-&gt;GetX()-&gt;size();  std::cout &lt;&lt; &quot;return size is &quot; &lt;&lt; size &lt;&lt; std::endl;  for (size_t i = 0; i &lt; size; i++) &#123;    x[i] = result_ptr-&gt;GetX()-&gt;at(i);    y[i] = result_ptr-&gt;GetY()-&gt;at(i);    phi[i] = result_ptr-&gt;GetPhi()-&gt;at(i);    v[i] = result_ptr-&gt;GetV()-&gt;at(i);  &#125;  for (size_t i = 0; i &lt; size - 1; i++) &#123;    a[i] = result_ptr-&gt;GetA()-&gt;at(i);    steer[i] = result_ptr-&gt;GetSteer()-&gt;at(i);  &#125;  *output_size = size;&#125;&#125;;\n python与c交互\n怎么告诉 Python 一个外来函数的形参类型和返回的值的类型呢？\n这就要需要给函数的两个属性 restype 和 argtypes 赋值了。它们分别对应返回类型和参数类型。\n如果返回类型是void，可以不用说明。\n# hybrid_a_star_python_interface.py#!/usr/bin/env pythonimport ctypesfrom ctypes import *import math# 加载需要引用的c++库lib = cdll.LoadLibrary(    &#x27;/apollo/lib/libmodules_planning_open_space_tools_hybrid_a_star_wrapper.so&#x27;)# python需要调用到c++库里面的函数，都需要说明下函数的返回类型和参数类型# CreatePlannerPtr()没有输入参数，为空，所以使用[]，或者赋值为 None# CreatePlannerPtr()返回一个类的指针，所以使用c_void_plib.CreatePlannerPtr.argtypes = []lib.CreatePlannerPtr.restype = c_void_plib.CreateResultPtr.argtypes = []lib.CreateResultPtr.restype = c_void_plib.CreateObstaclesPtr.argtypes = []lib.CreateObstaclesPtr.restype = c_void_p# AddVirtualObstacle()输入参数指定类型，注意：指针使用# AddVirtualObstacle()返回是void，所以没有赋值lib.AddVirtualObstacle.argtypes = [c_void_p, POINTER(c_double), POINTER(c_double), c_int]# Plan()函数的返回类型是布尔类型lib.Plan.restype = c_bool# Plan()输入参数类型指定与c++里面代码一一对应lib.Plan.argtypes = [c_void_p, c_void_p, c_void_p, c_double, c_double, c_double, c_double,                     c_double, c_double, POINTER(c_double)]lib.GetResult.argtypes = [c_void_p, POINTER(c_double), POINTER(c_double), POINTER(c_double),            POINTER(c_double), POINTER(c_double), POINTER(c_double), POINTER(c_ushort)]# 定义pytho的一个类，用于外部调用class HybridAStarPlanner(object):    def __init__(self):        self.planner = lib.CreatePlannerPtr()        self.obstacles = lib.CreateObstaclesPtr()        self.result = lib.CreateResultPtr()    def AddVirtualObstacle(self, obstacle_x, obstacle_y, vertice_num):        lib.AddVirtualObstacle(self.obstacles, POINTER(c_double)(obstacle_x),                               POINTER(c_double)(obstacle_y), (c_int)(vertice_num))    def Plan(self, sx, sy, sphi, ex, ey, ephi, XYbounds):        return lib.Plan(self.planner, self.obstacles, self.result, c_double(sx),                        c_double(sy), c_double(sphi), c_double(ex), c_double(ey),                        c_double(ephi), POINTER(c_double)(XYbounds))    def GetResult(self, x, y, phi, v, a, steer, output_size):        lib.GetResult(self.result, POINTER(c_double)(x), POINTER(c_double)(y),                      POINTER(c_double)(phi), POINTER(c_double)(v), POINTER(c_double)(a),                      POINTER(c_double)(steer), POINTER(c_ushort)(output_size))\n# hybrid_a_star_visualizer.py# 先定以一个解决器HybridAStar = HybridAStarPlanner()# 然后通过AddVirtualObstacle()函数增加障碍物约束# 三点是折线，两条线段，三个点HybridAStar.AddVirtualObstacle(left_boundary_x_c, left_boundary_y_c, 3)# 紧接通过Plan()函数进行轨迹规划HybridAStar.Plan(sx, sy, sphi, ex, ey, ephi, XYbounds_ctype)# 最后通过GetResult()函数获得计算结果HybridAStar.GetResult(x, y, phi, v, a, steer, size)\n需要留意：python类型数据作为c++库里函数输入参数时，需要进行数据转换；反之，输出也是。\nleft_boundary_x = [-30.0, 0.0, 0.0]left_boundary_x_c = (c_double * 3)(*left_boundary_x)num_output_buffer = 100000x = (c_double * num_output_buffer)()y = (c_double * num_output_buffer)()\n 配置参数分析\nroi_config &#123;  roi_longitudinal_range: 15.0  parking_start_range: 12.0  parking_inwards: false&#125;warm_start_config &#123;  xy_grid_resolution: 1.5  phi_grid_resolution: 0.6  next_node_num: 10  step_size: 1.5  traj_forward_penalty: 1.0  traj_back_penalty: 1.0  traj_gear_switch_penalty: 10.0  traj_steer_penalty: 1.5  traj_steer_change_penalty: 0.0  grid_a_star_xy_resolution: 1.5  node_radius: 0.25  s_curve_config &#123;    acc_weight: 1.0    jerk_weight: 0.0    kappa_penalty_weight: 100.0    ref_s_weight: 0.1    ref_v_weight: 0.0  &#125;&#125;trajectory_partition_config &#123;  interpolated_pieces_num: 50  initial_gear_check_horizon: 3  heading_searching_range: 0.3  gear_shift_period_duration: 2.0  gear_shift_max_t: 3.0  gear_shift_unit_t: 0.02&#125;delta_t: 0.5is_near_destination_threshold: 0.05enable_check_parallel_trajectory: falseenable_linear_interpolation: false\n warm_start_config\n xy_grid_resolution\nx_grid_ = static_cast&lt;int&gt;(    (x_ - XYbounds[0]) /    open_space_conf.warm_start_config().xy_grid_resolution());y_grid_ = static_cast&lt;int&gt;(    (y_ - XYbounds[2]) /    open_space_conf.warm_start_config().xy_grid_resolution());\n\n phi_grid_resolution\nphi_grid_ = static_cast&lt;int&gt;(      (phi_ - (-M_PI)) /      open_space_conf.warm_start_config().phi_grid_resolution());\n next_node_num\n混合A星当前点往外拓展点的数量，例字如下(next_node_num: 10)\n\n step_size\n基本点之间的距离，决定了输出结果点的数量。\ntraveled_distance = step_size_;double arc = std::sqrt(2) * xy_grid_resolution_;for (size_t i = 0; i &lt; arc / step_size_; ++i) &#123;    const double next_x = last_x + traveled_distance * std::cos(last_phi);    ...&#125;\n\n比如：\n# step_size: 1.5 输出结果如下planning time is 0.00040459632873535156return size is 29\n\n\n# step_size: 0.5 输出结果如下planning time is 0.0005877017974853516return size is 75\n\n\n traj_forward_penalty\n主要是针对混合A星（非RS曲线算法）算法，往前移动一个步长(step_size_)的惩罚系数\npiecewise_cost += static_cast&lt;double&gt;(next_node-&gt;GetStepSize() - 1) *                  step_size_ * traj_forward_penalty_;\n traj_back_penalty\n主要是针对混合A星（非RS曲线算法）算法，往后移动一个步长(step_size_)的惩罚系数\npiecewise_cost += static_cast&lt;double&gt;(next_node-&gt;GetStepSize() - 1) *                  step_size_ * traj_back_penalty_;\n traj_gear_switch_penalty\n主要是针对混合A星（非RS曲线算法）算法，前进后退档位切换的惩罚系数\nif (current_node-&gt;GetDirec() != next_node-&gt;GetDirec()) &#123;  piecewise_cost += traj_gear_switch_penalty_;&#125;\n traj_steer_penalty\n主要是针对混合A星（非RS曲线算法）算法，对方向盘转角惩罚系数，也就是尽量地保持直行\nif (current_node-&gt;GetDirec() != next_node-&gt;GetDirec()) &#123;  piecewise_cost += traj_gear_switch_penalty_;&#125;\n traj_steer_change_penalty\n主要是针对混合A星（非RS曲线算法）算法，对方向盘变化的惩罚系数，也就是要尽量地保持方向盘方向不变\npiecewise_cost += traj_steer_change_penalty_ *                  std::abs(next_node-&gt;GetSteer() - current_node-&gt;GetSteer());\n enable_dp_map\n设置为true时，启发H值采用动态规划算法计算；设置为false时，采用曼哈顿距离或者欧氏距离。\n enable_euler_distance\n设置为true时，使用欧氏距离作为H值；设置为false时，采用曼哈顿距离最为H值。\n grid_a_star_xy_resolution\n通过动态规划获得启发H值，用于计算cost，类似配置参数xy_grid_resolution\n node_radius\n在动态规划算法里，判断与障碍物碰撞的阈值。\nif (linesegment.DistanceTo(&#123;node-&gt;GetGridX(), node-&gt;GetGridY()&#125;) &lt;    node_radius_) &#123;  return false;&#125;\n required_size_of_rs_segs\n限制最短RS曲线的段数。段数不大于设定值。\n delta_t\n混合A星算法得到的路径点，点与点的时间间隔，通过这个参数以及step_size影响速度的计算。\n∣max(velocity)∣≤step_sizedelta_t|max(velocity)|\\leq \\frac{step\\_size}{delta\\_t}\n∣max(velocity)∣≤delta_tstep_size​\ndouble discrete_v = (((result-&gt;x[i + 1] - result-&gt;x[i]) / delta_t_) *                         std::cos(result-&gt;phi[i]) +                     ((result-&gt;x[i] - result-&gt;x[i - 1]) / delta_t_) *                         std::cos(result-&gt;phi[i])) /                        2.0 +                    (((result-&gt;y[i + 1] - result-&gt;y[i]) / delta_t_) *                         std::sin(result-&gt;phi[i]) +                     ((result-&gt;y[i] - result-&gt;y[i - 1]) / delta_t_) *                         std::sin(result-&gt;phi[i])) /                        2.0;\n\n\nstep_size:1.5 delta_t: 0.3\n\nstep_size:1.5 delta_t: 0.5\n\n FLAGS_use_s_curve_speed_smooth\n为true时，使用二次规划算法(GenerateSCurveSpeedAcceleration())生成速度加速度。为false时，使用位置差除时间(GenerateSpeedAcceleration())得到速度，再求加速度。\n\n\n使用GenerateSpeedAcceleration()\n  I0911 17:28:25.671339 570808 hybrid_a_star.cc:906] [planning]searched RS num is 23I0911 17:28:25.671344 570808 hybrid_a_star.cc:907] [planning]explored node num is 59E0911 17:28:25.671348 570808 hybrid_a_star.cc:910] [planning]hybrid astar total time is 0.00175691planning time is 0.0018563270568847656return size is 38\n\n\n\n\n使用GenerateSCurveSpeedAcceleration()\n  I0911 17:54:39.282204 578265 hybrid_a_star.cc:906] [planning]searched RS num is 23I0911 17:54:39.282224 578265 hybrid_a_star.cc:907] [planning]explored node num is 59E0911 17:54:39.282227 578265 hybrid_a_star.cc:910] [planning]hybrid astar total time is 0.0897994planning time is 0.08991193771362305return size is 81\n\n\n\n\n FLAGS_enable_parallel_hybrid_a\n采用多线程形式进行计算RS曲线。\nif (FLAGS_enable_parallel_hybrid_a) &#123;  // AINFO &lt;&lt; &quot;parallel hybrid a*&quot;;  if (!GenerateRSPPar(start_node, end_node, all_possible_paths)) &#123;    ADEBUG &lt;&lt; &quot;Fail to generate general profile of different RSPs&quot;;    return false;  &#125;&#125; else &#123;  if (!GenerateRSP(start_node, end_node, all_possible_paths)) &#123;    AERROR &lt;&lt; &quot;Fail to generate general profile of different RSPs&quot;;    return false;  &#125;&#125;\n","categories":["算法","Apollo源码解读"]},{"title":"Apollo r5.5.0 代码解读之积分(Integral)","url":"/2022/09/26/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E7%A7%AF%E5%88%86(Integral)/","content":"解读integral.h integral.cc文件。\n\n 简介\nI=∫abf(x)dxI=\\int_{a}^{b}f(x)dx \\quad\nI=∫ab​f(x)dx\n只要找到被积公式的原函数F(x)F(x)F(x)，利用牛顿-莱布尼兹公式有：\n∫abf(x)dx=F(b)−F(a)\\int_{a}^{b}f(x)dx=F(b)-F(a)\n∫ab​f(x)dx=F(b)−F(a)\n还可以使用分割法，分割成无穷多个小区间：\n∫abf(x)dx=lim⁡x→∞∑i=1nb−anf(a+b−ani)\\int_{a}^{b}f(x)dx=\\lim_{x \\to \\infty}\\sum_{i=1}^{n}\\frac{b-a}{n}f(a+\\frac{b-a}{n}i)\n∫ab​f(x)dx=x→∞lim​i=1∑n​nb−a​f(a+nb−a​i)\n此外，可以使用数值积分。\n 数值积分：\n 高斯勒让德积分公式(GaussLegendre)\n 理论\n∫abf(x)dx≈∑k=0nAkf(xk)\\int_{a}^{b}f(x)dx\\approx \\sum_{k=0}^{n}A_kf(x_k)\n∫ab​f(x)dx≈k=0∑n​Ak​f(xk​)\n高斯–勒让德求积公式是构造高精度差值积分的最好方法之一。他是通过让节点和积分系数待定让函数f(x)f(x)f(x)以此取i=0,1,2...ni=0,1,2 ...ni=0,1,2...n次多项式使其尽可能多的能够精确成立来求出积分节点和积分系数。高斯积分的代数精度是2n−12n-12n−1，而且是最高的。通常的运用的是(−1,1)(-1,1)(−1,1)的积分节点和积分系数，其他积分域是通过变换公式x=(b−a)∗t/2+(b+a)/2x=(b-a)*t/2+(b+a)/2x=(b−a)∗t/2+(b+a)/2变换到-1到1之间积分。t∈(−1,1)t \\in (-1,1)t∈(−1,1)\nf(x)x∈(a,b)f(x) \\quad x\\in(a,b) \nf(x)x∈(a,b)\nx=(b−a)∗t/2+(b+a)/2t∈(−1,1)x=(b-a)*t/2+(b+a)/2 \\quad t\\in(-1,1)\nx=(b−a)∗t/2+(b+a)/2t∈(−1,1)\n⇔f((b−a)∗t/2+(b+a)/2)t∈(−1,1)\\Leftrightarrow\nf((b-a)*t/2+(b+a)/2) \\quad t\\in(-1,1)\n⇔f((b−a)∗t/2+(b+a)/2)t∈(−1,1)\n⇔g(t)t∈(−1,1)\\Leftrightarrow\ng(t) \\quad t\\in(-1,1)\n⇔g(t)t∈(−1,1)\n∫abf(x)dx=b−a2∫−11f((b−a)∗t/2+(b+a)/2)dt=b−a2∫−11g(t)dt\\int_{a}^{b}f(x)dx= \\frac{b-a}{2}\\int_{-1}^{1}f((b-a)*t/2+(b+a)/2)dt = \\frac{b-a}{2}\\int_{-1}^{1}g(t)dt\n∫ab​f(x)dx=2b−a​∫−11​f((b−a)∗t/2+(b+a)/2)dt=2b−a​∫−11​g(t)dt\n最终使用的标准形式：\n∫−11f(x)dx≈∑k=0nAkf(xk)\\int_{-1}^{1}f(x)dx\\approx \\sum_{k=0}^{n}A_kf(x_k)\n∫−11​f(x)dx≈k=0∑n​Ak​f(xk​)\ne.g.n=4e.g. \\quad n=4\ne.g.n=4\n∫−11f(x)dx≈A0f(x0)+A1f(x1)+A2f(x2)+A3f(x3)+A4f(x4)\\int_{-1}^{1}f(x)dx\\approx A_0f(x_0) + A_1f(x_1) + A_2f(x_2) + A_3f(x_3) + A_4f(x_4) \n∫−11​f(x)dx≈A0​f(x0​)+A1​f(x1​)+A2​f(x2​)+A3​f(x3​)+A4​f(x4​)\n有五组(n+1)(n+1)(n+1)系数(xk,Ak)(x_k, A_k)(xk​,Ak​)\n下表列出高斯–勒让德求积公式的节点和系数\n\n\n\nn\nxkx_kxk​\nAkA_kAk​\n\n\n\n\n0\n0.00.00.0\n2.02.02.0\n\n\n1\n±0.577350269189625764507\\pm 0.577350269189625764507±0.577350269189625764507\n1.01.01.0\n\n\n2\n0.00.00.0±0.774596669241483377010\\pm 0.774596669241483377010±0.774596669241483377010\n0.8888888888888888888770.8888888888888888888770.8888888888888888888770.5555555555555555555620.5555555555555555555620.555555555555555555562\n\n\n3\n±0.339981043584856264792\\pm 0.339981043584856264792±0.339981043584856264792±0.861136311594052575248\\pm 0.861136311594052575248±0.861136311594052575248\n0.6521451548625461426440.6521451548625461426440.6521451548625461426440.3478548451374538573830.3478548451374538573830.347854845137453857383\n\n\n4\n0.00.00.0±0.538469310105683091018\\pm 0.538469310105683091018±0.538469310105683091018±0.906179845938663992811\\pm 0.906179845938663992811±0.906179845938663992811\n0.5688888888888888888830.5688888888888888888830.5688888888888888888830.4786286704993664680300.4786286704993664680300.4786286704993664680300.2369268850561890875150.2369268850561890875150.236926885056189087515\n\n\n5\n±0.661209386466264513688\\pm 0.661209386466264513688±0.661209386466264513688±0.238619186083196908630\\pm 0.238619186083196908630±0.238619186083196908630±0.932469514203152027832\\pm 0.932469514203152027832±0.932469514203152027832\n0.3607615730481386075690.3607615730481386075690.3607615730481386075690.4679139345726910473890.4679139345726910473890.4679139345726910473890.1713244923791703450430.1713244923791703450430.171324492379170345043\n\n\n6\n0.00.00.0±0.405845151377397166917\\pm 0.405845151377397166917±0.405845151377397166917±0.741531185599394439864\\pm 0.741531185599394439864±0.741531185599394439864±0.949107912342758524541\\pm 0.949107912342758524541±0.949107912342758524541\n0.4179591836734693877490.4179591836734693877490.4179591836734693877490.3818300505051189449610.3818300505051189449610.3818300505051189449610.2797053914892766678900.2797053914892766678900.2797053914892766678900.1294849661688696932740.1294849661688696932740.129484966168869693274\n\n\n7\n±0.183434642495649804936\\pm 0.183434642495649804936±0.183434642495649804936±0.525532409916328985830\\pm 0.525532409916328985830±0.525532409916328985830±0.796666477413626739567\\pm 0.796666477413626739567±0.796666477413626739567±0.960289856497536231661\\pm 0.960289856497536231661±0.960289856497536231661\n0.3626837833783619829760.3626837833783619829760.3626837833783619829760.3137066458778872873380.3137066458778872873380.3137066458778872873380.2223810344533744705460.2223810344533744705460.2223810344533744705460.1012285362903762591540.1012285362903762591540.101228536290376259154\n\n\n8\n0.00.00.0±0.836031107326635794313\\pm 0.836031107326635794313±0.836031107326635794313±0.968160239507626089810\\pm 0.968160239507626089810±0.968160239507626089810±0.324253423403808929042\\pm 0.324253423403808929042±0.324253423403808929042±0.613371432700590397285\\pm 0.613371432700590397285±0.613371432700590397285\n0.3302393550012597631540.3302393550012597631540.3302393550012597631540.1806481606948574040590.1806481606948574040590.1806481606948574040590.8127438836157441197370.8127438836157441197370.8127438836157441197370.3123470770400028400570.3123470770400028400570.3123470770400028400570.2606106964029354623130.2606106964029354623130.260610696402935462313\n\n\n9\n±0.148874338981631210881\\pm 0.148874338981631210881±0.148874338981631210881±0.433395394129247190794\\pm 0.433395394129247190794±0.433395394129247190794±0.679409568299024406207\\pm 0.679409568299024406207±0.679409568299024406207±0.865063366688984510759\\pm 0.865063366688984510759±0.865063366688984510759±0.973906528517171720066\\pm 0.973906528517171720066±0.973906528517171720066\n0.2955242247147528701870.2955242247147528701870.2955242247147528701870.2692667193099963551050.2692667193099963551050.2692667193099963551050.2190863625159820440000.2190863625159820440000.2190863625159820440000.1494513491505805931500.1494513491505805931500.1494513491505805931500.6667134430868813759200.6667134430868813759200.666713443086881375920\n\n\n\n 代码实现\n/** * @brief Compute the integral of a target single-variable function *        from a lower bound to an upper bound, by 5-th Gauss-Legendre method * Given a target function and integral lower and upper bound, * compute the integral approximation using 5th order Gauss-Legendre * integration. * The target function must be a smooth function. * Example: * target function: auto func = [](const double x) &#123;return x * x;&#125;; *                  double integral = gauss_legendre(func, -2, 3); * This gives you the approximated integral of function x^2 in bound [-2, 3] * * reference: https://en.wikipedia.org/wiki/Gaussian_quadrature *            http://www.mymathlib.com/quadrature/gauss_legendre.html * * @param func The target single-variable function * @param lower_bound The lower bound of the integral * @param upper_bound The upper bound of the integral * @return The integral result */template &lt;std::size_t N&gt;double IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,                                const double lower_bound,                                const double upper_bound) &#123;  // 根据输入阶数，获取对应系数，这里N对应上表的n+1  // Apollo提供了N从2到10，也就是上表n从1到9  auto p = GetGaussLegendrePoints&lt;N&gt;();  std::array&lt;double, N&gt; x = p.first;  std::array&lt;double, N&gt; w = p.second;  // 复化系数  const double t = (upper_bound - lower_bound) * 0.5;  const double m = (upper_bound + lower_bound) * 0.5;  double integral = 0.0;  for (size_t i = 0; i &lt; N; ++i) &#123;    // 逐一累加各项和    integral += w[i] * func(t * x[i] + m);  &#125;  // 注意还乘t  return integral * t;&#125;/** * @brief Get the points and weights for different ordered Gauss-Legendre *        integration. Currently support order 2 - 10. Other input order will *        trigger compiling error. */template &lt;std::size_t N&gt;std::pair&lt;std::array&lt;double, N&gt;, std::array&lt;double, N&gt;&gt;GetGaussLegendrePoints();template &lt;&gt;inline std::pair&lt;std::array&lt;double, 2&gt;, std::array&lt;double, 2&gt;&gt;GetGaussLegendrePoints&lt;2&gt;() &#123;  std::array&lt;double, 2&gt; x;  x[0] = -5.77350269189625764507e-01;  x[1] = 5.77350269189625764507e-01;  std::array&lt;double, 2&gt; w;  w[0] = 1.0;  w[1] = 1.0;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 3&gt;, std::array&lt;double, 3&gt;&gt;GetGaussLegendrePoints&lt;3&gt;() &#123;  std::array&lt;double, 3&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 7.74596669241483377010e-01;  x[2] = -7.74596669241483377010e-01;  std::array&lt;double, 3&gt; w;  w[0] = 8.88888888888888888877e-01;  w[1] = 5.55555555555555555562e-01;  w[2] = 5.55555555555555555562e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 4&gt;, std::array&lt;double, 4&gt;&gt;GetGaussLegendrePoints&lt;4&gt;() &#123;  std::array&lt;double, 4&gt; x;  x[0] = 3.39981043584856264792e-01;  x[1] = -3.39981043584856264792e-01;  x[2] = 8.61136311594052575248e-01;  x[3] = -8.61136311594052575248e-01;  std::array&lt;double, 4&gt; w;  w[0] = 6.52145154862546142644e-01;  w[1] = 6.52145154862546142644e-01;  w[2] = 3.47854845137453857383e-01;  w[3] = 3.47854845137453857383e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 5&gt;, std::array&lt;double, 5&gt;&gt;GetGaussLegendrePoints&lt;5&gt;() &#123;  std::array&lt;double, 5&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 5.38469310105683091018e-01;  x[2] = -5.38469310105683091018e-01;  x[3] = 9.06179845938663992811e-01;  x[4] = -9.06179845938663992811e-01;  std::array&lt;double, 5&gt; w;  w[0] = 5.68888888888888888883e-01;  w[1] = 4.78628670499366468030e-01;  w[2] = 4.78628670499366468030e-01;  w[3] = 2.36926885056189087515e-01;  w[4] = 2.36926885056189087515e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 6&gt;, std::array&lt;double, 6&gt;&gt;GetGaussLegendrePoints&lt;6&gt;() &#123;  std::array&lt;double, 6&gt; x;  x[0] = 6.61209386466264513688e-01;  x[1] = -6.61209386466264513688e-01;  x[2] = 2.38619186083196908630e-01;  x[3] = -2.38619186083196908630e-01;  x[4] = 9.32469514203152027832e-01;  x[5] = -9.32469514203152027832e-01;  std::array&lt;double, 6&gt; w;  w[0] = 3.60761573048138607569e-01;  w[1] = 3.60761573048138607569e-01;  w[2] = 4.67913934572691047389e-01;  w[3] = 4.67913934572691047389e-01;  w[4] = 1.71324492379170345043e-01;  w[5] = 1.71324492379170345043e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 7&gt;, std::array&lt;double, 7&gt;&gt;GetGaussLegendrePoints&lt;7&gt;() &#123;  std::array&lt;double, 7&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 4.05845151377397166917e-01;  x[2] = -4.05845151377397166917e-01;  x[3] = 7.41531185599394439864e-01;  x[4] = -7.41531185599394439864e-01;  x[5] = 9.49107912342758524541e-01;  x[6] = -9.49107912342758524541e-01;  std::array&lt;double, 7&gt; w;  w[0] = 4.17959183673469387749e-01;  w[1] = 3.81830050505118944961e-01;  w[2] = 3.81830050505118944961e-01;  w[3] = 2.79705391489276667890e-01;  w[4] = 2.79705391489276667890e-01;  w[5] = 1.29484966168869693274e-01;  w[6] = 1.29484966168869693274e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 8&gt;, std::array&lt;double, 8&gt;&gt;GetGaussLegendrePoints&lt;8&gt;() &#123;  std::array&lt;double, 8&gt; x;  x[0] = 1.83434642495649804936e-01;  x[1] = -1.83434642495649804936e-01;  x[2] = 5.25532409916328985830e-01;  x[3] = -5.25532409916328985830e-01;  x[4] = 7.96666477413626739567e-01;  x[5] = -7.96666477413626739567e-01;  x[6] = 9.60289856497536231661e-01;  x[7] = -9.60289856497536231661e-01;  std::array&lt;double, 8&gt; w;  w[0] = 3.62683783378361982976e-01;  w[1] = 3.62683783378361982976e-01;  w[2] = 3.13706645877887287338e-01;  w[3] = 3.13706645877887287338e-01;  w[4] = 2.22381034453374470546e-01;  w[5] = 2.22381034453374470546e-01;  w[6] = 1.01228536290376259154e-01;  w[7] = 1.01228536290376259154e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 9&gt;, std::array&lt;double, 9&gt;&gt;GetGaussLegendrePoints&lt;9&gt;() &#123;  std::array&lt;double, 9&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 8.36031107326635794313e-01;  x[2] = -8.36031107326635794313e-01;  x[3] = 9.68160239507626089810e-01;  x[4] = -9.68160239507626089810e-01;  x[5] = 3.24253423403808929042e-01;  x[6] = -3.24253423403808929042e-01;  x[7] = 6.13371432700590397285e-01;  x[8] = -6.13371432700590397285e-01;  std::array&lt;double, 9&gt; w;  w[0] = 3.30239355001259763154e-01;  w[1] = 1.80648160694857404059e-01;  w[2] = 1.80648160694857404059e-01;  w[3] = 8.12743883615744119737e-02;  w[4] = 8.12743883615744119737e-02;  w[5] = 3.12347077040002840057e-01;  w[6] = 3.12347077040002840057e-01;  w[7] = 2.60610696402935462313e-01;  w[8] = 2.60610696402935462313e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 10&gt;, std::array&lt;double, 10&gt;&gt;GetGaussLegendrePoints&lt;10&gt;() &#123;  std::array&lt;double, 10&gt; x;  x[0] = 1.48874338981631210881e-01;  x[1] = -1.48874338981631210881e-01;  x[2] = 4.33395394129247190794e-01;  x[3] = -4.33395394129247190794e-01;  x[4] = 6.79409568299024406207e-01;  x[5] = -6.79409568299024406207e-01;  x[6] = 8.65063366688984510759e-01;  x[7] = -8.65063366688984510759e-01;  x[8] = 9.73906528517171720066e-01;  x[9] = -9.73906528517171720066e-01;  std::array&lt;double, 10&gt; w;  w[0] = 2.95524224714752870187e-01;  w[1] = 2.95524224714752870187e-01;  w[2] = 2.69266719309996355105e-01;  w[3] = 2.69266719309996355105e-01;  w[4] = 2.19086362515982044000e-01;  w[5] = 2.19086362515982044000e-01;  w[6] = 1.49451349150580593150e-01;  w[7] = 1.49451349150580593150e-01;  w[8] = 6.66713443086881375920e-02;  w[9] = 6.66713443086881375920e-02;  return std::make_pair(x, w);&#125;\n 梯形(Trapezoidal)求积公式\n 理论\n要求f(x)f(x)f(x)在[a,b][ a , b ][a,b]上的积分，将积分区间等长分成nnn段，则每两个分段点之间的距离h=b−anh=\\frac{b-a}{n}h=nb−a​，然后如下图进行近似：\n\n则该区间上的积分值就近似等同于每个小梯形的面积之和。\n第一个梯形（最左边）的上底f(x0)f(x_0)f(x0​)，下底f(x1)f(x_1)f(x1​)，高为h=b−anh=\\frac{b-a}{n}h=nb−a​，因此对应的面积为S1=(f(x0)+f(x1))∗h/2S_1=(f(x_0)+f(x_1))*h/2S1​=(f(x0​)+f(x1​))∗h/2。\n以此类推，最后一个（最右边）的上底f(xn−1)f(x_{n-1})f(xn−1​)，下底f(xn)f(x_n)f(xn​)，高为h=b−anh=\\frac{b-a}{n}h=nb−a​，因此对应的面积为Sn=(f(xn−1)+f(xn))∗h/2S_n=(f(x_{n-1})+f(x_n))*h/2Sn​=(f(xn−1​)+f(xn​))∗h/2。\n因此，所有梯形的总面积为：\n∫abf(x)dx≈∑i=1nSi=S1+S2+...+Sn=h/2[f(x0)+f(x1)+f(x1)+f(x2)+...+f(xn−2)+f(xn−1)+f(xn−1)+f(xn)]=h2[f(x0)+2∑i=1n−1f(xi)+f(xn)]=h∗∑i=1n−1f(xi)+0.5∗h(f(x0)+f(xn))\\begin{aligned}\n\\int_{a}^{b}f(x)dx \\approx \\sum_{i=1}^{n}S_i = S_1+S_2+...+S_n\n= h/2[f(x_0)+f(x_1)+f(x_1)+f(x_2)+...+f(x_{n-2})+f(x_{n-1})+f(x_{n-1})+f(x_n)] \\\\ \n= \\frac{h}{2}[f(x_0)+2\\sum_{i=1}^{n-1}f(x_i)+f(x_n)] \\\\\n= h*\\sum_{i=1}^{n-1}f(x_i)+0.5*h(f(x_0)+f(x_n))\n\\end{aligned}\n∫ab​f(x)dx≈i=1∑n​Si​=S1​+S2​+...+Sn​=h/2[f(x0​)+f(x1​)+f(x1​)+f(x2​)+...+f(xn−2​)+f(xn−1​)+f(xn−1​)+f(xn​)]=2h​[f(x0​)+2i=1∑n−1​f(xi​)+f(xn​)]=h∗i=1∑n−1​f(xi​)+0.5∗h(f(x0​)+f(xn​))​\n 代码实现\ndouble IntegrateByTrapezoidal(const std::vector&lt;double&gt;&amp; func, const double dx,                              const std::size_t nsteps) &#123;  // nsteps表示func集合元素的个数，也就是下标从0到nsteps-1，也就是意味着有nsteps-1个梯形  // 如参func为f(x_0)到f(x_&#123;nsteps-1&#125;)的集合，有nsteps个数，有nsteps-1个梯形  // dx就是步长(b-a)/(nsteps-1)，也就是公式里面的h  double sum = 0;  for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) &#123;    // 从i=1到i=nsteps-2的累加和    sum += func[i];  &#125;  return dx * sum + 0.5 * dx * (func[0] + func[nsteps - 1]);&#125;\n 辛普森(Simpson)求积公式\n 理论\n要求将区间划分成偶数个。\n\n辛普森积分法是一种用抛物线近似函数曲线来求定积分数值解的方法。把积分区间等分成若干段，对被积函数在每一段上使用辛普森公式，根据其在每一段的两端和中点处的值近似为抛物线，逐段积分后加起来，即得到原定积分的数值解。\n基本思想就是把复杂的函数f(x)f(x)f(x)近似成二次函数。\n∫abf(x)dx≈∫ab(Ax2+Bx+C)dx=A3(b3−a3)+B2(b2−a2)+C(b−a)=2A(b3−a3)+3B(b2−a2)+6C(b−a)6=(b−a)[2A(b2+ab+a2)+3B(b+a)+6C]6=(b−a)(Aa2+Ba+C+Ab2+Bb+C+Aa2+2Aab+Ab2+2Bb+2Ba+4C)6=(b−a)[f(a)+f(b)+A(a+b)2+2B(a+b)+4C]6=(b−a)[f(a)+f(b)+4(A(a+b2)2+Ba+b2+C)]6=(b−a)[f(a)+f(b)+4f(a+b2)]6\\begin{aligned}\n&amp;\\int_a^bf(x)dx \\approx \\int_a^b(Ax^2+Bx+C)dx \\\\\n&amp;=\\frac{A}{3}(b^3-a^3)+\\frac{B}{2}(b^2-a^2)+C(b-a) \\\\\n&amp;=\\frac{2A(b^3-a^3)+3B(b^2-a^2)+6C(b-a)}{6} \\\\\n&amp;=\\frac{(b-a)[2A(b^2+ab+a^2)+3B(b+a)+6C]}{6} \\\\\n&amp;=\\frac{(b-a)(Aa^2+Ba+C+Ab^2+Bb+C+Aa^2+2Aab+Ab^2+2Bb+2Ba+4C)}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+A(a+b)^2+2B(a+b)+4C]}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+4(A(\\frac{a+b}{2})^2+B\\frac{a+b}{2}+C)]}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+4f(\\frac{a+b}{2})]}{6}\n\\end{aligned}\n​∫ab​f(x)dx≈∫ab​(Ax2+Bx+C)dx=3A​(b3−a3)+2B​(b2−a2)+C(b−a)=62A(b3−a3)+3B(b2−a2)+6C(b−a)​=6(b−a)[2A(b2+ab+a2)+3B(b+a)+6C]​=6(b−a)(Aa2+Ba+C+Ab2+Bb+C+Aa2+2Aab+Ab2+2Bb+2Ba+4C)​=6(b−a)[f(a)+f(b)+A(a+b)2+2B(a+b)+4C]​=6(b−a)[f(a)+f(b)+4(A(2a+b​)2+B2a+b​+C)]​=6(b−a)[f(a)+f(b)+4f(2a+b​)]​​\n先求定积分∫abf(x)dx(a&lt;b)\\int_a^bf(x)dx \\quad (a&lt;b)∫ab​f(x)dx(a&lt;b)\n将闭区间等分成2n2n2n，即偶数个小区间[xi,xi+1](xi&lt;xi+1,x0=a,x2n=b,i∈[0,2n])[x_i, x_{i+1}] \\quad (x_i&lt;x_{i+1},x_0=a,x_{2n}=b,i\\in[0,2n])[xi​,xi+1​](xi​&lt;xi+1​,x0​=a,x2n​=b,i∈[0,2n])。在每个小区间上，用抛物线近似函数f(x)f(x)f(x)的曲线。每个区间长度为b−a2n\\frac{b-a}{2n}2nb−a​。\n以两个区间为基本单位，基本单位长度为b−an\\frac{b-a}{n}nb−a​，使用辛普森公式近似求积分：\ne.g.∫x0x2f(x)dx≈(x2−x0)[f(x0)+f(x2)+4f(x1)]6=(b−a)6n[f(x0)+4f(x1)+f(x2)]e.g. \\quad \\int_{x_0}^{x_2} f(x)dx\\approx \\frac{(x_2-x_0)[f(x_0)+f(x_2)+4f(x_1)]}{6} \\\\\n= \\frac{(b-a)}{6n} [f(x_0)+4f(x_1)+f(x_2)]\\\\\ne.g.∫x0​x2​​f(x)dx≈6(x2​−x0​)[f(x0​)+f(x2​)+4f(x1​)]​=6n(b−a)​[f(x0​)+4f(x1​)+f(x2​)]\ne.g.∫x2n−2x2nf(x)dx≈(x2n−x2n−2)[f(x2n−2)+f(x2n)+4f(x2n−1)]6=(b−a)6n[f(x2n−2)+4f(x2n−1)+f(x2n)]e.g. \\quad \\int_{x_{2n-2}}^{x_{2n}} f(x)dx\\approx \\frac{(x_{2n}-x_{2n-2})[f(x_{2n-2})+f(x_{2n})+4f(x_{2n-1})]}{6} \\\\\n= \\frac{(b-a)}{6n} [f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n})]\\\\\ne.g.∫x2n−2​x2n​​f(x)dx≈6(x2n​−x2n−2​)[f(x2n−2​)+f(x2n​)+4f(x2n−1​)]​=6n(b−a)​[f(x2n−2​)+4f(x2n−1​)+f(x2n​)]\n所以累加全部基本单位，可得：\n∫abf(x)dx≈∫x0x2f(x)dx+∫x2x4f(x)dx+...+∫x2n−2x2nf(x)dx=b−a6n[f(x0)+4f(x1)+f(x2)+f(x2)+4f(x3)+f(x4)+...+f(x2n−2)+4f(x2n−1)+f(x2n)]=b−a3∗2n[f(x0)+f(x2n)+4[f(x1)+f(x3)+...+f(x2n−1)]+2[f(x2)+f(x4)+...+f(x2n−2)]]\\begin{aligned}\n\\int_a^bf(x)dx \\approx \\int_{x_0}^{x_2} f(x)dx+\\int_{x_2}^{x_4} f(x)dx+...+\\int_{x_{2n-2}}^{x_{2n}} f(x)dx \\\\\n=\\frac{b-a}{6n}[f(x_0)+4f(x_1)+f(x_2) + f(x_2)+4f(x_3)+f(x_4) + ... + f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n})] \\\\\n=\\frac{b-a}{3*2n}[f(x_0)+f(x_{2n}) + 4[f(x_1)+f(x_3)+...+f(x_{2n-1})] + 2[f(x_2)+f(x_4)+...+f(x_{2n-2})]] \\\\\n\\end{aligned}\n∫ab​f(x)dx≈∫x0​x2​​f(x)dx+∫x2​x4​​f(x)dx+...+∫x2n−2​x2n​​f(x)dx=6nb−a​[f(x0​)+4f(x1​)+f(x2​)+f(x2​)+4f(x3​)+f(x4​)+...+f(x2n−2​)+4f(x2n−1​)+f(x2n​)]=3∗2nb−a​[f(x0​)+f(x2n​)+4[f(x1​)+f(x3​)+...+f(x2n−1​)]+2[f(x2​)+f(x4​)+...+f(x2n−2​)]]​\n 代码实现\ndouble IntegrateBySimpson(const std::vector&lt;double&gt;&amp; func, const double dx,                          const std::size_t nsteps) &#123;  // nsteps表示func集合元素的个数，也就是下标从0到nsteps-1，也就是意味着有nsteps-1个梯形  // 要求nsteps为奇数，也就是平分成偶数个梯形，nsteps-1个区间  // 如参func为f(x_0)到f(x_&#123;nsteps-1&#125;)的集合，有nsteps个数，有nsteps-1个梯形，即偶数个梯形  // dx就是步长(b-a)/(nsteps-1)，也就是每个区间的长度  CHECK_EQ(1, nsteps &amp; 1);  double sum1 = 0.0;  double sum2 = 0.0;  for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) &#123;    if ((i &amp; 1) != 0) &#123;      // 奇数求和      sum1 += func[i];    &#125; else &#123;      // 偶数求和      sum2 += func[i];    &#125;  &#125;  return dx / 3.0 * (4.0 * sum1 + 2.0 * sum2 + func[0] + func[nsteps - 1]);&#125;\n 参考文献\n[1]https://blog.csdn.net/xyz32768/article/details/81392369\n[2]https://baike.baidu.com/item/辛普森积分法/23337870?fr=aladdin\n[3]https://blog.csdn.net/justidle/article/details/112839920\n[4]https://wenku.baidu.com/view/b3fc62d74b7302768e9951e79b89680203d86bb7.html\n[5]https://max.book118.com/html/2019/0414/7142125161002020.shtm\n","categories":["Apollo源码解读"]},{"title":"Apollo r5.5.0 代码解读之规划模块--多项次曲线","url":"/2021/02/02/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E8%A7%84%E5%88%92%E6%A8%A1%E5%9D%97--%E5%A4%9A%E9%A1%B9%E6%AC%A1%E6%9B%B2%E7%BA%BF/","content":" 简介\n点到点的轨迹规划算法可以理解为在规划的时间TTT内，从已知起始点 θstart\\theta_{start}θstart​运动到末尾点θend\\theta_{end}θend​的方法。这里引入中间变量s(t)s(t)s(t)，它是时间的函数，定义域[0,T][0,T][0,T]，值域[0,1][0,1][0,1]，sss与θ\\thetaθ的关系见下面公式。这个公式不难理解，当s=0s=0s=0时，θ=θstart\\theta=\\theta_{start}θ=θstart​；当s=1s=1s=1时，θ=θend\\theta=\\theta_{end}θ=θend​。\n\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)&amp;=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns&amp;=s(t),t\\in[0,T] \\\\\n\\end{aligned}\nθ(s)s​=θstart​+s(θend​−θstart​),s∈[0,1]=s(t),t∈[0,T]​\nθ\\thetaθ对ttt求导是速度，即：\n∂θ∂t=∂θ∂s⋅∂s∂t其中∂θ∂s=θend−θstart∂θ∂t=(θend−θstart)⋅∂s∂t\\begin{aligned}\n\\frac{\\partial\\theta}{\\partial t}&amp;= \\frac{\\partial\\theta}{\\partial s} \\cdot \\frac{\\partial s}{\\partial t} \\quad其中\\frac{\\partial\\theta}{\\partial s}=\\theta_{end} -\\theta_{start} \\\\\n\\frac{\\partial\\theta}{\\partial t}&amp;=(\\theta_{end} -\\theta_{start})\\cdot \\frac{\\partial s}{\\partial t} \\\\\n\\end{aligned}\n∂t∂θ​∂t∂θ​​=∂s∂θ​⋅∂t∂s​其中∂s∂θ​=θend​−θstart​=(θend​−θstart​)⋅∂t∂s​​\nθ\\thetaθ对ttt求二阶导是加速度，即\n∂2θ∂t2=∂(∂θ∂s)∂t⋅∂s∂t+∂θ∂s⋅∂2s∂t2其中∂(∂θ∂s)∂t=∂(θend−θstart)∂t=0∂2θ∂t2=(θend−θstart)⋅∂2s∂t2\\begin{aligned}\n\\frac{\\partial^2\\theta}{\\partial t^2}&amp;= \\frac{\\partial(\\frac{\\partial\\theta}{\\partial s})}{\\partial t} \\cdot \\frac{\\partial s}{\\partial t}+\\frac{\\partial\\theta}{\\partial s} \\cdot \\frac{\\partial^2 s}{\\partial t^2} \\quad其中\\frac{\\partial(\\frac{\\partial\\theta}{\\partial s})}{\\partial t}=\\frac{\\partial(\\theta_{end} -\\theta_{start})}{\\partial t}=0 \\\\\n\\frac{\\partial^2\\theta}{\\partial t^2}&amp;=(\\theta_{end} -\\theta_{start})\\cdot \\frac{\\partial^2 s}{\\partial t^2} \\\\\n\\end{aligned}\n∂t2∂2θ​∂t2∂2θ​​=∂t∂(∂s∂θ​)​⋅∂t∂s​+∂s∂θ​⋅∂t2∂2s​其中∂t∂(∂s∂θ​)​=∂t∂(θend​−θstart​)​=0=(θend​−θstart​)⋅∂t2∂2s​​\n由于θstart\\theta_{start}θstart​和θend\\theta_{end}θend​是已知的，所以速度和加速度随时间的变化取决与s=s(t),t∈[0,T]s=s(t),t\\in[0,T]s=s(t),t∈[0,T]。\n这里的s(t)s(t)s(t)有很多种方法，比较常见的是三次函数，五次函数，梯形函数，S曲线等。\n 三次曲线–&gt;cubic polynomial curve1d\nCubicPolynomialCurve1d::CubicPolynomialCurve1d(const double x0,                                               const double dx0,                                               const double ddx0,                                               const double x1,                                               const double param) &#123;  ComputeCoefficients(x0, dx0, ddx0, x1, param);  param_ = param;  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_ = x1;&#125;\ns(t)=a0+a1t+a2t2+a3t3s(t)=a_0 + a_1t + a_2t^2 + a_3t^3\ns(t)=a0​+a1​t+a2​t2+a3​t3\n入参初始条件\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02s(T)=a0+a1T+a2T2+a3T3=x1  ⟺  a3=x1−x0−dx0T−ddx02T2T3\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\ns(T) = a_0 + a_1T + a_2T^2 + a_3T^3 = x_1 \\iff a_3 = \\frac{x_1 - x_0 - dx_0T - \\frac{ddx_0}{2}T^2}{T^3}\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​s(T)=a0​+a1​T+a2​T2+a3​T3=x1​⟺a3​=T3x1​−x0​−dx0​T−2ddx0​​T2​​\nvoid CubicPolynomialCurve1d::ComputeCoefficients(const double x0,                                                 const double dx0,                                                 const double ddx0,                                                 const double x1,                                                 const double param) &#123;  DCHECK(param &gt; 0.0);  const double p2 = param * param;  const double p3 = param * p2;  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  coef_[3] = (x1 - x0 - dx0 * param - coef_[2] * p2) / p3;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble CubicPolynomialCurve1d::Evaluate(const std::uint32_t order,                                        const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return ((coef_[3] * p + coef_[2]) * p + coef_[1]) * p + coef_[0];    &#125;    case 1: &#123;      return (3.0 * coef_[3] * p + 2.0 * coef_[2]) * p + coef_[1];    &#125;    case 2: &#123;      return 6.0 * coef_[3] * p + 2.0 * coef_[2];    &#125;    case 3: &#123;      return 6.0 * coef_[3];    &#125;    default:      return 0.0;  &#125;&#125;\n 四次曲线–&gt;quartic polynomial curve1d\nQuarticPolynomialCurve1d::QuarticPolynomialCurve1d(    const double x0, const double dx0, const double ddx0, const double dx1,    const double ddx1, const double param) &#123;  param_ = param;  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_[0] = dx1;  end_condition_[1] = ddx1;  ComputeCoefficients(x0, dx0, ddx0, dx1, ddx1, param);&#125;\ns(t)=a0+a1t+a2t2+a3t3+a4t4s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4\ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4\n 入参初始条件（一）: x0, dx0, ddx0, dx1, ddx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(1)s&#x27;(T) = a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 1\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(1)\ns′′(T)=2a2+6a3T+12a4T2=ddx1(2)s&#x27;&#x27;(T) = 2a_2 + 6a_3T + 12a_4T^2 = ddx_1 \\tag2\ns′′(T)=2a2​+6a3​T+12a4​T2=ddx1​(2)\n公式3*(1)-T*(2)得：\n3a1+6a2T+9a3T2+12a4T3=3dx12a2T+6a3T2+12a4T3=T∗ddx1  ⟺  3a1+4a2T+3a3T2=3dx1−T∗ddx1  ⟺  a3=3dx1−T∗ddx1−3a1−4a2T3T2  ⟺  a3=3dx1−T∗ddx1−3dx0−2ddx0T3T2  ⟺  a3=3(dx1−ddx0T−dx0)−T∗(ddx1−ddx0)3T2\\begin{aligned}\n3a_1 + 6a_2T + 9a_3T^2 +12a_4T^3 &amp; = 3dx_1 \\\\\n2a_2T + 6a_3T^2 + 12a_4T^3&amp; = T*ddx_1 \\\\\n\\iff 3a_1 + 4a_2T +3a_3T^2 &amp;= 3dx_1 - T*ddx_1 \\\\\n\\iff a_3 &amp; = \\frac{3dx_1 - T*ddx_1-3a_1-4a_2T}{3T^2} \\\\\n\\iff a_3 &amp; = \\frac{3dx_1 - T*ddx_1-3dx_0 -2ddx_0T}{3T^2} \\\\\n\\iff a_3 &amp; = \\frac{3(dx_1 - ddx_0T - dx_0) - T*(ddx_1 - ddx_0)}{3T^2} \n\\end{aligned}\n3a1​+6a2​T+9a3​T2+12a4​T32a2​T+6a3​T2+12a4​T3⟺3a1​+4a2​T+3a3​T2⟺a3​⟺a3​⟺a3​​=3dx1​=T∗ddx1​=3dx1​−T∗ddx1​=3T23dx1​−T∗ddx1​−3a1​−4a2​T​=3T23dx1​−T∗ddx1​−3dx0​−2ddx0​T​=3T23(dx1​−ddx0​T−dx0​)−T∗(ddx1​−ddx0​)​​\n公式2(1)-T(2)得：\n2a1+4a2T+6a3T2+8a4T3=2dx12a2T+6a3T2+12a4T3=T∗ddx1  ⟺  2a1+2a2T−4a4T3=2dx1−T∗ddx1  ⟺  a4=2a1+2a2T−2dx1+T∗ddx14T3  ⟺  a4=2dx0+ddx0T−2dx1+T∗ddx14T3  ⟺  a4=−2(dx1−ddx0T−dx0)+T∗(ddx1−ddx0)4T3\\begin{aligned}\n2a_1 + 4a_2T + 6a_3T^2 +8a_4T^3 &amp; = 2dx_1 \\\\\n2a_2T + 6a_3T^2 + 12a_4T^3&amp; = T*ddx_1 \\\\\n\\iff 2a_1 + 2a_2T - 4a_4T^3 &amp;= 2dx_1 - T*ddx_1 \\\\\n\\iff a_4 &amp; = \\frac{2a_1 + 2a_2T - 2dx_1 + T*ddx_1}{4T^3} \\\\\n\\iff a_4 &amp; = \\frac{2dx_0 + ddx_0T - 2dx_1 + T*ddx_1}{4T^3} \\\\\n\\iff a_4 &amp; = \\frac{-2(dx_1 - ddx_0T - dx_0) + T*(ddx_1 - ddx_0)}{4T^3} \n\\end{aligned}\n2a1​+4a2​T+6a3​T2+8a4​T32a2​T+6a3​T2+12a4​T3⟺2a1​+2a2​T−4a4​T3⟺a4​⟺a4​⟺a4​​=2dx1​=T∗ddx1​=2dx1​−T∗ddx1​=4T32a1​+2a2​T−2dx1​+T∗ddx1​​=4T32dx0​+ddx0​T−2dx1​+T∗ddx1​​=4T3−2(dx1​−ddx0​T−dx0​)+T∗(ddx1​−ddx0​)​​\nvoid QuarticPolynomialCurve1d::ComputeCoefficients(    const double x0, const double dx0, const double ddx0, const double dx1,    const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  double b0 = dx1 - ddx0 * p - dx0;  double b1 = ddx1 - ddx0;  double p2 = p * p;  double p3 = p2 * p;  coef_[3] = (3 * b0 - b1 * p) / (3 * p2);  coef_[4] = (-2 * b0 + b1 * p) / (4 * p3);&#125;\n 入参初始条件（二）: x0, dx0, ddx0, x1, dx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4=x1(3)s(T)=a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 = x_1 \\tag 3\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4=x1​(3)\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(4)s&#x27;(T) =a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 4\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(4)\n公式4*(3)-T(4)得：\n4a0+4a1T+4a2T2+4a3T3+4a4T4=4x1a1T+2a2T2+3a3T3+4a4T4=T∗dx1  ⟺  4a0+3a1T+2a2T2+a3T3=4x1−T∗dx1  ⟺  a3=4x1−T∗dx1−4a0−3a1T−2a2T2T3  ⟺  a3=4x1−T∗dx1−4x0−3dx0T−ddx0T2T3  ⟺  a3=4(x1−x0−dx0T−ddx02T2)−T∗(dx1−dx0−ddx0T)T3\\begin{aligned}\n4a_0 + 4a_1T + 4a_2T^2 + 4a_3T^3 + 4a_4T^4&amp; = 4x_1 \\\\\na_1T + 2a_2T^2 + 3a_3T^3 + 4a_4T^4&amp; = T*dx_1 \\\\\n\\iff 4a_0 + 3a_1T + 2a_2T^2 + a_3T^3 &amp;= 4x_1 - T*dx_1 \\\\\n\\iff a_3 &amp; = \\frac{4x_1 - T*dx_1-4a_0-3a_1T-2a_2T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{4x_1 - T*dx_1 - 4x_0 - 3dx_0T-ddx_0T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{4(x_1-x_0-dx_0T-\\frac{ddx_0}{2}T^2) - T*(dx_1-dx_0 - ddx_0T)}{T^3} \n\\end{aligned}\n4a0​+4a1​T+4a2​T2+4a3​T3+4a4​T4a1​T+2a2​T2+3a3​T3+4a4​T4⟺4a0​+3a1​T+2a2​T2+a3​T3⟺a3​⟺a3​⟺a3​​=4x1​=T∗dx1​=4x1​−T∗dx1​=T34x1​−T∗dx1​−4a0​−3a1​T−2a2​T2​=T34x1​−T∗dx1​−4x0​−3dx0​T−ddx0​T2​=T34(x1​−x0​−dx0​T−2ddx0​​T2)−T∗(dx1​−dx0​−ddx0​T)​​\n公式3*(3)-T(3)得：\n3a0+3a1T+3a2T2+3a3T3+3a4T4=3x1a1T+2a2T2+3a3T3+4a4T4=T∗dx1  ⟺  3a0+2a1T+a2T2−a4T4=3x1−T∗dx1  ⟺  a4=3a0+2a1T+a2T2−3x1+T∗dx1T4  ⟺  a4=3x0+2dx0T+ddx02T2−3x1+T∗dx1T4  ⟺  a4=T∗(dx1−dx0−ddx0T)−3(x1−x0−dx0T−ddx02T2)T4\\begin{aligned}\n3a_0 + 3a_1T + 3a_2T^2 + 3a_3T^3 + 3a_4T^4&amp; = 3x_1 \\\\\na_1T + 2a_2T^2 + 3a_3T^3 + 4a_4T^4&amp; = T*dx_1 \\\\\n\\iff 3a_0 + 2a_1T + a_2T^2 - a_4T^4 &amp;= 3x_1 - T*dx_1 \\\\\n\\iff a_4 &amp; = \\frac{3a_0 + 2a_1T + a_2T^2 - 3x_1 + T*dx_1}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{3x_0 + 2dx_0T + \\frac{ddx_0}{2}T^2 - 3x_1 + T*dx_1}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{T*(dx_1 - dx_0 - ddx_0T) - 3(x_1-x_0-dx_0T - \\frac{ddx_0}{2}T^2)}{T^4} \n\\end{aligned}\n3a0​+3a1​T+3a2​T2+3a3​T3+3a4​T4a1​T+2a2​T2+3a3​T3+4a4​T4⟺3a0​+2a1​T+a2​T2−a4​T4⟺a4​⟺a4​⟺a4​​=3x1​=T∗dx1​=3x1​−T∗dx1​=T43a0​+2a1​T+a2​T2−3x1​+T∗dx1​​=T43x0​+2dx0​T+2ddx0​​T2−3x1​+T∗dx1​​=T4T∗(dx1​−dx0​−ddx0​T)−3(x1​−x0​−dx0​T−2ddx0​​T2)​​\nQuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointFirstOrder(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double p) &#123;  CHECK_GT(p, 0.0);  param_ = p;  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double b0 = x1 - coef_[0] - coef_[1] * p - coef_[2] * p2;  double b1 = dx1 - dx0 - ddx0 * p;  coef_[4] = (b1 * p - 3 * b0) / p4;  coef_[3] = (4 * b0 - b1 * p) / p3;  return *this;&#125;\n 入参初始条件（三）: x0, dx0, x1, dx1, ddx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4=x1(5)s(T)=a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 = x_1 \\tag 5\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4=x1​(5)\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(6)s&#x27;(T)=a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 6\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(6)\ns′′(T)=2a2+6a3T+12a4T2=ddx1(7)s&#x27;&#x27;(T)=2a_2 + 6a_3T + 12a_4T^2 = ddx_1 \\tag 7\ns′′(T)=2a2​+6a3​T+12a4​T2=ddx1​(7)\n公式12*(5)-6*T*(6)+T*T*(7)得：\n12a0+12a1T+12a2T2+12a3T3+12a4T4=12x16a1T+12a2T2+18a3T3+24a4T4=6dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  12a0+6a1T+2a2T2=12x1−6dx1T+ddx1T2  ⟺  a2=12x1−6dx1T+ddx1T2−12a0−6a1T2T2  ⟺  a2=12x1−6dx1T+ddx1T2−12x0−6dx0T2T2  ⟺  a2=0.5ddx1T2−3(dx1−dx0)T+6(x1−x0−dx0T)T2\\begin{aligned}\n12a_0 + 12a_1T + 12a_2T^2 + 12a_3T^3 + 12a_4T^4 &amp; = 12x_1 \\\\\n6a_1T + 12a_2T^2 + 18a_3T^3 + 24a_4T^4 &amp; = 6dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 12a_0 + 6a_1T + 2a_2T^2 &amp; = 12x_1 - 6dx_1T + ddx_1T^2 \\\\\n\\iff a_2 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12a_0 -6a_1T}{2T^2} \\\\\n\\iff a_2 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12x_0 -6dx_0T}{2T^2} \\\\\n\\iff a_2 &amp; = \\frac{0.5ddx_1T^2 - 3(dx_1-dx_0)T + 6(x_1-x_0-dx_0T)}{T^2} \\\\\n\\end{aligned}\n12a0​+12a1​T+12a2​T2+12a3​T3+12a4​T46a1​T+12a2​T2+18a3​T3+24a4​T42a2​T2+6a3​T3+12a4​T4⟺12a0​+6a1​T+2a2​T2⟺a2​⟺a2​⟺a2​​=12x1​=6dx1​T=ddx1​T2=12x1​−6dx1​T+ddx1​T2=2T212x1​−6dx1​T+ddx1​T2−12a0​−6a1​T​=2T212x1​−6dx1​T+ddx1​T2−12x0​−6dx0​T​=T20.5ddx1​T2−3(dx1​−dx0​)T+6(x1​−x0​−dx0​T)​​\n公式8*(5)-5*T*(6)+T*T*(7)得：\n8a0+8a1T+8a2T2+8a3T3+8a4T4=8x15a1T+10a2T2+15a3T3+20a4T4=5dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  8a0+3a1T−a3T3=8x1−5dx1T+ddx1T2  ⟺  a3=8a0+3a1T−8x1+5dx1T−ddx1T2T3  ⟺  a3=8x0+3dx0T−8x1+5dx1T−ddx1T2T3  ⟺  a3=−ddx1T2+5(dx1−dx0)T−8(x1−x0−dx0T)T3\\begin{aligned}\n8a_0 + 8a_1T + 8a_2T^2 + 8a_3T^3 + 8a_4T^4 &amp; = 8x_1 \\\\\n5a_1T + 10a_2T^2 + 15a_3T^3 + 20a_4T^4 &amp; = 5dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 8a_0 + 3a_1T - a_3T^3 &amp; = 8x_1 - 5dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{8a_0 + 3a_1T - 8x_1 + 5dx_1T - ddx_1T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{8x_0 + 3dx_0T - 8x_1 + 5dx_1T - ddx_1T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{-ddx_1T^2 + 5(dx_1-dx_0)T - 8(x_1-x_0-dx_0T)}{T^3} \\\\\n\\end{aligned}\n8a0​+8a1​T+8a2​T2+8a3​T3+8a4​T45a1​T+10a2​T2+15a3​T3+20a4​T42a2​T2+6a3​T3+12a4​T4⟺8a0​+3a1​T−a3​T3⟺a3​⟺a3​⟺a3​​=8x1​=5dx1​T=ddx1​T2=8x1​−5dx1​T+ddx1​T2=T38a0​+3a1​T−8x1​+5dx1​T−ddx1​T2​=T38x0​+3dx0​T−8x1​+5dx1​T−ddx1​T2​=T3−ddx1​T2+5(dx1​−dx0​)T−8(x1​−x0​−dx0​T)​​\n公式6*(5)-4*T*(6)+T*T*(7)得：\n6a0+6a1T+6a2T2+6a3T3+6a4T4=6x14a1T+8a2T2+12a3T3+16a4T4=4dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  6a0+2a1T+2a4T4=6x1−4dx1T+ddx1T2  ⟺  a3=3x1−2dx1T+0.5ddx1T2−3a0−a1TT4  ⟺  a3=3x1−2dx1T+0.5ddx1T2−3x0−dx0TT4  ⟺  a3=0.5ddx1T2−2(dx1−dx0)T+3(x1−x0−dx0T)T4\\begin{aligned}\n6a_0 + 6a_1T + 6a_2T^2 + 6a_3T^3 + 6a_4T^4 &amp; = 6x_1 \\\\\n4a_1T + 8a_2T^2 + 12a_3T^3 + 16a_4T^4 &amp; = 4dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 6a_0 + 2a_1T + 2a_4T^4 &amp; = 6x_1 - 4dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{3x_1 - 2dx_1T + 0.5ddx_1T^2-3a_0 -a_1T}{T^4} \\\\\n\\iff a_3 &amp; = \\frac{3x_1 - 2dx_1T + 0.5ddx_1T^2-3x_0 -dx_0T}{T^4} \\\\\n\\iff a_3 &amp; = \\frac{0.5ddx_1T^2 - 2(dx_1-dx_0)T + 3(x_1-x_0-dx_0T)}{T^4} \\\\\n\\end{aligned}\n6a0​+6a1​T+6a2​T2+6a3​T3+6a4​T44a1​T+8a2​T2+12a3​T3+16a4​T42a2​T2+6a3​T3+12a4​T4⟺6a0​+2a1​T+2a4​T4⟺a3​⟺a3​⟺a3​​=6x1​=4dx1​T=ddx1​T2=6x1​−4dx1​T+ddx1​T2=T43x1​−2dx1​T+0.5ddx1​T2−3a0​−a1​T​=T43x1​−2dx1​T+0.5ddx1​T2−3x0​−dx0​T​=T40.5ddx1​T2−2(dx1​−dx0​)T+3(x1​−x0​−dx0​T)​​\nQuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointSecondOrder(    const double x0, const double dx0, const double x1, const double dx1,    const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  param_ = p;  coef_[0] = x0;  coef_[1] = dx0;  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double b0 = x1 - coef_[0] - coef_[1] * p;  double b1 = dx1 - coef_[1];  double c1 = b1 * p;  double c2 = ddx1 * p2;  coef_[2] = (0.5 * c2 - 3 * c1 + 6 * b0) / p2;  coef_[3] = (-c2 + 5 * c1 - 8 * b0) / p3;  coef_[4] = (0.5 * c2 - 2 * c1 + 3 * b0) / p4;  return *this;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble QuarticPolynomialCurve1d::Evaluate(const std::uint32_t order,                                          const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return (((coef_[4] * p + coef_[3]) * p + coef_[2]) * p + coef_[1]) * p +             coef_[0];    &#125;    case 1: &#123;      return ((4.0 * coef_[4] * p + 3.0 * coef_[3]) * p + 2.0 * coef_[2]) * p +             coef_[1];    &#125;    case 2: &#123;      return (12.0 * coef_[4] * p + 6.0 * coef_[3]) * p + 2.0 * coef_[2];    &#125;    case 3: &#123;      return 24.0 * coef_[4] * p + 6.0 * coef_[3];    &#125;    case 4: &#123;      return 24.0 * coef_[4];    &#125;    default:      return 0.0;  &#125;&#125;\n 五次曲线–&gt;quintic polynomial curve1d\nQuinticPolynomialCurve1d::QuinticPolynomialCurve1d(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double ddx1, const double param) &#123;  ComputeCoefficients(x0, dx0, ddx0, x1, dx1, ddx1, param);  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_[0] = x1;  end_condition_[1] = dx1;  end_condition_[2] = ddx1;  param_ = param;&#125;\ns(t)=a0+a1t+a2t2+a3t3+a4t4+a5t5s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4 + a_5t^5\ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4+a5​t5\n{a0=x0a1=dx0a2=ddx02a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TTa5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{cases}{}\na_0 = x_0 \\\\ \na_1 = dx_0 \\\\\na_2 = \\frac{ddx_0}{2} \\\\\na_3 = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\na_4 =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\na_5 =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​a0​=x0​a1​=dx0​a2​=2ddx0​​a3​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)a4​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​a5​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n入参初始条件\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4+a5T5=x1(8)s(T) = a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 + a_5T^5 = x_1\\tag 8\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4+a5​T5=x1​(8)\ns′(T)=a1+2a2T+3a3T2+4a4T3+5a5T4=dx1(9)s&#x27;(T) = a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 + 5a_5T^4 = dx_1 \\tag 9\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3+5a5​T4=dx1​(9)\ns′′(T)=2a2+6a3T+12a4T2+20a5T3=ddx1(10)s&#x27;&#x27;(T) = 2a_2 + 6a_3T + 12a_4T^2 + 20a_5T^3 = ddx_1 \\tag{10}\ns′′(T)=2a2​+6a3​T+12a4​T2+20a5​T3=ddx1​(10)\n公式20*(8)-5*T*(9)+T*T*(10)得：\n20a0+20a1T+20a2T2+20a3T3+20a4T4+20a5T5=20x18a1T+16a2T2+24a3T3+32a4T4+40a5T5=8dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  20a0+12a1T+6a2T2+2a3T3=20x1−8dx1T+ddx1T2  ⟺  a3=20x1−8dx1T+ddx1T2−20a0−12a1T−6a2T22T3  ⟺  a3=20x1−8dx1T+ddx1T2−20x0−12dx0T−3ddx0T22T3  ⟺  a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)\\begin{aligned}\n20a_0 + 20a_1T + 20a_2T^2 + 20a_3T^3 + 20a_4T^4 + 20a_5T^5 &amp; = 20x_1 \\\\\n8a_1T + 16a_2T^2 + 24a_3T^3 + 32a_4T^4 + 40a_5T^5 &amp; = 8dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 20a_0 + 12a_1T + 6a_2T^2 + 2a_3T^3&amp; = 20x_1 - 8dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{20x_1 - 8dx_1T + ddx_1T^2 - 20a_0 - 12a_1T - 6a_2T^2}{2T^3} \\\\\n\\iff a_3 &amp; = \\frac{20x_1 - 8dx_1T + ddx_1T^2 - 20x_0 - 12dx_0T - 3ddx_0T^2}{2T^3} \\\\\n\\iff a_3 &amp; = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\n\\end{aligned}\n20a0​+20a1​T+20a2​T2+20a3​T3+20a4​T4+20a5​T58a1​T+16a2​T2+24a3​T3+32a4​T4+40a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺20a0​+12a1​T+6a2​T2+2a3​T3⟺a3​⟺a3​⟺a3​​=20x1​=8dx1​T=ddx1​T2=20x1​−8dx1​T+ddx1​T2=2T320x1​−8dx1​T+ddx1​T2−20a0​−12a1​T−6a2​T2​=2T320x1​−8dx1​T+ddx1​T2−20x0​−12dx0​T−3ddx0​T2​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)​\n提示：逆推一下得证。\n公式15*(8)-7*T*(9)+T*T*(10)得：\n15a0+15a1T+15a2T2+15a3T3+15a4T4+15a5T5=15x17a1T+14a2T2+21a3T3+28a4T4+35a5T5=7dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  15a0+8a1T+3a2T2−a4T4=15x1−7dx1T+ddx1T2  ⟺  a4=15a0+8a1T+3a2T2−15x1+7dx1T−ddx1T2T4  ⟺  a4=15x0+8dx0T+3ddx02T2−15x1+7dx1T−ddx1T2T4  ⟺  a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TT\\begin{aligned}\n15a_0 + 15a_1T + 15a_2T^2 + 15a_3T^3 + 15a_4T^4 + 15a_5T^5 &amp; = 15x_1 \\\\\n7a_1T + 14a_2T^2 + 21a_3T^3 + 28a_4T^4 + 35a_5T^5 &amp; = 7dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 15a_0 + 8a_1T + 3a_2T^2 - a_4T^4&amp; = 15x_1 - 7dx_1T + ddx_1T^2 \\\\\n\\iff a_4 &amp; = \\frac{15a_0 + 8a_1T + 3a_2T^2 - 15x_1 + 7dx_1T - ddx_1T^2}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{15x_0 + 8dx_0T + 3\\frac{ddx_0}{2}T^2 - 15x_1 + 7dx_1T - ddx_1T^2}{T^4} \\\\\n\\iff a_4 &amp; =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\n\\end{aligned}\n15a0​+15a1​T+15a2​T2+15a3​T3+15a4​T4+15a5​T57a1​T+14a2​T2+21a3​T3+28a4​T4+35a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺15a0​+8a1​T+3a2​T2−a4​T4⟺a4​⟺a4​⟺a4​​=15x1​=7dx1​T=ddx1​T2=15x1​−7dx1​T+ddx1​T2=T415a0​+8a1​T+3a2​T2−15x1​+7dx1​T−ddx1​T2​=T415x0​+8dx0​T+32ddx0​​T2−15x1​+7dx1​T−ddx1​T2​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​​\n提示：逆推一下得证。\n公式12*(8)-6*T*(9)+T*T*(10)得：\n12a0+12a1T+12a2T2+12a3T3+12a4T4+12a5T5=12x16a1T+12a2T2+18a3T3+24a4T4+30a5T5=6dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  12a0+6a1T+2a2T2+2a5T5=12x1−6dx1T+ddx1T2  ⟺  a5=12x1−6dx1T+ddx1T2−12a0−6a1T−2a2T22T5  ⟺  a5=12x1−6dx1T+ddx1T2−12x0−6dx0T−ddx0T22T5  ⟺  a5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{aligned}\n12a_0 + 12a_1T + 12a_2T^2 + 12a_3T^3 + 12a_4T^4 + 12a_5T^5 &amp; = 12x_1 \\\\\n6a_1T + 12a_2T^2 + 18a_3T^3 + 24a_4T^4 + 30a_5T^5 &amp; = 6dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 12a_0 + 6a_1T + 2a_2T^2 + 2a_5T^5&amp; = 12x_1 - 6dx_1T + ddx_1T^2 \\\\\n\\iff a_5 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12a_0 - 6a_1T - 2a_2T^2}{2T^5} \\\\\n\\iff a_5 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12x_0 - 6dx_0T - ddx_0T^2}{2T^5} \\\\\n\\iff a_5 &amp; =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{aligned}\n12a0​+12a1​T+12a2​T2+12a3​T3+12a4​T4+12a5​T56a1​T+12a2​T2+18a3​T3+24a4​T4+30a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺12a0​+6a1​T+2a2​T2+2a5​T5⟺a5​⟺a5​⟺a5​​=12x1​=6dx1​T=ddx1​T2=12x1​−6dx1​T+ddx1​T2=2T512x1​−6dx1​T+ddx1​T2−12a0​−6a1​T−2a2​T2​=2T512x1​−6dx1​T+ddx1​T2−12x0​−6dx0​T−ddx0​T2​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n提示：逆推一下得证。\nvoid QuinticPolynomialCurve1d::ComputeCoefficients(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = ddx0 / 2.0;  const double p2 = p * p;  const double p3 = p * p2;  // the direct analytical method is at least 6 times faster than using matrix  // inversion.  const double c0 = (x1 - 0.5 * p2 * ddx0 - dx0 * p - x0) / p3;  const double c1 = (dx1 - ddx0 * p - dx0) / p2;  const double c2 = (ddx1 - ddx0) / p;  coef_[3] = 0.5 * (20.0 * c0 - 8.0 * c1 + c2);  coef_[4] = (-15.0 * c0 + 7.0 * c1 - c2) / p;  coef_[5] = (6.0 * c0 - 3.0 * c1 + 0.5 * c2) / p2;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble QuinticPolynomialCurve1d::Evaluate(const uint32_t order,                                          const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return ((((coef_[5] * p + coef_[4]) * p + coef_[3]) * p + coef_[2]) * p +              coef_[1]) *                 p +             coef_[0];    &#125;    case 1: &#123;      return (((5.0 * coef_[5] * p + 4.0 * coef_[4]) * p + 3.0 * coef_[3]) * p +              2.0 * coef_[2]) *                 p +             coef_[1];    &#125;    case 2: &#123;      return (((20.0 * coef_[5] * p + 12.0 * coef_[4]) * p) + 6.0 * coef_[3]) *                 p +             2.0 * coef_[2];    &#125;    case 3: &#123;      return (60.0 * coef_[5] * p + 24.0 * coef_[4]) * p + 6.0 * coef_[3];    &#125;    case 4: &#123;      return 120.0 * coef_[5] * p + 24.0 * coef_[4];    &#125;    case 5: &#123;      return 120.0 * coef_[5];    &#125;    default:      return 0.0;  &#125;&#125;\n","categories":["Apollo源码解读"]},{"title":"Apollo v5.5.0 代码解读 之 控制模块-纵向控制","url":"/2023/04/26/Apollo%20v5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97-%E7%BA%B5%E5%90%91%E6%8E%A7%E5%88%B6/","content":" Class LonController\n\n\n\n\n LonController()\nLonController::LonController()    : name_(ControlConf_ControllerType_Name(ControlConf::LON_CONTROLLER)) &#123;  if (FLAGS_enable_csv_debug) &#123;    // 用 csv 格式记录debug信息    time_t rawtime;    char name_buffer[80];    std::time(&amp;rawtime);    std::tm time_tm;    localtime_r(&amp;rawtime, &amp;time_tm);    strftime(name_buffer, 80, &quot;/tmp/speed_log__%F_%H%M%S.csv&quot;, &amp;time_tm);    speed_log_file_ = fopen(name_buffer, &quot;w&quot;);    if (speed_log_file_ == nullptr) &#123;      AERROR &lt;&lt; &quot;Fail to open file:&quot; &lt;&lt; name_buffer;      FLAGS_enable_csv_debug = false;    &#125;    if (speed_log_file_ != nullptr) &#123;      fprintf(speed_log_file_,              &quot;station_reference,&quot;              &quot;station_error,&quot;              &quot;station_error_limited,&quot;              &quot;preview_station_error,&quot;              &quot;speed_reference,&quot;              &quot;speed_error,&quot;              &quot;speed_error_limited,&quot;              &quot;preview_speed_reference,&quot;              &quot;preview_speed_error,&quot;              &quot;preview_acceleration_reference,&quot;              &quot;acceleration_cmd_closeloop,&quot;              &quot;acceleration_cmd,&quot;              &quot;acceleration_lookup,&quot;              &quot;speed_lookup,&quot;              &quot;calibration_value,&quot;              &quot;throttle_cmd,&quot;              &quot;brake_cmd,&quot;              &quot;is_full_stop,&quot;              &quot;\\r\\n&quot;);      fflush(speed_log_file_);    &#125;    AINFO &lt;&lt; name_ &lt;&lt; &quot; used.&quot;;  &#125;&#125;\n CloseLogFile()\nvoid LonController::CloseLogFile() &#123;  if (FLAGS_enable_csv_debug) &#123;    if (speed_log_file_ != nullptr) &#123;      fclose(speed_log_file_);      speed_log_file_ = nullptr;    &#125;  &#125;&#125;void LonController::Stop() &#123; CloseLogFile(); &#125;LonController::~LonController() &#123; CloseLogFile(); &#125;\n Init()\nStatus LonController::Init(const ControlConf *control_conf) &#123;  control_conf_ = control_conf;  if (control_conf_ == nullptr) &#123;    // 配置文件加载失败    controller_initialized_ = false;    AERROR &lt;&lt; &quot;get_longitudinal_param() nullptr&quot;;    return Status(ErrorCode::CONTROL_INIT_ERROR,                  &quot;Failed to load LonController conf&quot;);  &#125;  // 获取纵向配置文件  const LonControllerConf &amp;lon_controller_conf =      control_conf_-&gt;lon_controller_conf();  double ts = lon_controller_conf.ts(); // ts 默认值 0.01  bool enable_leadlag =      lon_controller_conf.enable_reverse_leadlag_compensation();    // 初始化位置 PID  station_pid_controller_.Init(lon_controller_conf.station_pid_conf());  // 初始化速度 PID  speed_pid_controller_.Init(lon_controller_conf.low_speed_pid_conf());  if (enable_leadlag) &#123;    station_leadlag_controller_.Init(        lon_controller_conf.reverse_station_leadlag_conf(), ts);    speed_leadlag_controller_.Init(        lon_controller_conf.reverse_speed_leadlag_conf(), ts);  &#125;  // 获取车辆基本属性  vehicle_param_.CopyFrom(      common::VehicleConfigHelper::Instance()-&gt;GetConfig().vehicle_param());  SetDigitalFilterPitchAngle(lon_controller_conf);  // 加载标定表  LoadControlCalibrationTable(lon_controller_conf);  controller_initialized_ = true;  return Status::OK();&#125;\n SetDigitalFilterPitchAngle()\n//设置Pitch车辆俯仰角//参数：lon_controller_conf是纵向控制器配置类对象，该类由modules/control/proto/.proto文件生成//从该对象中读取截至频率，控制周期等参数来设置pitch角滤波器//pitch角用来进行车辆的坡道补偿，默认坡道补偿是关闭的void LonController::SetDigitalFilterPitchAngle(    const LonControllerConf &amp;lon_controller_conf) &#123;  double cutoff_freq =      lon_controller_conf.pitch_angle_filter_conf().cutoff_freq();  double ts = lon_controller_conf.ts();  SetDigitalFilter(ts, cutoff_freq, &amp;digital_filter_pitch_angle_);&#125;\n SetDigitalFilter()\n//加载控制标定表函数//参数：lon_controller_conf是纵向控制器配置类对象，该类由modules/control/proto/.proto文件生成//从纵向控制器配置对象中读取车速-加速度-控制百分数标定表void LonController::SetDigitalFilter(double ts, double cutoff_freq,                                     common::DigitalFilter *digital_filter) &#123;  std::vector&lt;double&gt; denominators;  std::vector&lt;double&gt; numerators;  common::LpfCoefficients(ts, cutoff_freq, &amp;denominators, &amp;numerators);  digital_filter-&gt;set_coefficients(denominators, numerators);&#125;\n LoadControlCalibrationTable()\nvoid LonController::LoadControlCalibrationTable(    const LonControllerConf &amp;lon_controller_conf) &#123;  const auto &amp;control_table = lon_controller_conf.calibration_table();  AINFO &lt;&lt; &quot;Control calibration table loaded&quot;;  AINFO &lt;&lt; &quot;Control calibration table size is &quot;        &lt;&lt; control_table.calibration_size();  Interpolation2D::DataType xyz;  for (const auto &amp;calibration : control_table.calibration()) &#123;    xyz.push_back(std::make_tuple(calibration.speed(),                                  calibration.acceleration(),                                  calibration.command()));  &#125;  control_interpolation_.reset(new Interpolation2D);  CHECK(control_interpolation_-&gt;Init(xyz))      &lt;&lt; &quot;Fail to load control calibration table&quot;;&#125;\n ComputeControlCommand()\n\nStatus LonController::ComputeControlCommand(    const localization::LocalizationEstimate *localization,    const canbus::Chassis *chassis,    const planning::ADCTrajectory *planning_published_trajectory,    control::ControlCommand *cmd) &#123;  localization_ = localization;  chassis_ = chassis;  trajectory_message_ = planning_published_trajectory;  if (!control_interpolation_) &#123;    // 确认差值表是否有问题    AERROR &lt;&lt; &quot;Fail to initialize calibration table.&quot;;    return Status(ErrorCode::CONTROL_COMPUTE_ERROR,                  &quot;Fail to initialize calibration table.&quot;);  &#125;  if (trajectory_analyzer_ == nullptr ||      trajectory_analyzer_-&gt;seq_num() !=          trajectory_message_-&gt;header().sequence_num()) &#123;    // 更新跟踪轨迹    trajectory_analyzer_.reset(new TrajectoryAnalyzer(trajectory_message_));  &#125;  // 获取纵向控制配置参数  const LonControllerConf &amp;lon_controller_conf =      control_conf_-&gt;lon_controller_conf();  // 获取输出控制信息里面的debug指针  auto debug = cmd-&gt;mutable_debug()-&gt;mutable_simple_lon_debug();  debug-&gt;Clear(); // 清空debug信息  double brake_cmd = 0.0;  double throttle_cmd = 0.0;  double ts = lon_controller_conf.ts();  // preview_window 默认值 20  double preview_time = lon_controller_conf.preview_window() * ts;  bool enable_leadlag =      lon_controller_conf.enable_reverse_leadlag_compensation();  if (preview_time &lt; 0.0) &#123;    // 预瞄时间异常    const auto error_msg =        absl::StrCat(&quot;Preview time set as: &quot;, preview_time, &quot; less than 0&quot;);    AERROR &lt;&lt; error_msg;    return Status(ErrorCode::CONTROL_COMPUTE_ERROR, error_msg);  &#125;  // 计算纵向各项误差值  ComputeLongitudinalErrors(trajectory_analyzer_.get(), preview_time, ts,                            debug);  // 定义临时变量station_error_limit纵向位置误差限制  // 从配置文件control_conf.pb.txt-lon_controller_conf-station_error_limit中读取到  // 默认是2.0m  double station_error_limit = lon_controller_conf.station_error_limit();  // 定义临时变量station_error_limited为限幅后的纵向位置误差  double station_error_limited = 0.0;  // enable_speed_station_preview 默认值 true  if (FLAGS_enable_speed_station_preview) &#123;    // 有两种位置误差    // 第一种, preview_station_error=预览点纵向位置 - 匹配点纵向位置    // 第二种, station_error=参考点纵向位置 - 匹配点纵向位置    // 如果打开此开关则采用第一种纵向位置误差，纵向误差的计算结果都是存在debug里    station_error_limited =        common::math::Clamp(debug-&gt;preview_station_error(),                            -station_error_limit, station_error_limit);  &#125; else &#123;    // 否则采用第二种纵向位置误差，纵向误差的计算结果都是存在debug里    station_error_limited = common::math::Clamp(        debug-&gt;station_error(), -station_error_limit, station_error_limit);  &#125;  if (trajectory_message_-&gt;gear() == canbus::Chassis::GEAR_REVERSE) &#123;    // 倒档情况，设置对应PID配置文件    station_pid_controller_.SetPID(        lon_controller_conf.reverse_station_pid_conf());    speed_pid_controller_.SetPID(lon_controller_conf.reverse_speed_pid_conf());    if (enable_leadlag) &#123;      // 如果打开enable_leadlag超前滞后控制器，默认是关闭直接略过      station_leadlag_controller_.SetLeadlag(          lon_controller_conf.reverse_station_leadlag_conf());      speed_leadlag_controller_.SetLeadlag(          lon_controller_conf.reverse_speed_leadlag_conf());    &#125;  &#125; else if (VehicleStateProvider::Instance()-&gt;linear_velocity() &lt;=             lon_controller_conf.switch_speed()) &#123;    // 低速情况，设置对应PID配置文件    speed_pid_controller_.SetPID(lon_controller_conf.low_speed_pid_conf());  &#125; else &#123;    // 高速情况，设置对应PID配置文件     speed_pid_controller_.SetPID(lon_controller_conf.high_speed_pid_conf());  &#125;    // 速度偏差=位置控制器根据(限幅后位置误差，采样周期)计算出控制量即速度  // 补偿量  double speed_offset =      station_pid_controller_.Control(station_error_limited, ts);  if (enable_leadlag) &#123;    // 如果打开超前-滞后控制器，默认不打开，略过    speed_offset = station_leadlag_controller_.Control(speed_offset, ts);  &#125;  double speed_controller_input = 0.0;  // speed_controller_input_limit 默认值 2.0  double speed_controller_input_limit =      lon_controller_conf.speed_controller_input_limit();  double speed_controller_input_limited = 0.0;  if (FLAGS_enable_speed_station_preview) &#123;    // 打开的话速度控制器的输入 = 位置控制器计算出的speed_offset + 当前时间向前加上预览时间在轨迹上的对应点的速度和当前车速的偏差    speed_controller_input = speed_offset + debug-&gt;preview_speed_error();  &#125; else &#123;    // 不打开的话速度控制器的输入 = 位置控制器计算出的speed_offset + 参考点车速和当前车速的偏差    speed_controller_input = speed_offset + debug-&gt;speed_error();  &#125;  // 计算得到的速度控制器的输入再进行限幅  speed_controller_input_limited =      common::math::Clamp(speed_controller_input, -speed_controller_input_limit,                          speed_controller_input_limit);  double acceleration_cmd_closeloop = 0.0;  // 闭环的加速度指令就等于速度PID控制器根据速度控制器的输入，以及采样周期去计算  acceleration_cmd_closeloop =      speed_pid_controller_.Control(speed_controller_input_limited, ts);  // 将速度PID控制器中积分器的饱和状态设置到debug.pid_saturation_status里  debug-&gt;set_pid_saturation_status(      speed_pid_controller_.IntegratorSaturationStatus());  if (enable_leadlag) &#123;    acceleration_cmd_closeloop =        speed_leadlag_controller_.Control(acceleration_cmd_closeloop, ts);    debug-&gt;set_leadlag_saturation_status(        speed_leadlag_controller_.InnerstateSaturationStatus());  &#125;  // 定义斜坡补偿加速度 = (重力加速度 * 车辆俯仰角的正弦值)再经过数字滤波器滤波得到斜坡加速度补偿  double slope_offset_compenstaion = digital_filter_pitch_angle_.Filter(      GRA_ACC * std::sin(VehicleStateProvider::Instance()-&gt;pitch()));  if (std::isnan(slope_offset_compenstaion)) &#123;    slope_offset_compenstaion = 0;  &#125;  // 将斜坡补偿加速度设置到debug里  debug-&gt;set_slope_offset_compensation(slope_offset_compenstaion);  // 总的加速度指令 = 闭环加速度指令 + 预览参考加速度 + 坡道补偿加速度(如果打开坡道补偿的话)  double acceleration_cmd =      acceleration_cmd_closeloop + debug-&gt;preview_acceleration_reference() +      FLAGS_enable_slope_offset * debug-&gt;slope_offset_compensation();  debug-&gt;set_is_full_stop(false);  // 获取停车点的一个函数，后面介绍，找到当前规划模块发布的轨迹msg里的第一个v,a都小于一个很小值的点作为停车点  // 找到的这个停车点的纵向位置和当前车辆纵向位置的偏差设置到debug里面去，debug.path_remain()  GetPathRemain(debug);  // At near-stop stage, replace the brake control command with the standstill  // acceleration if the former is even softer than the latter  // 在快要停车的阶段，用一个固定的standstill的减速度代替刹车控制指令  // 简而言之就是快到停车点时给一个固定-0.3m/s^2的减速度(数值控制配置里设置)  if ((trajectory_message_-&gt;trajectory_type() ==       apollo::planning::ADCTrajectory::NORMAL) &amp;&amp;        // 预览点的加速度&lt;=控制配置里的停车时最大允许加速度        // max_acceleration_when_stopped 默认值 0.01      ((std::fabs(debug-&gt;preview_acceleration_reference()) &lt;=            control_conf_-&gt;max_acceleration_when_stopped() &amp;&amp;        // 预览点速度小于车辆参数中的最大允许停车速度        // max_abs_speed_when_stopped 默认值 0.2        std::fabs(debug-&gt;preview_speed_reference()) &lt;=            vehicle_param_.max_abs_speed_when_stopped()) ||       // 或当前纵向位置到停止点纵向位置偏差小于控制配置       // max_path_remain_when_stopped 默认值 0.3m       std::abs(debug-&gt;path_remain()) &lt;           control_conf_-&gt;max_path_remain_when_stopped())) &#123;    // 总结上述条件，轨迹类型normal且(预览点加速度小于阈值且预览点速度小于阈值)或到停车点纵向偏差&lt;阈值        // 符合条件时，加速度指令按如下方式计算          // standstill_acceleration默认为-0.3 m/s^2    acceleration_cmd =        (chassis-&gt;gear_location() == canbus::Chassis::GEAR_REVERSE)            ? std::max(acceleration_cmd,                       -lon_controller_conf.standstill_acceleration())            : std::min(acceleration_cmd,                       lon_controller_conf.standstill_acceleration());    ADEBUG &lt;&lt; &quot;Stop location reached&quot;;    debug-&gt;set_is_full_stop(true);  &#125;  // 定义油门指令的下边界，为 车辆配置里的throttle_deadzone 和 lon_controller_conf配置里的throttle_minimum_action，两者中的较大值  // 车辆控制油门，有一个最低油门，也就算只能车辆油门控制只能从最小油门开始，而不是0，刹车同理  double throttle_lowerbound =      std::max(vehicle_param_.throttle_deadzone(),               lon_controller_conf.throttle_minimum_action());  // 定义刹车指令的下边界  double brake_lowerbound =      std::max(vehicle_param_.brake_deadzone(),               lon_controller_conf.brake_minimum_action());  double calibration_value = 0.0;  // 要用来查表加速度，若R档为加速度控制指令取反，非R档保持加速度控制指令  double acceleration_lookup =      (chassis-&gt;gear_location() == canbus::Chassis::GEAR_REVERSE)          ? -acceleration_cmd          : acceleration_cmd;  if (FLAGS_use_preview_speed_for_table) &#123;    // 使用预览点速度来查标定表(车速-加速度-控制指令百分数)    calibration_value = control_interpolation_-&gt;Interpolate(        std::make_pair(debug-&gt;preview_speed_reference(), acceleration_lookup));  &#125; else &#123;    // 标定表就用chassis里反馈的实际车速去查    // 用速度加速度根据标定表线性插值得到控制量百分数calibration_value    calibration_value = control_interpolation_-&gt;Interpolate(        std::make_pair(chassis_-&gt;speed_mps(), acceleration_lookup));  &#125;  if (acceleration_lookup &gt;= 0) &#123;    // 请求查表加速度&gt;=0，也就是加油情况    if (calibration_value &gt;= 0) &#123;      // 计算得到的控制百分数&gt;=0      // 设置油门控制百分数，为油门下边界和查表得到的控制百分数之间的较大值      throttle_cmd = std::max(calibration_value, throttle_lowerbound);    &#125; else &#123;      // 如果计算得到的控制百分数&lt;0,但是加速度又大于0      // 设置油门控制百分数为油门下边界      throttle_cmd = throttle_lowerbound;    &#125;    brake_cmd = 0.0;  &#125; else &#123;    // 请求查表加速度&lt;0，也就是刹车情况    throttle_cmd = 0.0;    if (calibration_value &gt;= 0) &#123;      brake_cmd = brake_lowerbound;    &#125; else &#123;      brake_cmd = std::max(-calibration_value, brake_lowerbound);    &#125;  &#125;  // 将被限制的纵向位置误差设置到debug.station_error_limited    debug-&gt;set_station_error_limited(station_error_limited);  // 位置控制器的输出设置到debug.speedoffset  debug-&gt;set_speed_offset(speed_offset);  // 被限幅的速度控制器的输入设置到debug.speed_controller_input_limited  debug-&gt;set_speed_controller_input_limited(speed_controller_input_limited);  // 计算到的加速度指令设置到debug.acceleration_cmd  debug-&gt;set_acceleration_cmd(acceleration_cmd);  // 计算到的油门指令设置到debug.throttle_cmd  debug-&gt;set_throttle_cmd(throttle_cmd);  // 计算到的刹车指令设置到debug.brake_cmd  debug-&gt;set_brake_cmd(brake_cmd);  // 去查标定表的请求加速度设置到debug.acceleration_lookup  debug-&gt;set_acceleration_lookup(acceleration_lookup);  // 去查标定表的速度将chassis反馈值设置到debug.speed_lookup  debug-&gt;set_speed_lookup(chassis_-&gt;speed_mps());  // 将标定表中查到的控制百分数值calibration_value设置到debug.calibration_value  debug-&gt;set_calibration_value(calibration_value);  // 将闭环反馈速度控制器计算得到的控制量加速度设置到debug.acceleration_cmd_closeloop  debug-&gt;set_acceleration_cmd_closeloop(acceleration_cmd_closeloop);  if (FLAGS_enable_csv_debug &amp;&amp; speed_log_file_ != nullptr) &#123;    // 讲数据输出到 csv 文件    fprintf(speed_log_file_,            &quot;%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f,&quot;            &quot;%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %d,\\r\\n&quot;,            debug-&gt;station_reference(), debug-&gt;station_error(),            station_error_limited, debug-&gt;preview_station_error(),            debug-&gt;speed_reference(), debug-&gt;speed_error(),            speed_controller_input_limited, debug-&gt;preview_speed_reference(),            debug-&gt;preview_speed_error(),            debug-&gt;preview_acceleration_reference(), acceleration_cmd_closeloop,            acceleration_cmd, debug-&gt;acceleration_lookup(),            debug-&gt;speed_lookup(), calibration_value, throttle_cmd, brake_cmd,            debug-&gt;is_full_stop());  &#125;  // if the car is driven by acceleration, disgard the cmd-&gt;throttle and brake  // 如果车辆是以加速度驱动，那么可以忽略下面的油门，制动指令值  cmd-&gt;set_throttle(throttle_cmd);  cmd-&gt;set_brake(brake_cmd);  cmd-&gt;set_acceleration(acceleration_cmd);  // 如果车辆的纵向速度绝对值&lt;=车辆参数配置里设定的停车最大速度绝对值  // 简单理解就是车辆的纵向速度小于某阈值或者chassis反馈的档为信息是N档就认为车已经停住了，下发车辆的换档指令  if (std::fabs(VehicleStateProvider::Instance()-&gt;linear_velocity()) &lt;=          vehicle_param_.max_abs_speed_when_stopped() ||      chassis-&gt;gear_location() == trajectory_message_-&gt;gear() ||      chassis-&gt;gear_location() == canbus::Chassis::GEAR_NEUTRAL) &#123;    // 若车辆处于停车或N档时下发规划发布的轨迹msg里的档位    cmd-&gt;set_gear_location(trajectory_message_-&gt;gear());  &#125; else &#123;    // 若车辆不处于停车且不在N档时下发chassis反馈的车辆实际档位    cmd-&gt;set_gear_location(chassis-&gt;gear_location());  &#125;  return Status::OK();&#125;\n ComputeLongitudinalErrors()\n\nvoid LonController::ComputeLongitudinalErrors(    const TrajectoryAnalyzer *trajectory_analyzer, const double preview_time,    const double ts, SimpleLongitudinalDebug *debug) &#123;  // the decomposed vehicle motion onto Frenet frame  // s: longitudinal accumulated distance along reference trajectory  // s_dot: longitudinal velocity along reference trajectory  // d: lateral distance w.r.t. reference trajectory  // d_dot: lateral distance change rate, i.e. dd/dt  double s_matched = 0.0;  double s_dot_matched = 0.0;  double d_matched = 0.0;  double d_dot_matched = 0.0;  // 计算本车在轨迹上的投影点  auto matched_point = trajectory_analyzer-&gt;QueryMatchedPathPoint(      VehicleStateProvider::Instance()-&gt;x(),      VehicleStateProvider::Instance()-&gt;y());  // 将本车位置转换成SL坐标，基于规划轨迹的SL坐标系  trajectory_analyzer-&gt;ToTrajectoryFrame(      VehicleStateProvider::Instance()-&gt;x(),      VehicleStateProvider::Instance()-&gt;y(),      VehicleStateProvider::Instance()-&gt;heading(),      VehicleStateProvider::Instance()-&gt;linear_velocity(), matched_point,      &amp;s_matched, &amp;s_dot_matched, &amp;d_matched, &amp;d_dot_matched);  // 当前绝对时间  double current_control_time = Clock::NowInSeconds();  // 预瞄绝对时间  double preview_control_time = current_control_time + preview_time;  // 通过当前绝对时间获取轨迹上的参考点  TrajectoryPoint reference_point =      trajectory_analyzer-&gt;QueryNearestPointByAbsoluteTime(          current_control_time);  // 通过预瞄绝对时间获取轨迹上的预瞄点  TrajectoryPoint preview_point =      trajectory_analyzer-&gt;QueryNearestPointByAbsoluteTime(          preview_control_time);  // debug 记录 三个点的信息：位置匹配点，当前绝对时间的参考点，预瞄绝对时间的预瞄点  debug-&gt;mutable_current_matched_point()-&gt;mutable_path_point()-&gt;set_x(      matched_point.x());  debug-&gt;mutable_current_matched_point()-&gt;mutable_path_point()-&gt;set_y(      matched_point.y());  debug-&gt;mutable_current_reference_point()-&gt;mutable_path_point()-&gt;set_x(      reference_point.path_point().x());  debug-&gt;mutable_current_reference_point()-&gt;mutable_path_point()-&gt;set_y(      reference_point.path_point().y());  debug-&gt;mutable_preview_reference_point()-&gt;mutable_path_point()-&gt;set_x(      preview_point.path_point().x());  debug-&gt;mutable_preview_reference_point()-&gt;mutable_path_point()-&gt;set_y(      preview_point.path_point().y());  ADEBUG &lt;&lt; &quot;matched point:&quot; &lt;&lt; matched_point.DebugString();  ADEBUG &lt;&lt; &quot;reference point:&quot; &lt;&lt; reference_point.DebugString();  ADEBUG &lt;&lt; &quot;preview point:&quot; &lt;&lt; preview_point.DebugString();    // 航向角误差 = 车辆当前状态航向角 - 匹配点的航向角  // NormalizeAngle角度的规范化，就是将所有角度规范到-pi,pi  double heading_error = common::math::NormalizeAngle(      VehicleStateProvider::Instance()-&gt;heading() - matched_point.theta());  // 纵向速度 = 车辆速度 * cos(当前航向角 - 轨迹上距离最近点航向角)  double lon_speed = VehicleStateProvider::Instance()-&gt;linear_velocity() *                     std::cos(heading_error);  // 纵向加速度 = 车辆加速度 * cos(当前航向角 - 轨迹上距离最近点航向角  double lon_acceleration =      VehicleStateProvider::Instance()-&gt;linear_acceleration() *      std::cos(heading_error);  // 1-kd就是将大地坐标系转化到Frenet坐标纵向上引入的，如下图所示  double one_minus_kappa_lat_error =      1 - reference_point.path_point().kappa() *              VehicleStateProvider::Instance()-&gt;linear_velocity() *              std::sin(heading_error);  debug-&gt;set_station_reference(reference_point.path_point().s());  debug-&gt;set_current_station(s_matched);  // 纵向位置误差debug.station_error=参考点路径点的累积弧长-匹配点的累积弧长(匹配点就是路径最近点)  debug-&gt;set_station_error(reference_point.path_point().s() - s_matched);  debug-&gt;set_speed_reference(reference_point.v());  debug-&gt;set_current_speed(lon_speed);  // 速度误差就是参考点速度减匹配点速度 debug.speed_error  debug-&gt;set_speed_error(reference_point.v() - s_dot_matched);  debug-&gt;set_acceleration_reference(reference_point.a());  debug-&gt;set_current_acceleration(lon_acceleration);  // 设定加速度误差=参考点加速度-纵向加速度/(1-kd)  1-kd由全局坐标转换到Frenet坐标引入，kappa就是曲率  debug-&gt;set_acceleration_error(reference_point.a() -                                lon_acceleration / one_minus_kappa_lat_error);  double jerk_reference =      (debug-&gt;acceleration_reference() - previous_acceleration_reference_) / ts;  double lon_jerk =      (debug-&gt;current_acceleration() - previous_acceleration_) / ts;  debug-&gt;set_jerk_reference(jerk_reference);  debug-&gt;set_current_jerk(lon_jerk);  // 加加速度误差=加加速度参考-纵向加加速度/(1-kd)存到debug里  debug-&gt;set_jerk_error(jerk_reference - lon_jerk / one_minus_kappa_lat_error);  previous_acceleration_reference_ = debug-&gt;acceleration_reference();  previous_acceleration_ = debug-&gt;current_acceleration();  debug-&gt;set_preview_station_error(preview_point.path_point().s() - s_matched);  debug-&gt;set_preview_speed_error(preview_point.v() - s_dot_matched);  debug-&gt;set_preview_speed_reference(preview_point.v());  debug-&gt;set_preview_acceleration_reference(preview_point.a());&#125;\n\n GetPathRemain()\nvoid LonController::GetPathRemain(SimpleLongitudinalDebug *debug) &#123;  int stop_index = 0;  // 定义了静态常量速度阈值，速度小于此阈值认为是停止条件之一  static constexpr double kSpeedThreshold = 1e-3;  // 定义了静态常量加速度常量 前进档时加速度&gt;此阈值且&lt;0认为是停止条件之一  static constexpr double kForwardAccThreshold = -1e-2;  // 定义了静态常量加速度常量 R档时加速度&lt;此阈值且&gt;0认为是停止条件之一  static constexpr double kBackwardAccThreshold = 1e-1;  // 定义了静态常量驻车速度，也是判断停车点的一个依据  static constexpr double kParkingSpeed = 0.1;  if (trajectory_message_-&gt;gear() == canbus::Chassis::GEAR_DRIVE) &#123;    // 前进情况    while (stop_index &lt; trajectory_message_-&gt;trajectory_point_size()) &#123;      auto &amp;current_trajectory_point =          trajectory_message_-&gt;trajectory_point(stop_index);      // 遍历每个轨迹点，判断是否满足驻车条件      if (fabs(current_trajectory_point.v()) &lt; kSpeedThreshold &amp;&amp;          current_trajectory_point.a() &gt; kForwardAccThreshold &amp;&amp;          current_trajectory_point.a() &lt; 0.0) &#123;        break;      &#125;      ++stop_index;    &#125;  &#125; else &#123;    // 后退情况    while (stop_index &lt; trajectory_message_-&gt;trajectory_point_size()) &#123;      auto &amp;current_trajectory_point =          trajectory_message_-&gt;trajectory_point(stop_index);      // 遍历每个轨迹点，判断是否满足驻车条件      if (current_trajectory_point.v() &lt; kSpeedThreshold &amp;&amp;          current_trajectory_point.a() &lt; kBackwardAccThreshold &amp;&amp;          current_trajectory_point.a() &gt; 0.0) &#123;        break;      &#125;      ++stop_index;    &#125;  &#125;  if (stop_index == trajectory_message_-&gt;trajectory_point_size()) &#123;    // 停车下标是最后一个    --stop_index;    if (fabs(trajectory_message_-&gt;trajectory_point(stop_index).v()) &lt;        kParkingSpeed) &#123;      ADEBUG &lt;&lt; &quot;the last point is selected as parking point&quot;;    &#125; else &#123;      ADEBUG &lt;&lt; &quot;the last point found in path and speed &gt; speed_deadzone&quot;;      debug-&gt;set_path_remain(10000); // 设置停车距离无穷远    &#125;  &#125;  // 记录当前位置到停车位置的距离  debug-&gt;set_path_remain(      trajectory_message_-&gt;trajectory_point(stop_index).path_point().s() -      debug-&gt;current_station());&#125;\n Reset()\nStatus LonController::Reset() &#123;  speed_pid_controller_.Reset();  station_pid_controller_.Reset();  return Status::OK();&#125;\n Class TrajectoryAnalyzer\n TrajectoryAnalyzer()\nTrajectoryAnalyzer::TrajectoryAnalyzer(    const planning::ADCTrajectory *planning_published_trajectory) &#123;  // 规划轨迹时间戳  header_time_ = planning_published_trajectory-&gt;header().timestamp_sec();  // 规划轨迹帧数  seq_num_ = planning_published_trajectory-&gt;header().sequence_num();  for (int i = 0; i &lt; planning_published_trajectory-&gt;trajectory_point_size();       ++i) &#123;    // 整合规划轨迹点集合    trajectory_points_.push_back(        planning_published_trajectory-&gt;trajectory_point(i));  &#125;&#125;\n QueryMatchedPathPoint()\n找到离散曲线上离(x,y)最近的点，通过差值算出来的。\nPathPoint TrajectoryAnalyzer::QueryMatchedPathPoint(const double x,                                                    const double y) const &#123;  CHECK_GT(trajectory_points_.size(), 0);  // 计算轨迹第一个点到（x,y）的距离  double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);  size_t index_min = 0;  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) &#123;    // 遍历每一个点，选取最近的点    double d_temp = PointDistanceSquare(trajectory_points_[i], x, y);    if (d_temp &lt; d_min) &#123;      d_min = d_temp;      index_min = i;    &#125;  &#125;  // 计算最近的范围  size_t index_start = index_min == 0 ? index_min : index_min - 1;  size_t index_end =      index_min + 1 == trajectory_points_.size() ? index_min : index_min + 1;  const double kEpsilon = 0.001;  if (index_start == index_end ||      std::fabs(trajectory_points_[index_start].path_point().s() -                trajectory_points_[index_end].path_point().s()) &lt;= kEpsilon) &#123;    // 输出 PathPoint 的格式    return TrajectoryPointToPathPoint(trajectory_points_[index_start]);  &#125;  return FindMinDistancePoint(trajectory_points_[index_start],                              trajectory_points_[index_end], x, y);&#125;\n FindMinDistancePoint()\n在两点之间找到离(x,y)最近的点，通过黄金分割方法查找。\nPathPoint TrajectoryAnalyzer::FindMinDistancePoint(const TrajectoryPoint &amp;p0,                                                   const TrajectoryPoint &amp;p1,                                                   const double x,                                                   const double y) const &#123;  // given the fact that the discretized trajectory is dense enough,  // we assume linear trajectory between consecutive trajectory points.  auto dist_square = [&amp;p0, &amp;p1, &amp;x, &amp;y](const double s) &#123;    double px = common::math::lerp(p0.path_point().x(), p0.path_point().s(),                                   p1.path_point().x(), p1.path_point().s(), s);    double py = common::math::lerp(p0.path_point().y(), p0.path_point().s(),                                   p1.path_point().y(), p1.path_point().s(), s);    double dx = px - x;    double dy = py - y;    return dx * dx + dy * dy;  &#125;;  PathPoint p = p0.path_point();  double s = common::math::GoldenSectionSearch(dist_square, p0.path_point().s(),                                               p1.path_point().s());  p.set_s(s);  p.set_x(common::math::lerp(p0.path_point().x(), p0.path_point().s(),                             p1.path_point().x(), p1.path_point().s(), s));  p.set_y(common::math::lerp(p0.path_point().y(), p0.path_point().s(),                             p1.path_point().y(), p1.path_point().s(), s));  p.set_theta(common::math::slerp(p0.path_point().theta(), p0.path_point().s(),                                  p1.path_point().theta(), p1.path_point().s(),                                  s));  // approximate the curvature at the intermediate point  p.set_kappa(common::math::lerp(p0.path_point().kappa(), p0.path_point().s(),                                 p1.path_point().kappa(), p1.path_point().s(),                                 s));  return p;&#125;\n ToTrajectoryFrame()\n将(x,y,theta,v)(x,y,theta,v)(x,y,theta,v)转换成SL坐标系下的(s,s˙,l,l′)(s, \\dot s, l, l&#x27;)(s,s˙,l,l′)。\nvoid TrajectoryAnalyzer::ToTrajectoryFrame(const double x, const double y,                                           const double theta, const double v,                                           const PathPoint &amp;ref_point,                                           double *ptr_s, double *ptr_s_dot,                                           double *ptr_d,                                           double *ptr_d_dot) const &#123;  double dx = x - ref_point.x();  double dy = y - ref_point.y();  double cos_ref_theta = std::cos(ref_point.theta());  double sin_ref_theta = std::sin(ref_point.theta());  // the sin of diff angle between vector (cos_ref_theta, sin_ref_theta) and  // (dx, dy)  double cross_rd_nd = cos_ref_theta * dy - sin_ref_theta * dx;  *ptr_d = cross_rd_nd;  // the cos of diff angle between vector (cos_ref_theta, sin_ref_theta) and  // (dx, dy)  double dot_rd_nd = dx * cos_ref_theta + dy * sin_ref_theta;  *ptr_s = ref_point.s() + dot_rd_nd;  double delta_theta = theta - ref_point.theta();  double cos_delta_theta = std::cos(delta_theta);  double sin_delta_theta = std::sin(delta_theta);  *ptr_d_dot = v * sin_delta_theta;  double one_minus_kappa_r_d = 1 - ref_point.kappa() * (*ptr_d);  if (one_minus_kappa_r_d &lt;= 0.0) &#123;    AERROR &lt;&lt; &quot;TrajectoryAnalyzer::ToTrajectoryFrame &quot;              &quot;found fatal reference and actual difference. &quot;              &quot;Control output might be unstable:&quot;           &lt;&lt; &quot; ref_point.kappa:&quot; &lt;&lt; ref_point.kappa()           &lt;&lt; &quot; ref_point.x:&quot; &lt;&lt; ref_point.x()           &lt;&lt; &quot; ref_point.y:&quot; &lt;&lt; ref_point.y() &lt;&lt; &quot; car x:&quot; &lt;&lt; x           &lt;&lt; &quot; car y:&quot; &lt;&lt; y &lt;&lt; &quot; *ptr_d:&quot; &lt;&lt; *ptr_d           &lt;&lt; &quot; one_minus_kappa_r_d:&quot; &lt;&lt; one_minus_kappa_r_d;    // currently set to a small value to avoid control crash.    one_minus_kappa_r_d = 0.01;  &#125;  *ptr_s_dot = v * cos_delta_theta / one_minus_kappa_r_d;&#125;\n QueryNearestPointByAbsoluteTime()\nTrajectoryPoint TrajectoryAnalyzer::QueryNearestPointByAbsoluteTime(    const double t) const &#123;  return QueryNearestPointByRelativeTime(t - header_time_);&#125;\n QueryNearestPointByRelativeTime()\n通过相对时间找到离散轨迹点集里面最近的轨迹点。\nTrajectoryPoint TrajectoryAnalyzer::QueryNearestPointByRelativeTime(    const double t) const &#123;  auto func_comp = [](const TrajectoryPoint &amp;point,                      const double relative_time) &#123;    return point.relative_time() &lt; relative_time;  &#125;;  // 找到时间匹配的下标值  auto it_low = std::lower_bound(trajectory_points_.begin(),                                 trajectory_points_.end(), t, func_comp);  if (it_low == trajectory_points_.begin()) &#123;    return trajectory_points_.front();  &#125;  if (it_low == trajectory_points_.end()) &#123;    return trajectory_points_.back();  &#125;  if (FLAGS_query_forward_time_point_only) &#123;    return *it_low;  &#125; else &#123;    // 找最近时间点的轨迹点    auto it_lower = it_low - 1;    if (it_low-&gt;relative_time() - t &lt; t - it_lower-&gt;relative_time()) &#123;      return *it_low;    &#125;    return *it_lower;  &#125;&#125;\n QueryNearestPointByPosition()\n找到离散轨迹点集里面离(x,y)最近的轨迹点。\nTrajectoryPoint TrajectoryAnalyzer::QueryNearestPointByPosition(    const double x, const double y) const &#123;  double d_min = PointDistanceSquare(trajectory_points_.front(), x, y);  size_t index_min = 0;  for (size_t i = 1; i &lt; trajectory_points_.size(); ++i) &#123;    double d_temp = PointDistanceSquare(trajectory_points_[i], x, y);    if (d_temp &lt; d_min) &#123;      d_min = d_temp;      index_min = i;    &#125;  &#125;  return trajectory_points_[index_min];&#125;\n TrajectoryTransformToCOM()\n将基于后轴中心的轨迹点集转换到基于车辆质心位置的轨迹点集。\n  /**   * @brief Transform the current trajectory points to the center of mass(COM)   * of the vehicle, given the distance from rear wheels to the center of mass.   * @param rear_to_com_distance Distance from rear wheels to   *        the vehicle&#x27;s center of mass.   */void TrajectoryAnalyzer::TrajectoryTransformToCOM(    const double rear_to_com_distance) &#123;  CHECK_GT(trajectory_points_.size(), 0);  for (size_t i = 0; i &lt; trajectory_points_.size(); ++i) &#123;    // 遍历每个轨迹点    auto com = ComputeCOMPosition(rear_to_com_distance,                                  trajectory_points_[i].path_point());    trajectory_points_[i].mutable_path_point()-&gt;set_x(com.x());    trajectory_points_[i].mutable_path_point()-&gt;set_y(com.y());  &#125;&#125;\n ComputeCOMPosition()\n将点平移指定距离。\n  /**   * @brief Compute the position of center of mass(COM) of the vehicle,   *        given the distance from rear wheels to the center of mass.   * @param rear_to_com_distance Distance from rear wheels to   *        the vehicle&#x27;s center of mass.   * @param path_point PathPoint along the published planning trajectory.   * @return The position of the vehicle&#x27;s center of mass.   */common::math::Vec2d TrajectoryAnalyzer::ComputeCOMPosition(    const double rear_to_com_distance, const PathPoint &amp;path_point) const &#123;  // Initialize the vector for coordinate transformation of the position  // reference point  Eigen::Vector3d v;  const double cos_heading = std::cos(path_point.theta());  const double sin_heading = std::sin(path_point.theta());  v &lt;&lt; rear_to_com_distance * cos_heading, rear_to_com_distance * sin_heading,      0.0;  // Original position reference point at center of rear-axis  Eigen::Vector3d pos_vec(path_point.x(), path_point.y(), path_point.z());  // Transform original position with vector v  Eigen::Vector3d com_pos_3d = v + pos_vec;  // Return transfromed x and y  return common::math::Vec2d(com_pos_3d[0], com_pos_3d[1]);&#125;","categories":["算法","Apollo源码解读"]},{"title":"Apollo v8.0.0 代码解读 之 Docker启动脚本","url":"/2023/01/29/Apollo%20v8.0.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BDocker%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/","content":"这篇博客深入解析了 Apollo v8.0.0 中用于启动开发环境的 Docker 启动脚本，包括 dev_start.sh 的执行流程、环境变量设置、镜像选择逻辑、数据卷挂载、GPU检测与配置等关键机制。通过逐步剖析 shell 脚本结构，帮助读者全面理解 Apollo 启动容器的底层逻辑与自动化设计思路，为二次开发和调试提供了坚实基础。\n\n 启动流程\n\n dev_start.sh\n 变量定义\n# 获取该文件所在位置的绝对路径CURR_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot; &amp;&amp; pwd -P)&quot;# 执行指定脚本source &quot;$&#123;CURR_DIR&#125;/docker_base.sh&quot;CACHE_ROOT_DIR=&quot;$&#123;APOLLO_ROOT_DIR&#125;/.cache&quot;DOCKER_REPO=&quot;apolloauto/apollo&quot;DEV_CONTAINER=&quot;apollo_dev_$&#123;USER&#125;&quot;DEV_INSIDE=&quot;in-dev-docker&quot;# 定义一个数组# 读取数组方式：$&#123;数组名[下标]&#125;SUPPORTED_ARCHS=(x86_64 aarch64)# 电脑架构类型：x86_64还是aarch64TARGET_ARCH=&quot;$(uname -m)&quot;VERSION_X86_64=&quot;dev-x86_64-18.04-20221124_1708&quot;TESTING_VERSION_X86_64=&quot;dev-x86_64-18.04-testing-20210112_0008&quot;VERSION_AARCH64=&quot;dev-aarch64-18.04-20201218_0030&quot;USER_VERSION_OPT=FAST_MODE=&quot;no&quot;# 地理位置GEOLOC=USE_LOCAL_IMAGE=0CUSTOM_DIST=USER_AGREED=&quot;no&quot;VOLUME_VERSION=&quot;latest&quot;SHM_SIZE=&quot;2G&quot;USER_SPECIFIED_MAPS=MAP_VOLUMES_CONF=OTHER_VOLUMES_CONF=# 定义一个数组DEFAULT_MAPS=(    sunnyvale_big_loop    sunnyvale_loop    sunnyvale_with_two_offices    san_mateo    apollo_virutal_map)# 定义一个数组DEFAULT_TEST_MAPS=(    sunnyvale_big_loop    sunnyvale_loop)\n main函数\n# 传递给函数或脚本的所有参数main &quot;$@&quot;function main() &#123;    check_host_environment    check_target_arch    parse_arguments &quot;$@&quot;    if [[ &quot;$&#123;USER_AGREED&#125;&quot; != &quot;yes&quot; ]]; then        check_agreement    fi    determine_dev_image &quot;$&#123;USER_VERSION_OPT&#125;&quot;    geo_specific_config &quot;$&#123;GEOLOC&#125;&quot;    if [[ &quot;$&#123;USE_LOCAL_IMAGE&#125;&quot; -gt 0 ]]; then        info &quot;Start docker container based on local image : $&#123;DEV_IMAGE&#125;&quot;    fi    if ! docker_pull &quot;$&#123;DEV_IMAGE&#125;&quot;; then        error &quot;Failed to pull docker image $&#123;DEV_IMAGE&#125;&quot;        exit 1    fi    info &quot;Remove existing Apollo Development container ...&quot;    remove_container_if_exists $&#123;DEV_CONTAINER&#125;    info &quot;Determine whether host GPU is available ...&quot;    determine_gpu_use_host    info &quot;USE_GPU_HOST: $&#123;USE_GPU_HOST&#125;&quot;\t\t\t# 设定数据卷，必须执行    local local_volumes=    setup_devices_and_mount_local_volumes local_volumes    mount_map_volumes    mount_other_volumes    info &quot;Starting Docker container \\&quot;$&#123;DEV_CONTAINER&#125;\\&quot; ...&quot;    local local_host=&quot;$(hostname)&quot; # 主机名字    local display=&quot;$&#123;DISPLAY:-:0&#125;&quot;    local user=&quot;$&#123;USER&#125;&quot;    local uid=&quot;$(id -u)&quot;    local group=&quot;$(id -g -n)&quot;    local gid=&quot;$(id -g)&quot;    set -x    $&#123;DOCKER_RUN_CMD&#125; -itd \\ # -i:打开容器的标准输入，打开STDIN，用于控制台交互  -t:告诉docker为容器建立一个命令行终端，分配tty设备，该可以支持终端登录  -d:使容器在后台运行        --privileged \\ # 赋予此容器扩展的特权        --name &quot;$&#123;DEV_CONTAINER&#125;&quot; \\ # 为容器设置一个名字        -e DISPLAY=&quot;$&#123;display&#125;&quot; \\        -e DOCKER_USER=&quot;$&#123;user&#125;&quot; \\        -e USER=&quot;$&#123;user&#125;&quot; \\ # 设定容器用户        -e DOCKER_USER_ID=&quot;$&#123;uid&#125;&quot; \\ # 设定用户ID        -e DOCKER_GRP=&quot;$&#123;group&#125;&quot; \\ # 设定用户组名字        -e DOCKER_GRP_ID=&quot;$&#123;gid&#125;&quot; \\ # 设定用户组ID        -e DOCKER_IMG=&quot;$&#123;DEV_IMAGE&#125;&quot; \\ # 设置容器镜像        -e USE_GPU_HOST=&quot;$&#123;USE_GPU_HOST&#125;&quot; \\        -e NVIDIA_VISIBLE_DEVICES=all \\        -e NVIDIA_DRIVER_CAPABILITIES=compute,video,graphics,utility \\        $&#123;MAP_VOLUMES_CONF&#125; \\ # 挂载地图数据卷        $&#123;OTHER_VOLUMES_CONF&#125; \\ # 挂载其他数据卷        $&#123;local_volumes&#125; \\ # 挂载本地数据卷，最关键        --net host \\ # 指定容器的网络连接类型，支持bridge/host/none/container四种类型        -w /apollo \\ # 指定容器的工作目录，也就是一进入容器就在这目录下        --add-host &quot;$&#123;DEV_INSIDE&#125;:127.0.0.1&quot; \\ # 添加自定义主机到IP的映射（host：ip）        --add-host &quot;$&#123;local_host&#125;:127.0.0.1&quot; \\        --hostname &quot;$&#123;DEV_INSIDE&#125;&quot; \\ # 容器的主机名字        --shm-size &quot;$&#123;SHM_SIZE&#125;&quot; \\ # 设置共享内存大小        --pid=host \\ # 使用PID命名空间        -v /dev/null:/dev/raw1394 \\        &quot;$&#123;DEV_IMAGE&#125;&quot; \\ # 基于哪个镜像创建的容器        /bin/bash # /bin/bash:告诉docker要在容器里面执行此命令    if [ $? -ne 0 ]; then        error &quot;Failed to start docker container \\&quot;$&#123;DEV_CONTAINER&#125;\\&quot; based on image: $&#123;DEV_IMAGE&#125;&quot;        exit 1    fi    set +x    postrun_start_user &quot;$&#123;DEV_CONTAINER&#125;&quot;    ok &quot;Congratulations! You have successfully finished setting up Apollo Dev Environment.&quot;    ok &quot;To login into the newly created $&#123;DEV_CONTAINER&#125; container, please run the following command:&quot;    ok &quot;  bash docker/scripts/dev_into.sh&quot;    ok &quot;Enjoy!&quot;&#125;\nid命令用于显示用户的 ID，以及所属群组的ID。\n\n-u显示用户ID\n-g显示用户所属群组的ID\n-n显示用户，所属群组 , 附加群组的名称\n\nset -x显示脚本执行过程，并显示脚本对变量的处理结果。如果，某一个脚本使用了大量的变量，而我们希望能看到这些变量的传递，使用是否正确，那么，set -x 将是你很好的选择。（快速定位问题，尤其是变量所产生的问题）。\n一个显示脚本执行过程并将脚本内的变量的值暴露出来的一个开关，-x 是开，+x等于是默认的关闭，一般情况下，脚本是关闭这个显示过程的。\n与PID命名空间相关的全局资源就是进程 ID 数字空间。这意味着在不同 PID 命名空间中的进程可以有相同的进程 ID。PID 命名空间实现的容器可在主机之间迁移，并保持容器内的进程 ID 不变。\n对于传统 Linux （或 UNIX）系统，PID 命名空间内的进程 ID 是唯一的，从 1 开始依次分配，对于传统 Linux 系统，PID 1是 init 进程，比较特殊：它是第一个在命名空间内创建的进程，在命名空间内执行特定的管理任务。\n check_host_environment\n判断电脑系统\nfunction check_host_environment() &#123;    if [[ &quot;$&#123;HOST_OS&#125;&quot; != &quot;Linux&quot; ]]; then        warning &quot;Running Apollo dev container on $&#123;HOST_OS&#125; is UNTESTED, exiting...&quot;        exit 1    fi&#125;\nHost OS (Host Operating System)中host是主人的意思，那Host OS可以粗暴地翻译成主人操作系统，而Guest OS也可直译为客人操作系统。\nHost OS(主人操作系统）就是安装在你硬件设备上的系统，而Guest OS(客人操作系统）则是安装在虚拟机（VM）上面的系统。\nexit退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。\n check_target_arch\n判断电脑架构类型\nfunction check_target_arch() &#123;    local arch=&quot;$&#123;TARGET_ARCH&#125;&quot;    for ent in &quot;$&#123;SUPPORTED_ARCHS[@]&#125;&quot;; do        if [[ &quot;$&#123;ent&#125;&quot; == &quot;$&#123;TARGET_ARCH&#125;&quot; ]]; then            return 0        fi    done    error &quot;Unsupported target architecture: $&#123;TARGET_ARCH&#125;.&quot;    exit 1&#125;\nlocal一般用于局部变量声明，多在在函数内部使用。\n1. Shell脚本中定义的变量是global的，其作用域从被定义的地方开始，到shell结束或被显示删除的地方为止。\n2. Shell函数定义的变量默认是global的，其作用域从“函数被调用时执行变量定义的地方”开始，到shell结束或被显示删除处为止。函数定义的变量可以被显示定义成local的，其作用域局限于函数内。但请注意，函数的参数是local的。\n3. 如果同名，Shell函数定义的local变量会屏蔽脚本定义的global变量。\n$&#123;SUPPORTED_ARCHS[@]&#125;: 数组所有元素，没有元素的下标省略。\n parse_arguments\nfunction parse_arguments() &#123;    local custom_version=&quot;&quot;    local custom_dist=&quot;&quot;    local shm_size=&quot;&quot;    local geo=&quot;&quot;\t\t\t# $#传入参数个数    while [ $# -gt 0 ]; do # 如果传入参数个数大于0        local opt=&quot;$1&quot; # 获取第一个参数        shift # 平移参数列表，即清除第一个参数，也就是原来的$2变成现在的$1        case &quot;$&#123;opt&#125;&quot; in            -t | --tag)                if [ -n &quot;$&#123;custom_version&#125;&quot; ]; then                    warning &quot;Multiple option $&#123;opt&#125; specified, only the last one will take effect.&quot;                fi\t\t\t\t# 设置版本名字                custom_version=&quot;$1&quot;                shift # 把版本参数移除                optarg_check_for_opt &quot;$&#123;opt&#125;&quot; &quot;$&#123;custom_version&#125;&quot;                ;;            -d | --dist)                custom_dist=&quot;$1&quot;                shift                optarg_check_for_opt &quot;$&#123;opt&#125;&quot; &quot;$&#123;custom_dist&#125;&quot;                ;;            -h | --help)                show_usage                exit 1                ;;            -f | --fast)                FAST_MODE=&quot;yes&quot;                ;;            -g | --geo)                geo=&quot;$1&quot;                shift                optarg_check_for_opt &quot;$&#123;opt&#125;&quot; &quot;$&#123;geo&#125;&quot;                ;;            -l | --local)                USE_LOCAL_IMAGE=1                ;;            --shm-size)                shm_size=&quot;$1&quot;                shift                optarg_check_for_opt &quot;$&#123;opt&#125;&quot; &quot;$&#123;shm_size&#125;&quot;                ;;            --map)                map_name=&quot;$1&quot;                shift                USER_SPECIFIED_MAPS=&quot;$&#123;USER_SPECIFIED_MAPS&#125; $&#123;map_name&#125;&quot;                ;;            -y)                USER_AGREED=&quot;yes&quot;                ;;            stop)                info &quot;Now, stop all Apollo containers created by $&#123;USER&#125; ...&quot;                stop_all_apollo_containers &quot;-f&quot; # 入参带强制值令                exit 0                ;;            *)                warning &quot;Unknown option: $&#123;opt&#125;&quot;                exit 2                ;;        esac    done # End while loop\t\t\t# 判断变量是否存在，若存在则赋值    [[ -n &quot;$&#123;geo&#125;&quot; ]] &amp;&amp; GEOLOC=&quot;$&#123;geo&#125;&quot;    [[ -n &quot;$&#123;custom_version&#125;&quot; ]] &amp;&amp; USER_VERSION_OPT=&quot;$&#123;custom_version&#125;&quot;    [[ -n &quot;$&#123;custom_dist&#125;&quot; ]] &amp;&amp; CUSTOM_DIST=&quot;$&#123;custom_dist&#125;&quot;    [[ -n &quot;$&#123;shm_size&#125;&quot; ]] &amp;&amp; SHM_SIZE=&quot;$&#123;shm_size&#125;&quot;&#125;\n 数字关系运算符\n下面假定变量 a 为 10，变量 b 为 20：\n-eq：检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。\n-ne： 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。\n-gt： 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。\n-lt： 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。\n-ge： 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。\n-le： 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。\n\n\n\n名称\n含义\n\n\n\n\n$#\n传给脚本的参数个数\n\n\n$0\n脚本本身的名字\n\n\n$1\n传递给该shell脚本的第一个参数\n\n\n$2\n传递给该shell脚本的第二个参数\n\n\n$@\n传给脚本的所有参数的列表\n\n\n$*\n以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个\n\n\n$$\n脚本运行的当前进程ID号\n\n\n$?\n显示最后命令的退出状态，0表示没有错误，其他表示有错误\n\n\n\n 字符串运算符\n下表列出了常用的字符串运算符，假定变量a为&quot;abc&quot;，变量b为&quot;efg&quot;：\n=：检测两个字符串是否相等，相等返回true。[ $a = $b ]返回false。\n!=：检测两个字符串是否相等，不相等返回true。[ $a != $b ]返回true。\n-z：检测字符串长度是否为0，为0返回true。[ -z $a ]返回false。\n-n：检测字符串长度是否为0，不为0返回true。[ -n &quot;$a&quot; ]返回true。\n$：检测字符串是否为空，不为空返回true。[ $a ]返回true。\n 逻辑判断\n[ ]： 中括号旁边和运算符两边必须添加空格 （可以使用，不推荐）\n[[ ]]：中括号旁边和运算符两边必须添加空格 （字符串验证时，推荐使用）\n(( ))： 中括号旁边和运算符两边必须添加空格 （数字验证时，推荐使用）\n[[]]和(())分别是[ ]的针对数学比较表达式和字符串表达式的加强版。\n 运算符\n\n\n|运算符\n管道符号，是unix一个很强大的功能,符号为一条竖线|。\n用法:\ncommand 1 | command 2\n他的功能是把第一个命令command 1执行的结果作为参数，输入传给command 2\n\n\n&amp;&amp;运算符:\n&amp;&amp;左边的命令command 1返回真(即返回0，成功被执行）后，&amp;&amp;右边的命令command 2才能够被执行；换句话说，“如果这个命令执行成功&amp;&amp;那么执行这个命令”。\n语法格式如下：\ncommand1 &amp;&amp; command2 &amp;&amp; command3 ...\n命令之间使用&amp;&amp;连接，实现逻辑与的功能。\n只有在&amp;&amp;左边的命令返回真（命令返回值$? == 0），&amp;&amp;右边的命令才会被执行。\n只要有一个命令返回假（命令返回值$? == 1），后面的命令就不会被执行。\n\n\n||运算符:\ncommand1 || command2\n||则与&amp;&amp;相反。如果||左边的命令command 1未执行成功，那么就执行||右边的命令command 2；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。\n命令之间使用||连接，实现逻辑或的功能。\n只有在||左边的命令返回假（命令返回值$? == 1），||右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。\n只要有一个命令返回真（命令返回值$? == 0），后面的命令就不会被执行。\n  echo $BASH |grep -q &#x27;bash&#x27; || &#123; exec bash &quot;$0&quot; &quot;$@&quot; || exit 1; &#125;    # 系统调用exec是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。\n\n\n()运算符:\n如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。\n格式:\n(command1;command2;command3....)\n多个命令之间用;分隔\n一条命令需要独占一个物理行，如果需要将多条命令放在同一行，命令之间使用命令分隔符;分隔。执行的效果等同于多个独立的命令单独执行的效果。\n()表示在当前 shell 中将多个命令作为一个整体执行。需要注意的是，使用()括起来的命令在执行前面都不会切换当前工作目录，也就是说命令组合都是在当前工作目录下被执行的，尽管命令中有切换目录的命令。\n命令组合常和命令执行控制结合起来使用。\n\n\n&#123;&#125;运算符:\n如果使用&#123;&#125;来代替()，那么相应的命令将在子shell而不是当前shell中作为一个整体被执行，只有在&#123;&#125;中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子shell中执行，否则在当前shell执行。\n它的一般形式为：\n&#123; command1;command2;command3… &#125;\n注意：在使用&#123;&#125;时，{}与命令之间必须使用一个空格\n\n\n optarg_check_for_opt\nfunction optarg_check_for_opt() &#123;  local opt=&quot;$1&quot;  local optarg=&quot;$2&quot;  # 判断参数是否为空，或者带 - 前缀  if [[ -z &quot;$&#123;optarg&#125;&quot; || &quot;$&#123;optarg&#125;&quot; =~ ^-.* ]]; then      error &quot;Missing parameter for $&#123;opt&#125;. Exiting...&quot;      exit 3  fi&#125;\n 逻辑运算符\n以下介绍Shell的逻辑运算符，假定变量a为10，变量b为20:\n&amp;&amp;：逻辑的 AND，[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]，返回false\n||：逻辑的 OR，[[ $a -lt 100 || $b -gt 100 ]]，返回true\n=~：正则表达式匹配，用在[[ ]]测试中。\n^-.*意思如下：\n\n^表示字符串开头，^-以-开头的字符串\n.除换行符以外的所有字符\n*匹配0次或多次\n\nfunction show_usage() &#123;    cat &lt;&lt;EOFUsage: $0 [options] ...OPTIONS:    -h, --help             Display this help and exit.    -f, --fast             Fast mode without pulling all map volumes.    -g, --geo &lt;us|cn|none&gt; Pull docker image from geolocation specific registry mirror.    -l, --local            Use local docker image.    -t, --tag &lt;TAG&gt;        Specify docker image with tag &lt;TAG&gt; to start.    -d, --dist             Specify Apollo distribution(stable/testing)    --shm-size &lt;bytes&gt;     Size of /dev/shm . Passed directly to &quot;docker run&quot;    -y                     Agree to Apollo License Agreement non-interactively.    stop                   Stop all running Apollo containers.EOF&#125;\ncat &lt;&lt;EOF\ncat命令表示查看，而cat &lt;&lt;EOF命令表示将进行输入，直到以EOF终止符来结束输入（最后的新行）。EOF必须写在一行的头部，前面不能有制表符或者空格。如果结束符EOF前面有制表符或者空格，则EOF不会被当做结束符，只会被视为继续输入的状态。\n简单的理解，就是随意输入一堆字符，当输入EOF的时候才真正结束。\n结合这两个标识，即可避免使用多行echo命令的方式，并实现多行输出的结果。\n stop_all_apollo_containers\nfunction stop_all_apollo_containers() &#123;    local force=&quot;$1&quot; # 强制值令本地参数    local running_containers\t# 获取docker运行container列表    running_containers=&quot;$(docker ps -a --format &#x27;&#123;&#123;.Names&#125;&#125;&#x27;)&quot;\t# 遍历循环先有容器    for container in $&#123;running_containers[*]&#125;; do\t\t# 若是属于apollo项目的容器则关掉        if [[ &quot;$&#123;container&#125;&quot; =~ apollo_.*_$&#123;USER&#125; ]]; then            #printf %-*s 70 &quot;Now stop container: $&#123;container&#125; ...&quot;            #printf &quot;\\033[32m[DONE]\\033[0m\\n&quot;            #printf &quot;\\033[31m[FAILED]\\033[0m\\n&quot;            info &quot;Now stop container $&#123;container&#125; ...&quot;            if docker stop &quot;$&#123;container&#125;&quot; &gt;/dev/null; then                if [[ &quot;$&#123;force&#125;&quot; == &quot;-f&quot; || &quot;$&#123;force&#125;&quot; == &quot;--force&quot; ]]; then                    docker rm -f &quot;$&#123;container&#125;&quot; 2&gt;/dev/null                fi                info &quot;Done.&quot;            else                warning &quot;Failed.&quot;            fi        fi    done&#125;\n/dev/null是一个特殊的设备文件，它丢弃一切写入其中的数据 可以将它视为一个黑洞，它等效于只写文件, 写入其中的所有内容都会消失, 尝试从中读取或输出不会有任何结果，同样，/dev/nul 在命令行和脚本中都非常有用。\n用途：/dev/null通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成，任何你想丢弃的数据都可以写入其中。\nLinux系统预留可三个文件描述符：0、1和2，他们的意义如下所示：\n\n0——标准输入（stdin）\n1——标准输出（stdout）\n2——标准错误（stderr）\n\n重定向的符号有两个：&gt;或&gt;&gt;，两者的区别是：前者会先清空文件，然后再写入内容，后者会将重定向的内容追加到现有文件的尾部。\n2&gt;/dev/null的意思就是将标准错误stderr删掉。\n check_agreement\n# Check whether user has agreed license agreementfunction check_agreement() &#123;    local agreement_record=&quot;$&#123;HOME&#125;/.apollo_agreement.txt&quot;    if [[ -e &quot;$&#123;agreement_record&#125;&quot; ]]; then        return 0    fi    local agreement_file    agreement_file=&quot;$&#123;APOLLO_ROOT_DIR&#125;/scripts/AGREEMENT.txt&quot;    if [[ ! -f &quot;$&#123;agreement_file&#125;&quot; ]]; then        error &quot;AGREEMENT $&#123;agreement_file&#125; does not exist.&quot;        exit 1    fi    cat &quot;$&#123;agreement_file&#125;&quot;    local tip=&quot;Type &#x27;y&#x27; or &#x27;Y&#x27; to agree to the license agreement above, \\or type any other key to exit:&quot;    echo -n &quot;$&#123;tip&#125;&quot;    local answer=&quot;$(read_one_char_from_stdin)&quot;    echo    if [[ &quot;$&#123;answer&#125;&quot; != &quot;y&quot; ]]; then        exit 1    fi    cp -f &quot;$&#123;agreement_file&#125;&quot; &quot;$&#123;agreement_record&#125;&quot;    echo &quot;$&#123;tip&#125;&quot; &gt;&gt; &quot;$&#123;agreement_record&#125;&quot;    echo &quot;$&#123;user_agreed&#125;&quot; &gt;&gt; &quot;$&#123;agreement_record&#125;&quot;&#125;\n determine_dev_image\n# 该函数用于确定使用哪个版本function determine_dev_image() &#123;    local version=&quot;$1&quot;    # If no custom version specified    if [[ -z &quot;$&#123;version&#125;&quot; ]]; then # 确定版本变量是否为0，是则往下走\t    # 判断目标架构        if [[ &quot;$&#123;TARGET_ARCH&#125;&quot; == &quot;x86_64&quot; ]]; then\t\t\t# 判断是否是测试情景            if [[ &quot;$&#123;CUSTOM_DIST&#125;&quot; == &quot;testing&quot; ]]; then                version=&quot;$&#123;TESTING_VERSION_X86_64&#125;&quot;            else                version=&quot;$&#123;VERSION_X86_64&#125;&quot;            fi        elif [[ &quot;$&#123;TARGET_ARCH&#125;&quot; == &quot;aarch64&quot; ]]; then            version=&quot;$&#123;VERSION_AARCH64&#125;&quot;        else            error &quot;Logic can&#x27;t reach here! Please report this issue to Apollo@GitHub.&quot;            exit 3        fi    fi    DEV_IMAGE=&quot;$&#123;DOCKER_REPO&#125;:$&#123;version&#125;&quot;&#125;\n geo_specific_config\n# 根据地理位置设定注册位置function geo_specific_config() &#123;    local geo=&quot;$1&quot;    if [[ -z &quot;$&#123;geo&#125;&quot; ]]; then        info &quot;Use default GeoLocation settings&quot;        return    fi    info &quot;Setup geolocation specific configurations for $&#123;geo&#125;&quot;    if [[ &quot;$&#123;geo&#125;&quot; == &quot;cn&quot; ]]; then        info &quot;GeoLocation settings for Mainland China&quot;        GEO_REGISTRY=&quot;registry.baidubce.com&quot;    else        info &quot;GeoLocation settings for $&#123;geo&#125; is not ready, fallback to default&quot;    fi&#125;\n docker_pull\nfunction docker_pull() &#123;    local img=&quot;$1&quot;    if [[ &quot;$&#123;USE_LOCAL_IMAGE&#125;&quot; -gt 0 ]]; then        if docker images --format &quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot; | grep -q &quot;$&#123;img&#125;&quot;; then            info &quot;Local image $&#123;img&#125; found and will be used.&quot;            return        fi        warning &quot;Image $&#123;img&#125; not found locally although local mode enabled. Trying to pull from remote registry.&quot;    fi    if [[ -n &quot;$&#123;GEO_REGISTRY&#125;&quot; ]]; then        img=&quot;$&#123;GEO_REGISTRY&#125;/$&#123;img&#125;&quot;    fi    info &quot;Start pulling docker image $&#123;img&#125; ...&quot;    if ! docker pull &quot;$&#123;img&#125;&quot;; then        error &quot;Failed to pull docker image : $&#123;img&#125;&quot;        exit 1    fi&#125;\ngrep -q：不显示常规输出。\n 布尔运算符\n下表列出了常用的布尔运算符，假定变量a为 10，变量b为 20：\n!：非运算，表达式为true则返回false，否则返回true。[ ! false ]返回true。\n-o：或运算，有一个表达式为true则返回true。[ $a -lt 20 -o $b -gt 100 ]返回true。\n-a：与运算，两个表达式都为true才返回true。[ $a -lt 20 -a $b -gt 100 ]返回false。\n remove_container_if_exists\nfunction remove_container_if_exists() &#123;    local container=&quot;$1&quot;    if docker ps -a --format &#x27;&#123;&#123;.Names&#125;&#125;&#x27; | grep -q &quot;$&#123;container&#125;&quot;; then        info &quot;Removing existing Apollo container: $&#123;container&#125;&quot;        docker stop &quot;$&#123;container&#125;&quot; &gt;/dev/null # 停止容器        docker rm -v -f &quot;$&#123;container&#125;&quot; 2&gt;/dev/null # 删除容器    fi&#125;\n determine_gpu_use_host\nfunction determine_gpu_use_host() &#123;    if [[ &quot;$&#123;HOST_ARCH&#125;&quot; == &quot;aarch64&quot; ]]; then        if lsmod | grep -q &quot;^nvgpu&quot;; then            USE_GPU_HOST=1        fi    elif [[ &quot;$&#123;HOST_ARCH&#125;&quot; == &quot;x86_64&quot; ]]; then        if [[ ! -x &quot;$(command -v nvidia-smi)&quot; ]]; then            warning &quot;No nvidia-smi found. CPU will be used&quot;        elif [[ -z &quot;$(nvidia-smi)&quot; ]]; then            warning &quot;No GPU device found. CPU will be used.&quot;        else            USE_GPU_HOST=1        fi    else        error &quot;Unsupported CPU architecture: $&#123;HOST_ARCH&#125;&quot;        exit 1    fi    local nv_docker_doc=&quot;https://github.com/NVIDIA/nvidia-docker/blob/master/README.md&quot;    if [[ &quot;$&#123;USE_GPU_HOST&#125;&quot; -eq 1 ]]; then        if [[ -x &quot;$(which nvidia-container-toolkit)&quot; ]]; then            local docker_version\t\t\t# 只输出版本编号            docker_version=&quot;$(docker version --format &#x27;&#123;&#123;.Server.Version&#125;&#125;&#x27;)&quot;            if dpkg --compare-versions &quot;$&#123;docker_version&#125;&quot; &quot;ge&quot; &quot;19.03&quot;; then                DOCKER_RUN_CMD=&quot;docker run --gpus all&quot;            else                warning &quot;Please upgrade to docker-ce 19.03+ to access GPU from container.&quot;                USE_GPU_HOST=0            fi        elif [[ -x &quot;$(which nvidia-docker)&quot; ]]; then            DOCKER_RUN_CMD=&quot;nvidia-docker run&quot;        else            USE_GPU_HOST=0            warning &quot;Cannot access GPU from within container. Please install latest Docker&quot; \\                &quot;and NVIDIA Container Toolkit as described by: &quot;            warning &quot;  $&#123;nv_docker_doc&#125;&quot;        fi    fi&#125;\n执行lsmod指令，会列出所有已载入系统的模块。Linux操作系统的核心具有模块化的特性，因此在编译核心时，务须把全部的功能都放入核心。\n 文件运算符\n-b file：检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。\n-c file：检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。\n-d file：检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。\n-f file：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。\n-g file：检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。\n-k file：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。\n-p file：检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。\n-u file：检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。\n-r file：检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。\n-w file：检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。\n-x file：检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。\n-s file：检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。\n-e file：检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。\n setup_devices_and_mount_local_volumes\nfunction setup_devices_and_mount_local_volumes() &#123;    local __retval=&quot;$1&quot;\t# 检查是否有目录，否则创建目录    [ -d &quot;$&#123;CACHE_ROOT_DIR&#125;&quot; ] || mkdir -p &quot;$&#123;CACHE_ROOT_DIR&#125;&quot;    source &quot;$&#123;APOLLO_ROOT_DIR&#125;/scripts/apollo_base.sh&quot;    setup_device\t\t# 工作目录在主机与容器间映射    local volumes=&quot;-v $APOLLO_ROOT_DIR:/apollo&quot;    [ -d &quot;$&#123;APOLLO_CONFIG_HOME&#125;&quot; ] || mkdir -p &quot;$&#123;APOLLO_CONFIG_HOME&#125;&quot;    volumes=&quot;-v $&#123;APOLLO_CONFIG_HOME&#125;:$&#123;APOLLO_CONFIG_HOME&#125; $&#123;volumes&#125;&quot;    local teleop=&quot;$&#123;APOLLO_ROOT_DIR&#125;/../apollo-teleop&quot;    if [ -d &quot;$&#123;teleop&#125;&quot; ]; then        volumes=&quot;$&#123;volumes&#125; -v $&#123;teleop&#125;:/apollo/modules/teleop $&#123;volumes&#125;&quot;    fi    local apollo_tools=&quot;$&#123;APOLLO_ROOT_DIR&#125;/../apollo-tools&quot;    if [ -d &quot;$&#123;apollo_tools&#125;&quot; ]; then        volumes=&quot;$&#123;volumes&#125; -v $&#123;apollo_tools&#125;:/tools&quot;    fi    local os_release=&quot;$(lsb_release -rs)&quot;    case &quot;$&#123;os_release&#125;&quot; in        16.04)            warning &quot;[Deprecated] Support for Ubuntu 16.04 will be removed&quot; \\                &quot;in the near future. Please upgrade to ubuntu 18.04+.&quot;            volumes=&quot;$&#123;volumes&#125; -v /dev:/dev&quot;            ;;        18.04 | 20.04 | *)            volumes=&quot;$&#123;volumes&#125; -v /dev:/dev&quot;            ;;    esac    # local tegra_dir=&quot;/usr/lib/aarch64-linux-gnu/tegra&quot;    # if [[ &quot;$&#123;TARGET_ARCH&#125;&quot; == &quot;aarch64&quot; &amp;&amp; -d &quot;$&#123;tegra_dir&#125;&quot; ]]; then    #    volumes=&quot;$&#123;volumes&#125; -v $&#123;tegra_dir&#125;:$&#123;tegra_dir&#125;:ro&quot;    # fi    volumes=&quot;$&#123;volumes&#125; -v /media:/media \\                        -v /tmp/.X11-unix:/tmp/.X11-unix:rw \\                        -v /etc/localtime:/etc/localtime:ro \\                        -v /usr/src:/usr/src \\                        -v /lib/modules:/lib/modules&quot;    volumes=&quot;$(tr -s &quot; &quot; &lt;&lt;&lt;&quot;$&#123;volumes&#125;&quot;)&quot;    eval &quot;$&#123;__retval&#125;=&#x27;$&#123;volumes&#125;&#x27;&quot;&#125;\nmkdir [-p] dirName：-p确保目录名称存在，不存在的就建一个。\nLSB是Linux Standard Base（Linux标准库）的缩写，lsb_release命令用来与具体Linux发行版相关的Linux标准库信息。\n注：LSB的译法有Linux标准库，Linux标准规范\n-r：显示当前Linux发行版版本号\n-s：可以取消开头的显示字符\n-a：显示全部信息，包括LSB、版本号、代号、版本描述信息\n-c：显示当前Linux发行版代号(codename)\n-d：显示Linux发行版描述信息\n-i：显示该Linux系统的发行商\n-v：显示与你Linux发行版相对应的Linux版本库描述信息。Linux版本库模块描述使用冒号(:)分分隔\ntr，translate的简写，主要用于压缩重复字符，删除文件中的控制字符以及进行字符转换操作。\n-s：删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。\n-d：删除字符串1中所有输入字符。\n mount_map_volumes\nfunction mount_map_volumes() &#123;    info &quot;Starting mounting map volumes ...&quot;    if [ -n &quot;$&#123;USER_SPECIFIED_MAPS&#125;&quot; ]; then        for map_name in $&#123;USER_SPECIFIED_MAPS&#125;; do            restart_map_volume_if_needed &quot;$&#123;map_name&#125;&quot; &quot;$&#123;VOLUME_VERSION&#125;&quot;        done    fi    if [[ &quot;$FAST_MODE&quot; == &quot;no&quot; ]]; then        for map_name in $&#123;DEFAULT_MAPS[@]&#125;; do            restart_map_volume_if_needed &quot;$&#123;map_name&#125;&quot; &quot;$&#123;VOLUME_VERSION&#125;&quot;        done    else        for map_name in $&#123;DEFAULT_TEST_MAPS[@]&#125;; do            restart_map_volume_if_needed &quot;$&#123;map_name&#125;&quot; &quot;$&#123;VOLUME_VERSION&#125;&quot;        done    fi&#125;\n restart_map_volume_if_needed\nfunction restart_map_volume_if_needed() &#123;    local map_name=&quot;$1&quot;    local map_version=&quot;$2&quot;    local map_volume=&quot;apollo_map_volume-$&#123;map_name&#125;_$&#123;USER&#125;&quot;    local map_path=&quot;/apollo/modules/map/data/$&#123;map_name&#125;&quot;    if [[ $&#123;MAP_VOLUMES_CONF&#125; == *&quot;$&#123;map_volume&#125;&quot;* ]]; then        info &quot;Map $&#123;map_name&#125; has already been included.&quot;    else        local map_image=        if [ &quot;$&#123;TARGET_ARCH&#125;&quot; = &quot;aarch64&quot; ]; then            map_image=&quot;$&#123;DOCKER_REPO&#125;:map_volume-$&#123;map_name&#125;-$&#123;TARGET_ARCH&#125;-$&#123;map_version&#125;&quot;        else            map_image=&quot;$&#123;DOCKER_REPO&#125;:map_volume-$&#123;map_name&#125;-$&#123;map_version&#125;&quot;        fi        info &quot;Load map $&#123;map_name&#125; from image: $&#123;map_image&#125;&quot;        docker_restart_volume &quot;$&#123;map_volume&#125;&quot; &quot;$&#123;map_image&#125;&quot; &quot;$&#123;map_path&#125;&quot;        MAP_VOLUMES_CONF=&quot;$&#123;MAP_VOLUMES_CONF&#125; --volume $&#123;map_volume&#125;:$&#123;map_path&#125;&quot;    fi&#125;\n mount_other_volumes\n# 挂载其他数据卷，主要是用于感知模块function mount_other_volumes() &#123;    info &quot;Mount other volumes ...&quot;    local volume_conf=    # AUDIO    local audio_volume=&quot;apollo_audio_volume_$&#123;USER&#125;&quot;    local audio_image=&quot;$&#123;DOCKER_REPO&#125;:data_volume-audio_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local audio_path=&quot;/apollo/modules/audio/data/&quot;    docker_restart_volume &quot;$&#123;audio_volume&#125;&quot; &quot;$&#123;audio_image&#125;&quot; &quot;$&#123;audio_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;audio_volume&#125;:$&#123;audio_path&#125;&quot;    #TRAFFIC_LIGHT_DETECTION    local tl_detection_volume=&quot;apollo_tl_detection_volume_$&#123;USER&#125;&quot;    local tl_detection_image=&quot;$&#123;DOCKER_REPO&#125;:traffic_light-detection_caffe_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local tl_detection_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/traffic_light_detection/tl_detection_caffe&quot;    docker_restart_volume &quot;$&#123;tl_detection_volume&#125;&quot; &quot;$&#123;tl_detection_image&#125;&quot; &quot;$&#123;tl_detection_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;tl_detection_volume&#125;:$&#123;tl_detection_path&#125;&quot;    #TRAFFIC_LIGHT_RECOGNITION    local tl_horizontal_volume=&quot;apollo_tl_horizontal_volume_$&#123;USER&#125;&quot;    local tl_horizontal_image=&quot;$&#123;DOCKER_REPO&#125;:traffic_light-horizontal_caffe_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local tl_horizontal_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/traffic_light_recognition/horizontal_caffe&quot;    docker_restart_volume &quot;$&#123;tl_horizontal_volume&#125;&quot; &quot;$&#123;tl_horizontal_image&#125;&quot; &quot;$&#123;tl_horizontal_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;tl_horizontal_volume&#125;:$&#123;tl_horizontal_path&#125;&quot;    #TRAFFIC_LIGHT_RECOGNITION    local tl_quadrate_volume=&quot;apollo_tl_quadrate_volume_$&#123;USER&#125;&quot;    local tl_quadrate_image=&quot;$&#123;DOCKER_REPO&#125;:traffic_light-quadrate_caffe_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local tl_quadrate_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/traffic_light_recognition/quadrate_caffe&quot;    docker_restart_volume &quot;$&#123;tl_quadrate_volume&#125;&quot; &quot;$&#123;tl_quadrate_image&#125;&quot; &quot;$&#123;tl_quadrate_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;tl_quadrate_volume&#125;:$&#123;tl_quadrate_path&#125;&quot;    #TRAFFIC_LIGHT_RECOGNITION    local tl_recognition_volume=&quot;apollo_tl_recognition_volume_$&#123;USER&#125;&quot;    local tl_recognition_image=&quot;$&#123;DOCKER_REPO&#125;:traffic_light-recognition_caffe_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local tl_recognition_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/traffic_light_recognition/vertical_caffe&quot;    docker_restart_volume &quot;$&#123;tl_recognition_volume&#125;&quot; &quot;$&#123;tl_recognition_image&#125;&quot; &quot;$&#123;tl_recognition_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;tl_recognition_volume&#125;:$&#123;tl_recognition_path&#125;&quot;    #YOLO_OBSTACLE    local yolo_volume=&quot;yolo_obstacle_volume_$&#123;USER&#125;&quot;    local yolo_image=&quot;$&#123;DOCKER_REPO&#125;:yolo_obstacle_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local yolo_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/yolo_obstacle_detector/3d-r4-half_caffe&quot;    docker_restart_volume &quot;$&#123;yolo_volume&#125;&quot; &quot;$&#123;yolo_image&#125;&quot; &quot;$&#123;yolo_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;yolo_volume&#125;:$&#123;yolo_path&#125;&quot;    #CNNSEG128    local cnnseg_volume=&quot;cnnseg_volume_$&#123;USER&#125;&quot;    local cnnseg_image=&quot;$&#123;DOCKER_REPO&#125;:cnnseg_caffe_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local cnnseg_path=&quot;/apollo/modules/perception/production/data/perception/lidar/models/cnnseg/cnnseg128_caffe&quot;    docker_restart_volume &quot;$&#123;cnnseg_volume&#125;&quot; &quot;$&#123;cnnseg_image&#125;&quot; &quot;$&#123;cnnseg_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;cnnseg_volume&#125;:$&#123;cnnseg_path&#125;&quot;    #LANE_DETECTION    local lane_detection_volume=&quot;lane_detection_volume_$&#123;USER&#125;&quot;    local lane_detection_image=&quot;$&#123;DOCKER_REPO&#125;:lane_detection_model-$&#123;TARGET_ARCH&#125;-latest&quot;    local lane_detection_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/lane_detector/darkSCNN_caffe&quot;    docker_restart_volume &quot;$&#123;lane_detection_volume&#125;&quot; &quot;$&#123;lane_detection_image&#125;&quot; &quot;$&#123;lane_detection_path&#125;&quot;    volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;lane_detection_volume&#125;:$&#123;lane_detection_path&#125;&quot;     # SMOKE    if [[ &quot;$&#123;TARGET_ARCH&#125;&quot; == &quot;x86_64&quot; ]]; then        local smoke_volume=&quot;apollo_smoke_volume_$&#123;USER&#125;&quot;        local smoke_image=&quot;$&#123;DOCKER_REPO&#125;:smoke_volume-yolo_obstacle_detection_model-$&#123;TARGET_ARCH&#125;-latest&quot;        local smoke_path=&quot;/apollo/modules/perception/production/data/perception/camera/models/yolo_obstacle_detector/smoke_libtorch_model&quot;        docker_restart_volume &quot;$&#123;smoke_volume&#125;&quot; &quot;$&#123;smoke_image&#125;&quot; &quot;$&#123;smoke_path&#125;&quot;        volume_conf=&quot;$&#123;volume_conf&#125; --volume $&#123;smoke_volume&#125;:$&#123;smoke_path&#125;&quot;    fi    OTHER_VOLUMES_CONF=&quot;$&#123;volume_conf&#125;&quot;&#125;\n docker_restart_volume\nfunction docker_restart_volume() &#123;    local volume=&quot;$1&quot;    local image=&quot;$2&quot;    local path=&quot;$3&quot;    info &quot;Create volume $&#123;volume&#125; from image: $&#123;image&#125;&quot;    docker_pull &quot;$&#123;image&#125;&quot;    docker volume rm &quot;$&#123;volume&#125;&quot; &gt;/dev/null 2&gt;&amp;1    docker run -v &quot;$&#123;volume&#125;&quot;:&quot;$&#123;path&#125;&quot; --rm &quot;$&#123;image&#125;&quot; true&#125;\n2&gt;&amp;1的意思就是将标准错误重定向到标准输出。这里标准输出已经重定向到了/dev/null。那么标准错误也会输出到/dev/null。\n postrun_start_user\n# 配置容器内环境变量function postrun_start_user() &#123;    local container=&quot;$1&quot;    if [ &quot;$&#123;USER&#125;&quot; != &quot;root&quot; ]; then        docker exec -u root &quot;$&#123;container&#125;&quot; \\            bash -c &#x27;/apollo/scripts/docker_start_user.sh&#x27;    fi&#125;\ndocker exec是需要容器处于运行中且PID 1进程也处于运行中才能执行的操作。命令执行后会进入容器的默认工作目录，如果在Dockerfile中指定了工作目录，则会进入Dokcerfile指定的目录，如果命令中指定了工作目录-w则会进入该目录。\n\n-u：指定访问容器的用户名\n\n bash -c “cmd string”\n如果用-c那么bash会从第一个非选项参数后面的字符串中读取命令，如果字符串有多个空格，第一个空格前面的字符串是要执行的命令，也就是$0, 后面的是参数，即$1,  $2…\n\n-c第一个字符串一定要是命令路径，不能是文件名，如果把./atest前面的./去掉，那么就会报找不到命令\n命令文件必须要有可执行权限，即./atest的必须就有x属性\n\n docker_base.sh\nTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/../..&quot; &amp;&amp; pwd)&quot;source &quot;$&#123;TOP_DIR&#125;/scripts/apollo.bashrc&quot;unset TOP_DIRexport HOST_ARCH=&quot;$(uname -m)&quot;export HOST_OS=&quot;$(uname -s)&quot;GEO_REGISTRY=DOCKER_RUN_CMD=&quot;docker run&quot;USE_GPU_HOST=0export -f geo_specific_configexport -f determine_gpu_use_hostexport -f stop_all_apollo_containers remove_container_if_existsexport -f check_agreementexport USE_GPU_HOSTexport DOCKER_RUN_CMDexport GEO_REGISTRY\nunset为 shell 内建指令，用于删除已定义的shell变量（包括环境变量）和shell函数。unset命令不能够删除具有只读属性的shell变量和环境变量。\n\n-f：仅删除函数\n-v：仅删除变量\n\n apollo.bashrc\nAPOLLO_ROOT_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;APOLLO_IN_DOCKER=false# If inside docker containerif [ -f /.dockerenv ]; then  APOLLO_IN_DOCKER=true  APOLLO_ROOT_DIR=&quot;/apollo&quot;fiexport APOLLO_CONFIG_HOME=&quot;$&#123;APOLLO_CONFIG_HOME:=$HOME/.apollo&#125;&quot;export APOLLO_ROOT_DIR=&quot;$&#123;APOLLO_ROOT_DIR&#125;&quot;export APOLLO_IN_DOCKER=&quot;$&#123;APOLLO_IN_DOCKER&#125;&quot;export APOLLO_CACHE_DIR=&quot;$&#123;APOLLO_ROOT_DIR&#125;/.cache&quot;export APOLLO_SYSROOT_DIR=&quot;/opt/apollo/sysroot&quot;export TAB=&quot;    &quot; # 4 spacessource $&#123;APOLLO_ROOT_DIR&#125;/scripts/common.bashrc: $&#123;VERBOSE:=yes&#125;# 设置颜色BOLD=&#x27;\\033[1m&#x27;RED=&#x27;\\033[0;31m&#x27;BLUE=&#x27;\\033[0;34m&#x27;GREEN=&#x27;\\033[32m&#x27;WHITE=&#x27;\\033[34m&#x27;YELLOW=&#x27;\\033[33m&#x27;NO_COLOR=&#x27;\\033[0m&#x27;if $&#123;APOLLO_IN_DOCKER&#125; ; then    setup_gpu_supportfi\n setup_gpu_support\nfunction setup_gpu_support() &#123;  # 判断目录是否存在，若存在则返回true  if [ -e /usr/local/cuda/ ]; then    # 将 /usr/local/cuda/bin 增加到 PATH 里面    pathprepend /usr/local/cuda/bin  fi  determine_gpu_use_target  # TODO(infra): revisit this for CPU builds on GPU capable machines  local dev=&quot;cpu&quot;  # 判断是否要使用 GPU  if [ &quot;$&#123;USE_GPU_TARGET&#125;&quot; -gt 0 ]; then    dev=&quot;gpu&quot;  fi  local torch_path=&quot;/usr/local/libtorch_$&#123;dev&#125;/lib&quot;  # 判断目录是否存在  if [ -d &quot;$&#123;torch_path&#125;&quot; ]; then    # Runtime default: for ./bazel-bin/xxx/yyy to work as expected\t# 将目录加入到 LD_LIBRARY_PATH    pathprepend $&#123;torch_path&#125; LD_LIBRARY_PATH  fi&#125;\n pathprepend\n# 将路径$1增加到$2前面function pathprepend() &#123;  pathremove $1 $2  # 如果$2已被定义但是为空值，则 PATHVARIABLE 为 $&#123;PATH&#125;  local PATHVARIABLE=$&#123;2:-PATH&#125;  # 如果$&#123;!PATHVARIABLE&#125;不为空，  # 则 $PATHVARIABLE=&quot;$1:$&#123;!PATHVARIABLE&#125;&quot;，其中 : 是路径分割符，相当于一个字符，没有其他意思  export $PATHVARIABLE=&quot;$1$&#123;!PATHVARIABLE:+:$&#123;!PATHVARIABLE&#125;&#125;&quot;&#125;\n pathappend\n# 将路径$1增加到$2后面function pathappend() &#123;  pathremove $1 $2  # 如果$2已被定义但是为空值，则 PATHVARIABLE 为 $&#123;PATH&#125;  local PATHVARIABLE=$&#123;2:-PATH&#125;  # 如果$&#123;!PATHVARIABLE&#125;不为空，  # 则 $PATHVARIABLE=&quot;$&#123;!PATHVARIABLE&#125;:$1&quot;，其中 : 是路径分割符，相当于一个字符，没有其他意思  export $PATHVARIABLE=&quot;$&#123;!PATHVARIABLE:+$&#123;!PATHVARIABLE&#125;:&#125;$1&quot;&#125;\n 间接变量引用\naaa=123bbb=aaaecho $bbbecho $&#123;!bbb&#125;\n输出结果：\naaa123\n感叹号是可以引用间接变量的值\n pathremove\nfunction pathremove() &#123;  local IFS=&#x27;:&#x27; # 设定分割符  local NEWPATH  local DIR  local PATHVARIABLE=$&#123;2:-PATH&#125;  for DIR in $&#123;!PATHVARIABLE&#125;; do # 变量以分割符进行拆解，然后遍历循环    # 遍历循环，去掉指定路径    if [ &quot;$DIR&quot; != &quot;$1&quot; ]; then\t  # 第一次循环，因为 NEWPATH 声明了但为空，所以 NEWPATH=$DIR\t  # 此后循化，使用 NEWPATH 不为空，所以 NEWPATH=$NEWPATH:$DIR\t  # 增加了一个路径分割符      NEWPATH=$&#123;NEWPATH:+$NEWPATH:&#125;$DIR    fi  done  export $PATHVARIABLE=&quot;$NEWPATH&quot;&#125;\n determine_gpu_use_target\nfunction determine_gpu_use_target() &#123;  local arch=&quot;$(uname -m)&quot;  local use_gpu=0  if [[ &quot;$&#123;arch&#125;&quot; == &quot;aarch64&quot; ]]; then    if lsmod | grep -q nvgpu; then      if ldconfig -p | grep -q cudart; then        use_gpu=1      fi    fi  else ## x86_64 mode    # Check the existence of nvidia-smi    if [[ ! -x &quot;$(command -v nvidia-smi)&quot; ]]; then      warning &quot;nvidia-smi not found. CPU will be used.&quot;    elif [[ -z &quot;$(nvidia-smi)&quot; ]]; then      warning &quot;No GPU device found. CPU will be used.&quot;    else      use_gpu=1    fi  fi  export USE_GPU_TARGET=&quot;$&#123;use_gpu&#125;&quot;&#125;","categories":["算法","Apollo源码解读"]},{"title":"Apollo v8.0.0 代码解读 之 QpSplineReferenceLineSmoother","url":"/2023/01/29/Apollo%20v8.0.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BQpSplineReferenceLineSmoother/","content":"这篇文章对 Apollo v8.0.0 中的 QpSplineReferenceLineSmoother 模块进行了系统性的代码解读。文章详述了如何通过分段五次样条建模，将参考线平滑问题构建为二次规划（QP）问题，并借助 OSQP 求解器求解该优化模型。整体流程涵盖点信息提取、约束构建、目标函数设定及样条插值重建等关键步骤，为理解 Apollo 路径规划中的参考线优化提供了详实的参考。\n\n 二次规划（QP）样条路径QpSplineReferenceLineSmoother\n五次样条(quintic splines)，是汽车x和y位置的五次多项式函数。\n 算法原理\n\n\n将路径划分成n段，每一段路径用一个多项式来表示。\n\n\n每个样条段i都有沿着参考线的累加距离did_idi​。每段的路径默认用五次多项式表示：\nl=fi(s)=ai0+ai1⋅s+ai2⋅s2+ai3⋅s3+ai4⋅s4+ai5⋅s50≤s≤dil=f_i(s)=a_{i0} + a_{i1}\\cdot s + a_{i2}\\cdot s^2 + a_{i3}\\cdot s^3 + a_{i4}\\cdot s^4 + a_{i5}\\cdot s^5 \\\\\n0 \\leq s \\leq d_i\nl=fi​(s)=ai0​+ai1​⋅s+ai2​⋅s2+ai3​⋅s3+ai4​⋅s4+ai5​⋅s50≤s≤di​\n\n\n每个样条段优化的目标函数\ncost=∑i=1n[w1⋅∫0difi′2(s)ds+w2⋅∫0difi′′2(s)ds+w3⋅∫0difi′′′2(s)ds]cost=\\sum^n_{i=1}[w_1 \\cdot \\int^{d_i}_0f_i&#x27;^2(s)ds + w_2 \\cdot \\int^{d_i}_0f_i&#x27;&#x27;^2(s)ds + w_3 \\cdot \\int^{d_i}_0f_i&#x27;&#x27;&#x27;^2(s)ds]\ncost=i=1∑n​[w1​⋅∫0di​​fi′2​(s)ds+w2​⋅∫0di​​fi′′2​(s)ds+w3​⋅∫0di​​fi′′′2​(s)ds]\n\n\n将cost函数转换成为QP公式\nminimize12⋅xT⋅H⋅x+fT⋅xsubjectto:LB≤x≤UBAeqx=beqAx≥bminimize \\quad \\frac{1}{2}\\cdot x^T\\cdot \\textbf{H}\\cdot x+f^T\\cdot x \\\\\nsubject \\quad to: \\quad  LB\\leq x \\leq UB \\\\\nA_{eq}x=b_{eq} \\\\\nAx\\geq b\nminimize21​⋅xT⋅H⋅x+fT⋅xsubjectto:LB≤x≤UBAeq​x=beq​Ax≥b\n下面是将cost函数转换为QP公式:\nfi(s)=[1ss2s3s4s5]⋅[ai0ai1ai2ai3ai4ai5]fi′(s)=[012s3s24s35s4]⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅[012s3s24s35s4]f_i(s)=\\begin{bmatrix} 1 &amp; s &amp; s^2 &amp; s^3 &amp; s^4 &amp; s^5 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\nf_i&#x27;(s)=\\begin{bmatrix} 0 &amp; 1 &amp; 2s &amp; 3s^2 &amp; 4s^3 &amp; 5s^4 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n= \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 \\\\ 1 \\\\ 2s \\\\ 3s^2 \\\\ 4s^3 \\\\ 5s^4 \\end{bmatrix} \\\\\nfi​(s)=[1​s​s2​s3​s4​s5​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​fi′​(s)=[0​1​2s​3s2​4s3​5s4​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​012s3s24s35s4​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n则：\n矩阵乘法满足结合律：(A⋅B)⋅C=A⋅(B⋅C)(A\\cdot B)\\cdot C=A\\cdot(B\\cdot C)(A⋅B)⋅C=A⋅(B⋅C)\nfi′(s)2=[ai0ai1ai2ai3ai4ai5]⋅[012s3s24s35s4]⋅[012s3s24s35s4]⋅[ai0ai1ai2ai3ai4ai5]f_i&#x27;(s)^2 = \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 \\\\ 1 \\\\ 2s \\\\ 3s^2 \\\\ 4s^3 \\\\ 5s^4 \\end{bmatrix} \\cdot \\begin{bmatrix} 0 &amp; 1 &amp; 2s &amp; 3s^2 &amp; 4s^3 &amp; 5s^4 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\nfi′​(s)2=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​012s3s24s35s4​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅[0​1​2s​3s2​4s3​5s4​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n然后可以得到：\n∫0difi′(s)2ds=[ai0ai1ai2ai3ai4ai5]⋅∫0di[012s3s24s35s4]⋅[012s3s24s35s4]ds⋅[ai0ai1ai2ai3ai4ai5]\\int_0^{d_i}f_i&#x27;(s)^2ds = \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\int_0^{d_i} \\begin{bmatrix} 0 \\\\ 1 \\\\ 2s \\\\ 3s^2 \\\\ 4s^3 \\\\ 5s^4 \\end{bmatrix} \\cdot \\begin{bmatrix} 0 &amp; 1 &amp; 2s &amp; 3s^2 &amp; 4s^3 &amp; 5s^4 \\end{bmatrix} ds \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix}\n∫0di​​fi′​(s)2ds=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅∫0di​​⎣⎢⎢⎢⎢⎢⎢⎢⎡​012s3s24s35s4​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅[0​1​2s​3s2​4s3​5s4​]ds⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n从聚合函数中提取出常量得到：\n∫0difi′(s)2ds=[ai0ai1ai2ai3ai4ai5]⋅∫0di[000000012s3s24s35s402s4s26s38s410s503s26s39s412s515s604s38s412s516s620s705s410s515s620s725s8]ds⋅[ai0ai1ai2ai3ai4ai5]\\int_0^{d_i}f_i&#x27;(s)^2ds = \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\int_0^{d_i} \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 2s &amp; 3s^2 &amp; 4s^3 &amp; 5s^4 \\\\ 0 &amp; 2s &amp; 4s^2 &amp; 6s^3 &amp; 8s^4 &amp; 10s^5 \\\\ 0 &amp; 3s^2 &amp; 6s^3 &amp; 9s^4 &amp; 12s^5 &amp; 15s^6 \\\\ 0 &amp; 4s^3 &amp; 8s^4 &amp; 12s^5 &amp; 16s^6 &amp; 20s^7 \\\\ 0 &amp; 5s^4 &amp; 10s^5 &amp; 15s^6 &amp; 20s^7 &amp; 25s^8 \\end{bmatrix} ds \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix}\n∫0di​​fi′​(s)2ds=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅∫0di​​⎣⎢⎢⎢⎢⎢⎢⎢⎡​000000​012s3s24s35s4​02s4s26s38s410s5​03s26s39s412s515s6​04s38s412s516s620s7​05s410s515s620s725s8​⎦⎥⎥⎥⎥⎥⎥⎥⎤​ds⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n最后得到：\n∫0difi′(s)2ds=[ai0ai1ai2ai3ai4ai5]⋅[0000000didi2di3di4di50di243di364di485di5106di60di364di495di5126di6157di70di485di5126di6167di7208di80di5106di6157di7208di8259di9]⋅[ai0ai1ai2ai3ai4ai5]\\int_0^{d_i}f_i&#x27;(s)^2ds = \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \n\\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; d_i &amp; d_i^2 &amp; d_i^3 &amp; d_i^4 &amp; d_i^5 \\\\ \n0 &amp; d_i^2 &amp; \\frac{4}{3}d_i^3 &amp; \\frac{6}{4}d_i^4 &amp; \\frac{8}{5}d_i^5 &amp; \\frac{10}{6}d_i^6 \\\\ \n0 &amp; d_i^3 &amp; \\frac{6}{4}d_i^4 &amp; \\frac{9}{5}d_i^5 &amp; \\frac{12}{6}d_i^6 &amp;\\frac{15}{7}d_i^7 \\\\ \n0 &amp; d_i^4 &amp; \\frac{8}{5}d_i^5 &amp; \\frac{12}{6}d_i^6 &amp; \\frac{16}{7}d_i^7 &amp; \\frac{20}{8}d_i^8 \\\\ \n0 &amp; d_i^5 &amp; \\frac{10}{6}d_i^6 &amp; \\frac{15}{7}d_i^7 &amp; \\frac{20}{8}d_i^8 &amp; \\frac{25}{9}d_i^9 \\end{bmatrix} \n\\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix}\n∫0di​​fi′​(s)2ds=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​000000​0di​di2​di3​di4​di5​​0di2​34​di3​46​di4​58​di5​610​di6​​0di3​46​di4​59​di5​612​di6​715​di7​​0di4​58​di5​612​di6​716​di7​820​di8​​0di5​610​di6​715​di7​820​di8​925​di9​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n二阶样条插值的衍生开销：\nfi′′(s)=[0026s12s220s3]⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅[0026s12s220s3]f_i&#x27;&#x27;(s)=\\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s &amp; 12s^2 &amp; 20s^3 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n= \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 \\\\ 0 \\\\ 2 \\\\ 6s \\\\ 12s^2 \\\\ 20s^3 \\end{bmatrix}\nfi′′​(s)=[0​0​2​6s​12s2​20s3​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​0026s12s220s3​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n可得：\nfi′′(s)2=[ai0ai1ai2ai3ai4ai5]⋅[0026s12s220s3]⋅[0026s12s220s3]⋅[ai0ai1ai2ai3ai4ai5]f_i&#x27;&#x27;(s)^2=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 \\\\ 0 \\\\ 2 \\\\ 6s \\\\ 12s^2 \\\\ 20s^3 \\end{bmatrix} \\cdot\n\\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s &amp; 12s^2 &amp; 20s^3 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\nfi′′​(s)2=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​0026s12s220s3​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅[0​0​2​6s​12s2​20s3​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n然后得到：\n∫0difi′′(s)2ds=[ai0ai1ai2ai3ai4ai5]⋅∫0di[0026s12s220s3]⋅[0026s12s220s3]ds⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅∫0di[00000000000000412s24s240s30012s36s272s3120s40024s272s3144s4240s50040s3120s4240s5400s6]ds⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅[000000000000004di6di28di310di4006di212di3724di424di5008di3724di41445di540di60010di424di540di64007di7]⋅[ai0ai1ai2ai3ai4ai5]\\begin{aligned}\n\\int_0^{d_i} f_i&#x27;&#x27;(s)^2ds=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\int_0^{d_i}\\begin{bmatrix} 0 \\\\ 0 \\\\ 2 \\\\ 6s \\\\ 12s^2 \\\\ 20s^3 \\end{bmatrix} \\cdot\n\\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s &amp; 12s^2 &amp; 20s^3 \\end{bmatrix} ds \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\int_0^{d_i}\\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 4 &amp; 12s &amp; 24s^2 &amp; 40s^3 \\\\ 0 &amp; 0 &amp; 12s &amp; 36s^2 &amp; 72s^3 &amp; 120s^4 \\\\ 0 &amp; 0 &amp; 24s^2 &amp; 72s^3 &amp; 144s^4 &amp; 240s^5 \\\\ 0 &amp; 0 &amp; 40s^3 &amp; 120s^4 &amp; 240s^5 &amp; 400s^6 \\end{bmatrix} ds \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 4d_i &amp; 6d_i^2 &amp; 8d_i^3 &amp; 10d_i^4 \\\\ 0 &amp; 0 &amp; 6d_i^2 &amp; 12d_i^3 &amp; \\frac{72}{4}d_i^4 &amp; 24d_i^5 \\\\ 0 &amp; 0 &amp; 8d_i^3 &amp; \\frac{72}{4}d_i^4 &amp; \\frac{144}{5}d_i^5 &amp; 40d_i^6 \\\\ 0 &amp; 0 &amp; 10d_i^4 &amp; 24d_i^5 &amp; 40d_i^6 &amp; \\frac{400}{7}d_i^7 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n\\end{aligned}\n∫0di​​fi′′​(s)2ds=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅∫0di​​⎣⎢⎢⎢⎢⎢⎢⎢⎡​0026s12s220s3​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅[0​0​2​6s​12s2​20s3​]ds⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅∫0di​​⎣⎢⎢⎢⎢⎢⎢⎢⎡​000000​000000​00412s24s240s3​0012s36s272s3120s4​0024s272s3144s4240s5​0040s3120s4240s5400s6​⎦⎥⎥⎥⎥⎥⎥⎥⎤​ds⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​000000​000000​004di​6di2​8di3​10di4​​006di2​12di3​472​di4​24di5​​008di3​472​di4​5144​di5​40di6​​0010di4​24di5​40di6​7400​di7​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​​\n三阶样条插值的衍生开销：\nfi′′′(s)=[000624s60s2]⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅[000624s60s2]f_i&#x27;&#x27;&#x27;(s)=\\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 6 &amp; 24s &amp; 60s^2 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n= \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 6 \\\\ 24s \\\\ 60s^2 \\end{bmatrix}\nfi′′′​(s)=[0​0​0​6​24s​60s2​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​000624s60s2​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n可得：\nfi′′′(s)2=[ai0ai1ai2ai3ai4ai5]⋅[000624s60s2]⋅[000624s60s2]⋅[ai0ai1ai2ai3ai4ai5]f_i&#x27;&#x27;&#x27;(s)^2=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 6 \\\\ 24s \\\\ 60s^2 \\end{bmatrix} \\cdot \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 6 &amp; 24s &amp; 60s^2 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix}\nfi′′′​(s)2=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​000624s60s2​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅[0​0​0​6​24s​60s2​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n然后得到：\n∫0difi′′′(s)2ds=[ai0ai1ai2ai3ai4ai5]⋅∫0di[000624s60s2]⋅[000624s60s2]ds⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅∫0di[00000000000000000000036144s360s2000144s576s21440s3000360s21440s33600s4]ds⋅[ai0ai1ai2ai3ai4ai5]=[ai0ai1ai2ai3ai4ai5]⋅[00000000000000000000036di72di2120di300072di2192di3360di4000120di3360di4720di5]⋅[ai0ai1ai2ai3ai4ai5]\\begin{aligned}\n\\int_0^{d_i} f_i&#x27;&#x27;&#x27;(s)^2ds=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\int_0^{d_i} \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 6 \\\\ 24s \\\\ 60s^2 \\end{bmatrix} \\cdot \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 6 &amp; 24s &amp; 60s^2 \\end{bmatrix}ds \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n=\\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\int_0^{d_i} \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 36 &amp; 144s &amp; 360s^2 \\\\ 0 &amp; 0 &amp; 0 &amp; 144s &amp; 576s^2 &amp; 1440s^3 \\\\ 0 &amp; 0 &amp; 0 &amp; 360s^2 &amp; 1440s^3 &amp; 3600s^4 \\end{bmatrix} ds \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\\\\n= \\begin{bmatrix} a_{i0} &amp; a_{i1} &amp; a_{i2} &amp; a_{i3} &amp; a_{i4} &amp; a_{i5} \\end{bmatrix} \\cdot \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 36d_i &amp; 72d_i^2 &amp; 120d_i^3 \\\\ 0 &amp; 0 &amp; 0 &amp; 72d_i^2 &amp; 192d_i^3 &amp; 360d_i^4 \\\\ 0 &amp; 0 &amp; 0 &amp; 120d_i^3 &amp; 360d_i^4 &amp; 720d_i^5 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \n\\end{aligned}\n∫0di​​fi′′′​(s)2ds=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅∫0di​​⎣⎢⎢⎢⎢⎢⎢⎢⎡​000624s60s2​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅[0​0​0​6​24s​60s2​]ds⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅∫0di​​⎣⎢⎢⎢⎢⎢⎢⎢⎡​000000​000000​000000​00036144s360s2​000144s576s21440s3​000360s21440s33600s4​⎦⎥⎥⎥⎥⎥⎥⎥⎤​ds⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[ai0​​ai1​​ai2​​ai3​​ai4​​ai5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​000000​000000​000000​00036di​72di2​120di3​​00072di2​192di3​360di4​​000120di3​360di4​720di5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​​\n 初始点约束\n考虑第i段曲线，假设第i段第一个点为(s0,l0)(s_0,l_0)(s0​,l0​)，(s0,l0′)(s_0,l_0&#x27;)(s0​,l0′​)和(s0,l0′′)(s_0,l_0&#x27;&#x27;)(s0​,l0′′​)。\n其中l0l_0l0​，l0′l_0&#x27;l0′​，l0′′l_0&#x27;&#x27;l0′′​表示横向的偏移。将上述约束转换为QP约束等式，使用等式：\nAeqx=beqA_{eq}x=b_{eq}\nAeq​x=beq​\n推导过程：\nfi(s0)=[1s0s02s03s04s05]⋅[ai0ai1ai2ai3ai4ai5]=l0fi′(s0)=[012s03s024s035s04]⋅[ai0ai1ai2ai3ai4ai5]=l0′fi′′(s0)=[0026s012s0220s03]⋅[ai0ai1ai2ai3ai4ai5]=l0′′\\begin{aligned}\nf_i(s_0)=\\begin{bmatrix} 1 &amp; s_0 &amp; s_0^2 &amp; s_0^3 &amp; s_0^4 &amp; s_0^5 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} = l_0 \\\\\nf_i&#x27;(s_0)=\\begin{bmatrix} 0 &amp; 1 &amp; 2s_0 &amp; 3s_0^2 &amp; 4s_0^3 &amp; 5s_0^4 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} = l_0&#x27; \\\\\nf_i&#x27;&#x27;(s_0)=\\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s_0 &amp; 12s_0^2 &amp; 20s_0^3 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} = l_0&#x27;&#x27; \\\\\n\\end{aligned}\nfi​(s0​)=[1​s0​​s02​​s03​​s04​​s05​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=l0​fi′​(s0​)=[0​1​2s0​​3s02​​4s03​​5s04​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=l0′​fi′′​(s0​)=[0​0​2​6s0​​12s02​​20s03​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=l0′′​​\n 终点约束\n同起始点约束一样，终点(se,le)(s_e,l_e)(se​,le​)按照起始点的计算方法生成约束条件。\n将起始点和终点组合在一起，得到约束等式为：\n[1s0s02s03s04s05012s03s024s035s040026s012s0220s031sese2se3se4se5012se3se24se35se40026se12se220se3]⋅[ai0ai1ai2ai3ai4ai5]=[l0l0′l0′′lele′le′′]\\begin{bmatrix} 1 &amp; s_0 &amp; s_0^2 &amp; s_0^3 &amp; s_0^4 &amp; s_0^5 \\\\\n0 &amp; 1 &amp; 2s_0 &amp; 3s_0^2 &amp; 4s_0^3 &amp; 5s_0^4 \\\\\n0 &amp; 0 &amp; 2 &amp; 6s_0 &amp; 12s_0^2 &amp; 20s_0^3 \\\\\n1 &amp; s_e &amp; s_e^2 &amp; s_e^3 &amp; s_e^4 &amp; s_e^5 \\\\\n0 &amp; 1 &amp; 2s_e &amp; 3s_e^2 &amp; 4s_e^3 &amp; 5s_e^4 \\\\\n0 &amp; 0 &amp; 2 &amp; 6s_e &amp; 12s_e^2 &amp; 20s_e^3 \\\\\n\\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} = \\begin{bmatrix} l_0 \\\\ l_0&#x27; \\\\ l_0&#x27;&#x27; \\\\ l_e \\\\ l_e&#x27; \\\\ l_e&#x27;&#x27; \\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎡​100100​s0​10se​10​s02​2s0​2se2​2se​2​s03​3s02​6s0​se3​3se2​6se​​s04​4s03​12s02​se4​4se3​12se2​​s05​5s04​20s03​se5​5se4​20se3​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎡​l0​l0′​l0′′​le​le′​le′′​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n 平滑节点约束\n该约束的目的是使样条的节点更加平滑。假设两个段segkseg_ksegk​和segk+1seg_{k+1}segk+1​相互连接，且segkseg_ksegk​的累计值sss为sks_ksk​。计算约束的等式为：\nfk(sk)=fk+1(s0)f_k(s_k)=f_{k+1}(s_0)\nfk​(sk​)=fk+1​(s0​)\n推导过程：\n[1sksk2sk3sk4sk5]⋅[ak0ak1ak2ak3ak4ak5]=[1s0s02s03s04s05]⋅[ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]\\begin{bmatrix} 1 &amp; s_k &amp; s_k^2 &amp; s_k^3 &amp; s_k^4 &amp; s_k^5 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\end{bmatrix} = \\begin{bmatrix} 1 &amp; s_0 &amp; s_0^2 &amp; s_0^3 &amp; s_0^4 &amp; s_0^5 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5} \\end{bmatrix}\n[1​sk​​sk2​​sk3​​sk4​​sk5​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[1​s0​​s02​​s03​​s04​​s05​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n然后：\n[1sksk2sk3sk4sk5−1−s0−s02−s03−s04−s05]⋅[ak0ak1ak2ak3ak4ak5ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]=0\\begin{bmatrix} 1 &amp; s_k &amp; s_k^2 &amp; s_k^3 &amp; s_k^4 &amp; s_k^5 &amp; -1 &amp; -s_0 &amp; -s_0^2 &amp; -s_0^3 &amp; -s_0^4 &amp; -s_0^5\\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\\\ a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5}\\end{bmatrix} = 0\n[1​sk​​sk2​​sk3​​sk4​​sk5​​−1​−s0​​−s02​​−s03​​−s04​​−s05​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​=0\n同理可计算以下约束等式：\nfk′(sk)=fk+1′(s0)  ⟺  [012sk3sk24sk35sk4]⋅[ak0ak1ak2ak3ak4ak5]=[012s03s024s035s04]⋅[ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]  ⟺  [012sk3sk24sk35sk40−1−2s0−3s02−4s03−5s04]⋅[ak0ak1ak2ak3ak4ak5ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]=0\\begin{aligned}\nf_k&#x27;(s_k)=f_{k+1}&#x27;(s_0)  \\\\\n\\iff \\begin{bmatrix} 0 &amp; 1 &amp; 2s_k &amp; 3s_k^2 &amp; 4s_k^3 &amp; 5s_k^4 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\end{bmatrix} = \\begin{bmatrix} 0 &amp; 1 &amp; 2s_0 &amp; 3s_0^2 &amp; 4s_0^3 &amp; 5s_0^4 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5} \\end{bmatrix}  \\\\\n\\iff \\begin{bmatrix} 0 &amp; 1 &amp; 2s_k &amp; 3s_k^2 &amp; 4s_k^3 &amp; 5s_k^4 &amp; 0 &amp; -1 &amp; -2s_0 &amp; -3s_0^2 &amp; -4s_0^3 &amp; -5s_0^4\\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\\\ a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5}\\end{bmatrix} = 0\n\\end{aligned}\nfk′​(sk​)=fk+1′​(s0​)⟺[0​1​2sk​​3sk2​​4sk3​​5sk4​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[0​1​2s0​​3s02​​4s03​​5s04​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⟺[0​1​2sk​​3sk2​​4sk3​​5sk4​​0​−1​−2s0​​−3s02​​−4s03​​−5s04​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​=0​\nfk′′(sk)=fk+1′′(s0)  ⟺  [0026sk12sk220sk3]⋅[ak0ak1ak2ak3ak4ak5]=[0026s012s0220s03]⋅[ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]  ⟺  [0026sk12sk220sk300−2−6s0−12s02−20s03]⋅[ak0ak1ak2ak3ak4ak5ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]=0\\begin{aligned}\nf_k&#x27;&#x27;(s_k)=f_{k+1}&#x27;&#x27;(s_0)  \\\\\n\\iff \\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s_k &amp; 12s_k^2 &amp; 20s_k^3 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\end{bmatrix} = \\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s_0 &amp; 12s_0^2 &amp; 20s_0^3 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5} \\end{bmatrix}  \\\\\n\\iff \\begin{bmatrix} 0 &amp; 0 &amp; 2 &amp; 6s_k &amp; 12s_k^2 &amp; 20s_k^3 &amp; 0 &amp; 0 &amp; -2 &amp; -6s_0 &amp; -12s_0^2 &amp; -20s_0^3\\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\\\ a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5}\\end{bmatrix} = 0\n\\end{aligned}\nfk′′​(sk​)=fk+1′′​(s0​)⟺[0​0​2​6sk​​12sk2​​20sk3​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[0​0​2​6s0​​12s02​​20s03​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⟺[0​0​2​6sk​​12sk2​​20sk3​​0​0​−2​−6s0​​−12s02​​−20s03​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​=0​\nfk′′′(sk)=fk+1′′′(s0)  ⟺  [000624sk60sk2]⋅[ak0ak1ak2ak3ak4ak5]=[000624s060s02]⋅[ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]  ⟺  [000624sk60sk2000−6−24s0−60s02]⋅[ak0ak1ak2ak3ak4ak5ak+1,0ak+1,1ak+1,2ak+1,3ak+1,4ak+1,5]=0\\begin{aligned}\nf_k&#x27;&#x27;&#x27;(s_k)=f_{k+1}&#x27;&#x27;&#x27;(s_0)  \\\\\n\\iff \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 6 &amp; 24s_k &amp; 60s_k^2 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\end{bmatrix} = \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 6 &amp; 24s_0 &amp; 60s_0^2 \\end{bmatrix} \\cdot \\begin{bmatrix} a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5} \\end{bmatrix}  \\\\\n\\iff \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 6 &amp; 24s_k &amp; 60s_k^2 &amp; 0 &amp; 0 &amp; 0 &amp; -6 &amp; -24s_0 &amp; -60s_0^2\\end{bmatrix} \\cdot \\begin{bmatrix} a_{k0} \\\\ a_{k1} \\\\ a_{k2} \\\\ a_{k3} \\\\ a_{k4} \\\\ a_{k5} \\\\ a_{k+1,0} \\\\ a_{k+1,1} \\\\ a_{k+1,2} \\\\ a_{k+1,3} \\\\ a_{k+1,4} \\\\ a_{k+1,5}\\end{bmatrix} = 0\n\\end{aligned}\nfk′′′​(sk​)=fk+1′′′​(s0​)⟺[0​0​0​6​24sk​​60sk2​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=[0​0​0​6​24s0​​60s02​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​⟺[0​0​0​6​24sk​​60sk2​​0​0​0​−6​−24s0​​−60s02​​]⋅⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​ak0​ak1​ak2​ak3​ak4​ak5​ak+1,0​ak+1,1​ak+1,2​ak+1,3​ak+1,4​ak+1,5​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​=0​\n 点采样边界约束\n在第i段路径上均匀的取样m个点，检查这些点上的障碍物边界。将这些约束转换为QP约束不等式，使用不等式：\nAx≥bAx\\ge b\nAx≥b\n首先基于道路宽度和周围的障碍物为找到点(sj,lj)(s_j,l_j)(sj​,lj​)的下边界llb,jl_{lb,j}llb,j​，且j∈[0,m]j\\in[0,m]j∈[0,m]。计算约束的不等式为：\n[1s0s02s03s04s051s1s12s13s14s151s2s22s23s24s25..................1smsm2sm3sm4sm5]⋅[ai0ai1ai2ai3ai4ai5]≥[llb,0llb,1llb,2...llb,m]\\begin{bmatrix} 1 &amp; s_0 &amp; s_0^2 &amp; s_0^3 &amp; s_0^4 &amp; s_0^5 \\\\\n1 &amp; s_1 &amp; s_1^2 &amp; s_1^3 &amp; s_1^4 &amp; s_1^5 \\\\\n1 &amp; s_2 &amp; s_2^2 &amp; s_2^3 &amp; s_2^4 &amp; s_2^5 \\\\\n... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\\\\n1 &amp; s_m &amp; s_m^2 &amp; s_m^3 &amp; s_m^4 &amp; s_m^5 \\\\\n\\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\ge \\begin{bmatrix} l_{lb,0} \\\\ l_{lb,1} \\\\ l_{lb,2} \\\\ ... \\\\ l_{lb,m} \\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎡​111...1​s0​s1​s2​...sm​​s02​s12​s22​...sm2​​s03​s13​s23​...sm3​​s04​s14​s24​...sm4​​s05​s15​s25​...sm5​​⎦⎥⎥⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​≥⎣⎢⎢⎢⎢⎢⎡​llb,0​llb,1​llb,2​...llb,m​​⎦⎥⎥⎥⎥⎥⎤​\n同样地，对上边界lub,jl_{ub,j}lub,j​，计算约束的不等式为：\n[−1−s0−s02−s03−s04−s05−1−s1−s12−s13−s14−s15−1−s2−s22−s23−s24−s25..................−1−sm−sm2−sm3−sm4−sm5]⋅[ai0ai1ai2ai3ai4ai5]≥−1⋅[lub,0lub,1lub,2...lub,m]\\begin{bmatrix} -1 &amp; -s_0 &amp; -s_0^2 &amp; -s_0^3 &amp; -s_0^4 &amp; -s_0^5 \\\\\n-1 &amp; -s_1 &amp; -s_1^2 &amp; -s_1^3 &amp; -s_1^4 &amp; -s_1^5 \\\\\n-1 &amp; -s_2 &amp; -s_2^2 &amp; -s_2^3 &amp; -s_2^4 &amp; -s_2^5 \\\\\n... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\\\\n-1 &amp; -s_m &amp; -s_m^2 &amp; -s_m^3 &amp; -s_m^4 &amp; -s_m^5 \\\\\n\\end{bmatrix} \\cdot \\begin{bmatrix} a_{i0} \\\\ a_{i1} \\\\ a_{i2} \\\\ a_{i3} \\\\ a_{i4} \\\\ a_{i5} \\end{bmatrix} \\ge -1 \\cdot\\begin{bmatrix} l_{ub,0} \\\\ l_{ub,1} \\\\ l_{ub,2} \\\\ ... \\\\ l_{ub,m} \\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎡​−1−1−1...−1​−s0​−s1​−s2​...−sm​​−s02​−s12​−s22​...−sm2​​−s03​−s13​−s23​...−sm3​​−s04​−s14​−s24​...−sm4​​−s05​−s15​−s25​...−sm5​​⎦⎥⎥⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎢⎢⎢⎢⎡​ai0​ai1​ai2​ai3​ai4​ai5​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​≥−1⋅⎣⎢⎢⎢⎢⎢⎡​lub,0​lub,1​lub,2​...lub,m​​⎦⎥⎥⎥⎥⎥⎤​\n\n\n 代码实现\ngraph LRop1_1(PolynomialXd)op1_2(Spline2dSeg)op1(Spline2d)op2_1(SplineSegKernel)op2(Spline2dKernel)op3_1(AffineConstraint)op3(Spline2dConstraint)op4(Spline2dSolver)op5(OsqpSpline2dSolver)op1_1--&gt;op1_2--每一维度都是五次多项式--&gt;op1-.二维样条曲线.-&gt;op4op2_1--计算每一段的P矩阵--&gt;op2-.OP问题的P矩阵.-&gt;op4op3_1--约束基本类--&gt;op3-..-&gt;op4op4--&gt;op5\nstruct AnchorPoint &#123;  common::PathPoint path_point;  double lateral_bound = 0.0;  double longitudinal_bound = 0.0;  // enforce smoother to strictly follow this reference point  bool enforced = false;&#125;;\n平滑之前，需要先设定锚点。\n QpSplineReferenceLineSmoother::SetAnchorPoints()\nvoid QpSplineReferenceLineSmoother::SetAnchorPoints(    const std::vector&lt;AnchorPoint&gt;&amp; anchor_points) &#123;  CHECK_GE(anchor_points.size(), 2);  anchor_points_ = anchor_points;&#125;\n QpSplineReferenceLineSmoother::Smooth()\n使用样条平滑时，首先需要将输入标准化。\nbool QpSplineReferenceLineSmoother::Smooth(    const ReferenceLine&amp; raw_reference_line,    ReferenceLine* const smoothed_reference_line) &#123;  // 主要就是清空类变量t_knots_  Clear();  const double kEpsilon = 1e-6;  // 确定样条数量  if (!Sampling()) &#123;    AERROR &lt;&lt; &quot;Fail to sample reference line smoother points!&quot;;    return false;  &#125;  // 重置样条解决器  spline_solver_-&gt;Reset(t_knots_, config_.qp_spline().spline_order());  // 增加限制条件  if (!AddConstraint()) &#123;    AERROR &lt;&lt; &quot;Add constraint for spline smoother failed&quot;;    return false;  &#125;  if (!AddKernel()) &#123;    AERROR &lt;&lt; &quot;Add kernel for spline smoother failed.&quot;;    return false;  &#125;  auto start = std::chrono::system_clock::now();  if (!Solve()) &#123;    AERROR &lt;&lt; &quot;Solve spline smoother problem failed&quot;;  &#125;  auto end = std::chrono::system_clock::now();  std::chrono::duration&lt;double&gt; diff = end - start;  ADEBUG &lt;&lt; &quot;QpSplineReferenceLineSmoother solve time is &quot;         &lt;&lt; diff.count() * 1000.0 &lt;&lt; &quot; ms.&quot;;  // mapping spline to reference line point  const double start_t = t_knots_.front();  const double end_t = t_knots_.back();  const double resolution =      (end_t - start_t) / (config_.num_of_total_points() - 1);  double t = start_t;  std::vector&lt;ReferencePoint&gt; ref_points;  const auto&amp; spline = spline_solver_-&gt;spline();  for (std::uint32_t i = 0; i &lt; config_.num_of_total_points() &amp;&amp; t &lt; end_t;       ++i, t += resolution) &#123;    const double heading =        std::atan2(spline.DerivativeY(t), spline.DerivativeX(t));    const double kappa = CurveMath::ComputeCurvature(        spline.DerivativeX(t), spline.SecondDerivativeX(t),        spline.DerivativeY(t), spline.SecondDerivativeY(t));    const double dkappa = CurveMath::ComputeCurvatureDerivative(        spline.DerivativeX(t), spline.SecondDerivativeX(t),        spline.ThirdDerivativeX(t), spline.DerivativeY(t),        spline.SecondDerivativeY(t), spline.ThirdDerivativeY(t));    std::pair&lt;double, double&gt; xy = spline(t);    xy.first += ref_x_;    xy.second += ref_y_;    common::SLPoint ref_sl_point;    if (!raw_reference_line.XYToSL(&#123;xy.first, xy.second&#125;, &amp;ref_sl_point)) &#123;      return false;    &#125;    if (ref_sl_point.s() &lt; -kEpsilon ||        ref_sl_point.s() &gt; raw_reference_line.Length()) &#123;      continue;    &#125;    ref_sl_point.set_s(std::max(ref_sl_point.s(), 0.0));    ReferencePoint rlp = raw_reference_line.GetReferencePoint(ref_sl_point.s());    auto new_lane_waypoints = rlp.lane_waypoints();    for (auto&amp; lane_waypoint : new_lane_waypoints) &#123;      lane_waypoint.l = ref_sl_point.l();    &#125;    ref_points.emplace_back(ReferencePoint(        hdmap::MapPathPoint(common::math::Vec2d(xy.first, xy.second), heading,                            new_lane_waypoints),        kappa, dkappa));  &#125;  ReferencePoint::RemoveDuplicates(&amp;ref_points);  if (ref_points.size() &lt; 2) &#123;    AERROR &lt;&lt; &quot;Fail to generate smoothed reference line.&quot;;    return false;  &#125;  *smoothed_reference_line = ReferenceLine(ref_points);  return true;&#125;\n QpSplineReferenceLineSmoother::Clear()\nvoid QpSplineReferenceLineSmoother::Clear() &#123; t_knots_.clear(); &#125;\n QpSplineReferenceLineSmoother::Sampling()\nbool QpSplineReferenceLineSmoother::Sampling() &#123;  // 计算整段路径的长度，锚点第一点是路径的起点，锚点最后一个点是路径的终点  const double length = anchor_points_.back().path_point.s() -                        anchor_points_.front().path_point.s();  // 计算样条的条数，总长除设定单条长度向上取整，最后一条长度小于等于设定单条长度  uint32_t num_spline =      std::max(1u, static_cast&lt;uint32_t&gt;(                       length / config_.qp_spline().max_spline_length() + 0.5));  // t_knots_表示样条衔接点数，值为样条数(num_spline)加1  for (std::uint32_t i = 0; i &lt;= num_spline; ++i) &#123;    t_knots_.push_back(i * 1.0);  &#125;  // normalize point xy  // 用于标准化，以第一点锚点为基准  ref_x_ = anchor_points_.front().path_point.x();  ref_y_ = anchor_points_.front().path_point.y();  return true;&#125;\n QpSplineReferenceLineSmoother::AddConstraint()\nbool QpSplineReferenceLineSmoother::AddConstraint() &#123;  // Add x, y boundary constraint  std::vector&lt;double&gt; headings;  std::vector&lt;double&gt; longitudinal_bound;  std::vector&lt;double&gt; lateral_bound;  std::vector&lt;common::math::Vec2d&gt; xy_points;  for (const auto&amp; point : anchor_points_) &#123;    const auto&amp; path_point = point.path_point;    headings.push_back(path_point.theta());    longitudinal_bound.push_back(point.longitudinal_bound);    lateral_bound.push_back(point.lateral_bound);    // 基于第一个锚点标准化，也就是第一点坐标为(0,0)    xy_points.emplace_back(path_point.x() - ref_x_, path_point.y() - ref_y_);  &#125;  // 计算长度比例，标准化的基础  const double scale = (anchor_points_.back().path_point.s() -                        anchor_points_.front().path_point.s()) /                       (t_knots_.back() - t_knots_.front());  std::vector&lt;double&gt; evaluated_t;  for (const auto&amp; point : anchor_points_) &#123;    // 将锚点的s值单位标准化    evaluated_t.emplace_back(point.path_point.s() / scale);  &#125;  // 增加样条优化的约束条件  auto* spline_constraint = spline_solver_-&gt;mutable_constraint();  // all points (x, y) should not deviate anchor points by a bounding box  if (!spline_constraint-&gt;Add2dBoundary(evaluated_t, headings, xy_points,                                        longitudinal_bound, lateral_bound)) &#123;    AERROR &lt;&lt; &quot;Add 2d boundary constraint failed.&quot;;    return false;  &#125;  // the heading of the first point should be identical to the anchor point.  if (FLAGS_enable_reference_line_stitching &amp;&amp;      !spline_constraint-&gt;AddPointAngleConstraint(evaluated_t.front(),                                                  headings.front())) &#123;    AERROR &lt;&lt; &quot;Add 2d point angle constraint failed.&quot;;    return false;  &#125;  // all spline should be connected smoothly to the second order derivative.  if (!spline_constraint-&gt;AddSecondDerivativeSmoothConstraint()) &#123;    AERROR &lt;&lt; &quot;Add jointness constraint failed.&quot;;    return false;  &#125;  return true;&#125;\n Spline2dConstraint::Add2dBoundary()\nbool Spline2dConstraint::Add2dBoundary(    // t_coord锚点标准后的单位长度    // angle锚点的航向角    const std::vector&lt;double&gt;&amp; t_coord, const std::vector&lt;double&gt;&amp; angle,    // ref_point锚点的坐标值    const std::vector&lt;Vec2d&gt;&amp; ref_point,    // 每个锚点的横纵向边界    const std::vector&lt;double&gt;&amp; longitudinal_bound,    const std::vector&lt;double&gt;&amp; lateral_bound) &#123;  // 输入参数检查是否合理，数量都是为锚点的数量  if (t_coord.size() != angle.size() || angle.size() != ref_point.size() ||      ref_point.size() != lateral_bound.size() ||      lateral_bound.size() != longitudinal_bound.size()) &#123;    return false;  &#125;  Eigen::MatrixXd affine_inequality =      Eigen::MatrixXd::Zero(4 * t_coord.size(), total_param_);  Eigen::MatrixXd affine_boundary =      Eigen::MatrixXd::Zero(4 * t_coord.size(), 1);  for (uint32_t i = 0; i &lt; t_coord.size(); ++i) &#123;    const double d_lateral = SignDistance(ref_point[i], angle[i]);    const double d_longitudinal =        SignDistance(ref_point[i], angle[i] - M_PI / 2.0);    const uint32_t index = FindIndex(t_coord[i]);    const double rel_t = t_coord[i] - t_knots_[index];    const uint32_t index_offset = 2 * index * (spline_order_ + 1);    std::vector&lt;double&gt; longi_coef = AffineCoef(angle[i], rel_t);    std::vector&lt;double&gt; longitudinal_coef =        AffineCoef(angle[i] - M_PI / 2, rel_t);    for (uint32_t j = 0; j &lt; 2 * (spline_order_ + 1); ++j) &#123;      // upper longi      affine_inequality(4 * i, index_offset + j) = longi_coef[j];      // lower longi      affine_inequality(4 * i + 1, index_offset + j) = -longi_coef[j];      // upper longitudinal      affine_inequality(4 * i + 2, index_offset + j) = longitudinal_coef[j];      // lower longitudinal      affine_inequality(4 * i + 3, index_offset + j) = -longitudinal_coef[j];    &#125;    affine_boundary(4 * i, 0) = d_lateral - lateral_bound[i];    affine_boundary(4 * i + 1, 0) = -d_lateral - lateral_bound[i];    affine_boundary(4 * i + 2, 0) = d_longitudinal - longitudinal_bound[i];    affine_boundary(4 * i + 3, 0) = -d_longitudinal - longitudinal_bound[i];  &#125;  return AddInequalityConstraint(affine_inequality, affine_boundary);&#125;\n Spline2dConstraint::SignDistance()\ndouble Spline2dConstraint::SignDistance(const Vec2d&amp; xy_point,                                        const double angle) const &#123;  return common::math::InnerProd(      xy_point.x(), xy_point.y(),      -common::math::sin(common::math::Angle16::from_rad(angle)),      common::math::cos(common::math::Angle16::from_rad(angle)));&#125;\n","categories":["算法","Apollo源码解读"]},{"title":"Apollo v8.0.0 代码解读 之 SpiralReferenceLineSmoother","url":"/2023/01/29/Apollo%20v8.0.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8BSpiralReferenceLineSmoother/","content":"这篇文章深入解析了 Apollo v8.0.0 中的 SpiralReferenceLineSmoother 模块的原理与实现。它通过五次多项式螺旋曲线对参考线进行平滑优化，结合 Ipopt 求解器，将参考线平滑问题转化为一个包含位置、航向角、曲率及其导数的非线性优化问题，并详细介绍了目标函数、变量约束和代码接口的具体实现逻辑。该模块在路径规划中起到关键的参考线优化作用。\n\n 螺旋曲线平滑器Spiral Smoother\nbool SpiralReferenceLineSmoother::Smooth(std::vector&lt;Eigen::Vector2d&gt; point2d,                                         std::vector&lt;double&gt;* ptr_theta,                                         std::vector&lt;double&gt;* ptr_kappa,                                         std::vector&lt;double&gt;* ptr_dkappa,                                         std::vector&lt;double&gt;* ptr_s,                                         std::vector&lt;double&gt;* ptr_x,                                         std::vector&lt;double&gt;* ptr_y) const &#123;  CHECK_GT(point2d.size(), 1);  // 定义一个新的求解器实例  SpiralProblemInterface* ptop = new SpiralProblemInterface(point2d);  // 设置距离平滑点距离锚点的最大偏移距离  ptop-&gt;set_default_max_point_deviation(config_.spiral().max_deviation());  if (fixed_start_point_) &#123;    // 设置起始点参数，apollo中起始点位置不能被平滑，因此均设置为固定点    ptop-&gt;set_start_point(fixed_start_x_, fixed_start_y_, fixed_start_theta_,                          fixed_start_kappa_, fixed_start_dkappa_);  &#125;  // 设置终止点参数  ptop-&gt;set_end_point_position(fixed_end_x_, fixed_end_y_);  // 设置曲线弧长权重  ptop-&gt;set_element_weight_curve_length(config_.spiral().weight_curve_length());  // 设置曲率权重  ptop-&gt;set_element_weight_kappa(config_.spiral().weight_kappa());  // 设置曲率变化率权重  ptop-&gt;set_element_weight_dkappa(config_.spiral().weight_dkappa());  Ipopt::SmartPtr&lt;Ipopt::TNLP&gt; problem = ptop;  // Create an instance of the IpoptApplication  Ipopt::SmartPtr&lt;Ipopt::IpoptApplication&gt; app = IpoptApplicationFactory();  // 设置求解器参数  // 通过拟牛顿法近似黑塞矩阵  app-&gt;Options()-&gt;SetStringValue(&quot;hessian_approximation&quot;, &quot;limited-memory&quot;);  app-&gt;Options()-&gt;SetIntegerValue(&quot;print_level&quot;, 0);  // 最大迭代次数,达到迭代次数后，算法停止优化  app-&gt;Options()-&gt;SetIntegerValue(&quot;max_iter&quot;, config_.spiral().max_iteration());  // 可接受的迭代次数，当算法没达到收敛误差tol，但是达到可接受的收敛误差acceptable_tol acceptable_iter次数以后，算法也会成功退出  app-&gt;Options()-&gt;SetIntegerValue(&quot;acceptable_iter&quot;,                                  config_.spiral().opt_acceptable_iteration());  // 收敛误差，满足该误差下算法即停止优化，返回成功求解  app-&gt;Options()-&gt;SetNumericValue(&quot;tol&quot;, config_.spiral().opt_tol());  // 可接受的收敛误差  app-&gt;Options()-&gt;SetNumericValue(&quot;acceptable_tol&quot;,                                  config_.spiral().opt_acceptable_tol());  // 初始化求解器参数  Ipopt::ApplicationReturnStatus status = app-&gt;Initialize();  if (status != Ipopt::Solve_Succeeded) &#123;    ADEBUG &lt;&lt; &quot;*** Error during initialization!&quot;;    return false;  &#125;  // 优化计算  status = app-&gt;OptimizeTNLP(problem);  if (status == Ipopt::Solve_Succeeded ||      status == Ipopt::Solved_To_Acceptable_Level) &#123;    // Retrieve some statistics about the solve    Ipopt::Index iter_count = app-&gt;Statistics()-&gt;IterationCount();    ADEBUG &lt;&lt; &quot;*** The problem solved in &quot; &lt;&lt; iter_count &lt;&lt; &quot; iterations!&quot;;    Ipopt::Number final_obj = app-&gt;Statistics()-&gt;FinalObjective();    ADEBUG &lt;&lt; &quot;*** The final value of the objective function is &quot; &lt;&lt; final_obj           &lt;&lt; &#x27;.&#x27;;  &#125; else &#123;    ADEBUG &lt;&lt; &quot;Return status: &quot; &lt;&lt; int(status);  &#125;  ptop-&gt;get_optimization_results(ptr_theta, ptr_kappa, ptr_dkappa, ptr_s, ptr_x,                                 ptr_y);  return status == Ipopt::Solve_Succeeded ||         status == Ipopt::Solved_To_Acceptable_Level;&#125;\n 算法原理\n参考spiral平滑原理。\n多项式螺旋线(polynomial spiral)，由相对于弧长的多项式曲率函数给出。\n\n假设有nnn点Pi(xi,yi)∣1,2,3,…,nP_i(x_i,y_i)|1,2,3,…,nPi​(xi​,yi​)∣1,2,3,…,n把参考线分成n−1n−1n−1段线段，这里仍然采用分段的思想，用n−1n−1n−1段多项式螺旋线描述整个参考线。\n使用弧长的五次多项式函数表示螺旋线上点的切线方向，参数化公式如下：\nθ(s)=a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f\\theta(s) = a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f\nθ(s)=a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f\nθ(s)\\theta(s)θ(s)表示螺旋线上点的切线方向，sss表示沿螺旋线弧长。根据微分几何原理，给定函数θ(s),s∈[0,sg]θ(s),s\\in[0,s_g]θ(s),s∈[0,sg​]可以完全确定一条曲线形状（sgs_gsg​为曲线上起点到终点之间的长度）。\n对于任意s∈[0,sg]s\\in [0,s_g]s∈[0,sg​]，任意点坐标x(s),y(s)x(s),y(s)x(s),y(s)表示如下：\nx(s)=xi+∫0scos(θ(s))dsy(s)=yi+∫0ssin(θ(s))ds\\begin{aligned}\nx(s) = x_i + \\int_0^s cos(\\theta(s))ds \\\\\ny(s) = y_i + \\int_0^s sin(\\theta(s))ds\n\\end{aligned}\nx(s)=xi​+∫0s​cos(θ(s))dsy(s)=yi​+∫0s​sin(θ(s))ds​\n每一段五次多项式螺旋线系数a,b,c,d,e,fa,b,c,d,e,fa,b,c,d,e,f可以由螺旋线两个端点状态相关的777个参数决定，并且满足以下约束，以第iii段为例：\nθi(0)=θiθi(Δsi)=θi+1θi′(0)=θi′θi′(Δsi)=θi+1′θi′′(0)=θi′′θi′′(Δsi)=θi+1′′\\begin{aligned}\n\\theta_i(0) = \\theta_i \\qquad \\theta_i(\\Delta s_i) = \\theta_{i+1} \\\\\n\\theta_i&#x27;(0) = \\theta_i&#x27; \\qquad \\theta_i&#x27;(\\Delta s_i) = \\theta_{i+1}&#x27; \\\\\n\\theta_i&#x27;&#x27;(0) = \\theta_i&#x27;&#x27; \\qquad \\theta_i&#x27;&#x27;(\\Delta s_i) = \\theta_{i+1}&#x27;&#x27; \\\\\n\\end{aligned}\nθi​(0)=θi​θi​(Δsi​)=θi+1​θi′​(0)=θi′​θi′​(Δsi​)=θi+1′​θi′′​(0)=θi′′​θi′′​(Δsi​)=θi+1′′​​\n其中：θi\\theta_iθi​: 起点方向，θi′\\theta&#x27;_iθi′​: 起点曲率，θi′′\\theta&#x27;&#x27;_iθi′′​: 起点曲率导数，θi+1\\theta_{i+1}θi+1​: 终点方向，θi+1′\\theta_{i+1}&#x27;θi+1′​: 终点曲率，θi+1′′\\theta_{i+1}&#x27;&#x27;θi+1′′​: 终点曲率导数，Δsi\\Delta s_iΔsi​: 两点之间曲线长度。\n由以上777个参数就可以确定一条θ(s)\\theta(s)θ(s)的五次多项式，进而确定一条五次多项式螺旋线。使用多段连接的方式去描述原始参考线，保证由多段螺旋线连接曲线的平滑性能，那么第iii段与第i+1i+1i+1段螺旋线连接处位置(xi+1,yi+1)(x_{i+1},y_{i+1})(xi+1​,yi+1​)、方向(θi+1)(\\theta_{i+1})(θi+1​)、曲率(θi+1′)(\\theta&#x27;_{i+1})(θi+1′​)、曲率变化率(θi+1′′)(\\theta_{i+1}&#x27;&#x27;)(θi+1′′​)需要保持一致，也就是满足如下约束：\nxi+1=xi+∫0Δsicos(θ(s))dsyi+1=yi+∫0Δsisin(θ(s))dsθi+1=θi(Δsi)θi+1′=θi′(Δsi)θi+1′′=θi′′(Δsi)\\begin{aligned}\nx_{i+1} = x_i + \\int_0^{\\Delta s_i} cos(\\theta(s))ds \\\\\ny_{i+1} = y_i + \\int_0^{\\Delta s_i} sin(\\theta(s))ds \\\\\n\\theta_{i+1} = \\theta_i(\\Delta s_i) \\\\\n\\theta&#x27;_{i+1} = \\theta&#x27;_i(\\Delta s_i) \\\\\n\\theta&#x27;&#x27;_{i+1} = \\theta&#x27;&#x27;_i(\\Delta s_i) \\\\\n\\end{aligned}\nxi+1​=xi​+∫0Δsi​​cos(θ(s))dsyi+1​=yi​+∫0Δsi​​sin(θ(s))dsθi+1​=θi​(Δsi​)θi+1′​=θi′​(Δsi​)θi+1′′​=θi′′​(Δsi​)​\n平滑的过程的本质是一个优化问题，其目的就是找到一系列最优的多项式，使得多项式螺旋线段更平滑的描述原始参考线。对于这种多项式参数化，定义的多项式系数ai,bi,ci,di,ei,fia_i,b_i,c_i,d_i,e_i,f_iai​,bi​,ci​,di​,ei​,fi​都根据sss的大小表现出不同的灵敏度。例如，如果sss很大，在相同微小变化情况下，aaa比fff导致θ(s)\\theta(s)θ(s)的变化要大得多，且该问题随着所需路径长度sss增加而恶化，尤其在计算雅可比矩阵及其逆矩阵时容易出现较大的数值误差。为了提高数值精度，结合整个优化问题以及上面确定一条五次多项式螺旋线的过程，这里选择θ,θ′,θ′′,x,y,Δs\\theta,\\theta&#x27;,\\theta&#x27;&#x27;,x,y,\\Delta sθ,θ′,θ′′,x,y,Δs作为此优化问题变量。\n 优化变量：\nθ,θ′,θ′′,x,y,Δs\\theta,\\theta&#x27;,\\theta&#x27;&#x27;,x,y,\\Delta s\nθ,θ′,θ′′,x,y,Δs\n 目标函数：\ncost=wlength∑i=1n−1Δsi+wkappa∑i=1n−1∑j=0m−1(θi′(sj))2+wdkappa∑i=1n−1∑j=0m−1(θi′′(sj))2cost = w_{length}\\sum_{i=1}^{n-1}\\Delta s_i + w_{kappa}\\sum_{i=1}^{n-1}\\sum_{j=0}^{m-1}(\\theta&#x27;_i(s_j))^2 + w_{dkappa}\\sum_{i=1}^{n-1}\\sum_{j=0}^{m-1}(\\theta&#x27;&#x27;_i(s_j))^2\ncost=wlength​i=1∑n−1​Δsi​+wkappa​i=1∑n−1​j=0∑m−1​(θi′​(sj​))2+wdkappa​i=1∑n−1​j=0∑m−1​(θi′′​(sj​))2\n其中：第一项代表曲线长度，第二项代表曲率，第三项代表曲率变化率。参数nnn代表n−1n−1n−1段螺旋线的端点，mmm表示每一段螺旋线上等间距点数，如下图所示：\n\n 约束条件：\n\n\n优化变量约束\n起点\n{θ1=θstartθ1′=κstartθ1′′=dκstartx1=xstarty1=ystart\\begin{cases}\n\\theta_1 = \\theta_{start} \\\\\n\\theta&#x27;_1 = \\kappa_{start} \\\\\n\\theta&#x27;&#x27;_1 = d\\kappa_{start} \\\\\nx_1 = x_{start} \\\\\ny_1 = y_{start} \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​θ1​=θstart​θ1′​=κstart​θ1′′​=dκstart​x1​=xstart​y1​=ystart​​\n中间点\n{θrelative−π2≤θi≤θrelative+π2−0.25≤κi≤0.25−0.05≤dκi≤0.05xˉi−ri≤xi≤xˉi+riyˉi−ri≤yi≤yˉi+ri∣pi,pi+1∣−2ri≤Δsi≤∣pi,pi+1∣∗π2\\begin{cases}\n\\theta_{relative} - \\frac{\\pi}{2} \\leq \\theta_i \\leq \\theta_{relative} + \\frac{\\pi}{2} \\\\\n-0.25 \\leq \\kappa_i \\leq 0.25 \\\\\n-0.05 \\leq d\\kappa_i \\leq 0.05 \\\\\n\\bar{x}_i -r_i \\leq x_i \\leq \\bar{x}_i  + r_i \\\\\n\\bar{y}_i  -r_i \\leq y_i \\leq \\bar{y}_i  + r_i \\\\\n|p_i,p_{i+1}| - 2r_i \\leq \\Delta s_i \\leq |p_i,p_{i+1}| * \\frac{\\pi}{2}\n\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​θrelative​−2π​≤θi​≤θrelative​+2π​−0.25≤κi​≤0.25−0.05≤dκi​≤0.05xˉi​−ri​≤xi​≤xˉi​+ri​yˉ​i​−ri​≤yi​≤yˉ​i​+ri​∣pi​,pi+1​∣−2ri​≤Δsi​≤∣pi​,pi+1​∣∗2π​​\n终点\n{θn=θendθn′=κendθn′′=dκendxn=xendyn=yend\\begin{cases}\n\\theta_n = \\theta_{end} \\\\\n\\theta&#x27;_n = \\kappa_{end} \\\\\n\\theta&#x27;&#x27;_n = d\\kappa_{end} \\\\\nx_n = x_{end} \\\\\ny_n = y_{end} \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​θn​=θend​θn′​=κend​θn′′​=dκend​xn​=xend​yn​=yend​​\n\n\n连接点等式约束\n{xi+1=xi+∫0Δsicos(θ(s))dsi=1,2,...,n−1yi+1=yi+∫0Δsisin(θ(s))dsi=1,2,...,n−1θi+1=θi(Δsi)θi+1′=θi′(Δsi)θi+1′′=θi′′(Δsi)\\begin{cases}\nx_{i+1} = x_i + \\int_0^{\\Delta s_i} cos(\\theta(s))ds &amp; i=1,2,...,n-1 \\\\\ny_{i+1} = y_i + \\int_0^{\\Delta s_i} sin(\\theta(s))ds &amp; i=1,2,...,n-1 \\\\\n\\theta_{i+1} = \\theta_i(\\Delta s_i) \\\\\n\\theta&#x27;_{i+1} = \\theta&#x27;_i(\\Delta s_i) \\\\\n\\theta&#x27;&#x27;_{i+1} = \\theta&#x27;&#x27;_i(\\Delta s_i) \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​xi+1​=xi​+∫0Δsi​​cos(θ(s))dsyi+1​=yi​+∫0Δsi​​sin(θ(s))dsθi+1​=θi​(Δsi​)θi+1′​=θi′​(Δsi​)θi+1′′​=θi′′​(Δsi​)​i=1,2,...,n−1i=1,2,...,n−1\n\n\n位置平移约束\n(xi−xˉi)2+(yi−yˉi)2≤ri2i=1,2,...,n\\begin{aligned}\n(x_i - \\bar{x}_i )^2 + (y_i - \\bar{y}_i )^2 \\leq r_i^2 \\\\\ni = 1,2,...,n\n\\end{aligned}\n(xi​−xˉi​)2+(yi​−yˉ​i​)2≤ri2​i=1,2,...,n​\n其中(xˉi,yˉi)(\\bar{x}_i,\\bar{y}_i)(xˉi​,yˉ​i​)代表原始参考点的位置坐标，rir_iri​代表原始参考点可以平移的距离，如下图所示：\n\n\n\n 代码实现\nIpopt是一个基于内点法求解非线性优化问题的函数库，对于Ipopt优化，需要在接口类中实现一些待求解的函数，需要提供的信息包括：\n\n\n定义问题规模Problem dimensions\n\n\n\n变量的数量number of variables\n约束的数量number of constraints\n\n\n\n定义问题边界Problem bounds\n\n\n\n优化变量的边界variable bounds\n约束的边界constraint bounds\n\n\n\n定义初始值Initial starting point\n\n\n\n优化变量的初始值Initial values for the primal x variables\n\n\n\n定义问题函数Evaluation of Problem Functions\n\n\n\n\n定义目标函数Objective functionf(x)f(x)f(x)\n\n\n定义目标函数导数Gradient of the objective∇f(x)\\nabla f(x)∇f(x)\n目标函数分别对各个优化变量求偏导\n\n\n定义约束函数Constraint function valuesg(x)g(x)g(x)\n\n\n定义约束函数雅克比矩阵Jacobian of the constraints∇g(x)T\\nabla g(x)^T∇g(x)T\n每个约束函数分别对各个优化变量求偏导\n\n\n定义拉格朗日函数的黑塞矩阵Hessian of the Lagrangian functionσf∇2f(x)+∑i=1mλi∇2gi(x)\\sigma_f\\nabla^2f(x)+\\sum_{i=1}^m\\lambda _i \\nabla^2g_i(x)σf​∇2f(x)+∑i=1m​λi​∇2gi​(x)\n\n\n\n\n SpiralProblemInterface::SpiralProblemInterface()\nSpiralProblemInterface::SpiralProblemInterface(    std::vector&lt;Eigen::Vector2d&gt; points)    : init_points_(std::move(points)) &#123;  // 参考点点数  num_of_points_ = static_cast&lt;int&gt;(init_points_.size());  CHECK_GT(num_of_points_, 1);  // 计算点之间的距离  point_distances_.reserve(num_of_points_ - 1);  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    point_distances_.push_back((init_points_[i + 1] - init_points_[i]).norm());  &#125;  // 首先根据两个点计算朝向  std::vector&lt;double&gt; normalized_theta;  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    Eigen::Vector2d v = init_points_[i + 1] - init_points_[i];    double theta = std::atan2(v.y(), v.x());    normalized_theta.push_back(theta);  &#125;  normalized_theta.push_back(normalized_theta.back());  // 然后计算每个点的参考朝向  relative_theta_.push_back(normalized_theta.front());  for (int i = 1; i &lt; num_of_points_; ++i) &#123;    // 注意，先计算每一段与该段起点的朝向偏差并标准化    double theta_diff =        common::math::AngleDiff(relative_theta_.back(), normalized_theta[i]);    // 然后再加上该段起点的朝向，注意，没有标准化，作为该段终点的朝向    relative_theta_.push_back(relative_theta_.back() + theta_diff);  &#125;  // 螺旋曲线的段数  piecewise_paths_.resize(num_of_points_ - 1);&#125;\n SpiralProblemInterface::get_nlp_info()\n优化变量θ,θ′,θ′′,x,y,Δs\\theta,\\theta&#x27;,\\theta&#x27;&#x27;,x,y,\\Delta sθ,θ′,θ′′,x,y,Δs\n循序是θ0,θ0′,θ0′′,x0,y0,θ1,θ1′,θ1′′,x1,y1,...,θn−1,θn−1′,θn−1′′,xn−1,yn−1,Δs1,Δs2,...,Δsn−1\\theta_0,\\theta&#x27;_0,\\theta&#x27;&#x27;_0,x_0,y_0,\\theta_1,\\theta&#x27;_1,\\theta&#x27;&#x27;_1,x_1,y_1,...,\\theta_{n-1},\\theta&#x27;_{n-1},\\theta&#x27;&#x27;_{n-1},x_{n-1},y_{n-1},\\Delta s_1,\\Delta s_2,...,\\Delta s_{n-1}θ0​,θ0′​,θ0′′​,x0​,y0​,θ1​,θ1′​,θ1′′​,x1​,y1​,...,θn−1​,θn−1′​,θn−1′′​,xn−1​,yn−1​,Δs1​,Δs2​,...,Δsn−1​\nipopt和osqp区别之一，ipopt中优化变量边界是独立于约束之外。\nbool SpiralProblemInterface::get_nlp_info(int&amp; n, int&amp; m, int&amp; nnz_jac_g,                                          int&amp; nnz_h_lag,                                          IndexStyleEnum&amp; index_style) &#123;  // number of variables  // 计算优化变量的数目，一个点五个优化变量，以及一个两点之间的弧长变量  n = num_of_points_ * 5 + num_of_points_ - 1;  num_of_variables_ = n;  // number of constraints  // b. positional equality constraints;  // totally 2 * (num_of_points - 1) considering x and y separately  // x,y的等式约束，x(i+i) = x(i) + 积分项  m = (num_of_points_ - 1) * 2;  // a. positional movements; totally num_of_points  m += num_of_points_; // 位置平移约束  num_of_constraints_ = m;  // number of nonzero constraint jacobian.  nnz_jac_g = (num_of_points_ - 1) * 2 * 9 + num_of_points_ * 2;  // number of nonzero hessian and lagrangian.  nnz_h_lag = 0;  index_style = IndexStyleEnum::C_STYLE;  return true;&#125;\n SpiralProblemInterface::get_bounds_info()\nbool SpiralProblemInterface::get_bounds_info(int n, double* x_l, double* x_u,                                             int m, double* g_l, double* g_u) &#123;  CHECK_EQ(n, num_of_variables_);  CHECK_EQ(m, num_of_constraints_);  // variables 优化变量边界  // a. for theta, kappa, dkappa, x, y  for (int i = 0; i &lt; num_of_points_; ++i) &#123;    int index = i * 5;    double theta_lower = 0.0;    double theta_upper = 0.0;    double kappa_lower = 0.0;    double kappa_upper = 0.0;    double dkappa_lower = 0.0;    double dkappa_upper = 0.0;    double x_lower = 0.0;    double x_upper = 0.0;    double y_lower = 0.0;    double y_upper = 0.0;    if (i == 0 &amp;&amp; has_fixed_start_point_) &#123;      // 设定起点约束      theta_lower = start_theta_;      theta_upper = start_theta_;      kappa_lower = start_kappa_;      kappa_upper = start_kappa_;      dkappa_lower = start_dkappa_;      dkappa_upper = start_dkappa_;      x_lower = start_x_;      x_upper = start_x_;      y_lower = start_y_;      y_upper = start_y_;    &#125; else if (i + 1 == num_of_points_ &amp;&amp; has_fixed_end_point_) &#123;      // 设定终点约束      theta_lower = end_theta_;      theta_upper = end_theta_;      kappa_lower = end_kappa_;      kappa_upper = end_kappa_;      dkappa_lower = end_dkappa_;      dkappa_upper = end_dkappa_;      x_lower = end_x_;      x_upper = end_x_;      y_lower = end_y_;      y_upper = end_y_;    &#125; else if (i + 1 == num_of_points_ &amp;&amp; has_fixed_end_point_position_) &#123;      // 中间点约束，固定x,y      theta_lower = relative_theta_[i] - M_PI * 0.2;      theta_upper = relative_theta_[i] + M_PI * 0.2;      kappa_lower = -0.25;      kappa_upper = 0.25;      dkappa_lower = -0.02;      dkappa_upper = 0.02;      x_lower = end_x_;      x_upper = end_x_;      y_lower = end_y_;      y_upper = end_y_;    &#125; else &#123;      // 中间点约束，不固定x,y      theta_lower = relative_theta_[i] - M_PI * 0.2;      theta_upper = relative_theta_[i] + M_PI * 0.2;      kappa_lower = -0.25;      kappa_upper = 0.25;      dkappa_lower = -0.02;      dkappa_upper = 0.02;      x_lower = init_points_[i].x() - default_max_point_deviation_;      x_upper = init_points_[i].x() + default_max_point_deviation_;      y_lower = init_points_[i].y() - default_max_point_deviation_;      y_upper = init_points_[i].y() + default_max_point_deviation_;    &#125;    // theta    x_l[index] = theta_lower;    x_u[index] = theta_upper;    // kappa    x_l[index + 1] = kappa_lower;    x_u[index + 1] = kappa_upper;    // dkappa    x_l[index + 2] = dkappa_lower;    x_u[index + 2] = dkappa_upper;    // x    x_l[index + 3] = x_lower;    x_u[index + 3] = x_upper;    // y    x_l[index + 4] = y_lower;    x_u[index + 4] = y_upper;  &#125;  // b. for delta_s  // default_max_point_deviation_点的最大偏移量  int variable_offset = num_of_points_ * 5;  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    x_l[variable_offset + i] =        point_distances_[i] - 2.0 * default_max_point_deviation_;    x_u[variable_offset + i] = point_distances_[i] * M_PI * 0.5;  &#125;  // constraints 等式、不等式约束  // a. positional equality constraints xy等式约束  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    // for x    g_l[i * 2] = 0.0;    g_u[i * 2] = 0.0;    // for y    g_l[i * 2 + 1] = 0.0;    g_u[i * 2 + 1] = 0.0;  &#125;  // b. positional deviation constraints  位置偏离不等式约束  int constraint_offset = 2 * (num_of_points_ - 1);  for (int i = 0; i &lt; num_of_points_; ++i) &#123;    g_l[constraint_offset + i] = 0.0;    g_u[constraint_offset + i] =        default_max_point_deviation_ * default_max_point_deviation_;  &#125;  return true;&#125;\n SpiralProblemInterface::get_starting_point()\nbool SpiralProblemInterface::get_starting_point(int n, bool init_x, double* x,\t\t\t\t\t\t\t\t\t\t\t\tbool init_z, double* z_L,                                                double* z_U, int m,                                                bool init_lambda,                                                double* lambda) &#123;  if (n != num_of_variables_) &#123;    AERROR &lt;&lt; &quot;n != num_of_variables_&quot;;    return false;  &#125;  if (!init_x) &#123;    AERROR &lt;&lt; &quot;init_x is false.&quot;;    return false;  &#125;  if (init_z) &#123;    AERROR &lt;&lt; &quot;init_z is true.&quot;;    return false;  &#125;  if (init_lambda) &#123;    AERROR &lt;&lt; &quot;init_lambda is true.&quot;;    return false;  &#125;  // 初始化优化初始解  for (int i = 0; i &lt; num_of_points_; ++i) &#123;    int index = i * 5;    x[index] = relative_theta_[i]; // theta    x[index + 1] = 0.0; // kappa    x[index + 2] = 0.0; // dkappa    x[index + 3] = init_points_[i].x(); // x    x[index + 4] = init_points_[i].y(); // y  &#125;  int variable_offset = num_of_points_ * 5;  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    double delta_theta = relative_theta_[i + 1] - relative_theta_[i];    // ？？？为什么这么计算delta_s？？？    x[variable_offset + i] = point_distances_[i] / std::cos(0.5 * delta_theta); // delta_s  &#125;  // 非第一个点的曲率计算，用弧长/角度变化：  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    double delta_theta = relative_theta_[i + 1] - relative_theta_[i];    // 初始化kappa值，delta_theta / delta_s    x[(i + 1) * 5 + 1] = delta_theta / x[variable_offset + i];  &#125;  x[1] = x[6];  if (has_fixed_start_point_) &#123;    // 如果有固定开始点，则固定第一个点的theta, kappa, dkappa    x[0] = start_theta_;    x[1] = start_kappa_;    x[2] = start_dkappa_;  &#125;  return true;&#125;\n SpiralProblemInterface::eval_f()\ncost=f=wlength∑i=1n−1Δsi+wkappa∑i=1n−1∑j=0m−1(θi′(sj))2+wdkappa∑i=1n−1∑j=0m−1(θi′′(sj))2cost = f = w_{length}\\sum_{i=1}^{n-1}\\Delta s_i + w_{kappa}\\sum_{i=1}^{n-1}\\sum_{j=0}^{m-1}(\\theta&#x27;_i(s_j))^2 + w_{dkappa}\\sum_{i=1}^{n-1}\\sum_{j=0}^{m-1}(\\theta&#x27;&#x27;_i(s_j))^2\ncost=f=wlength​i=1∑n−1​Δsi​+wkappa​i=1∑n−1​j=0∑m−1​(θi′​(sj​))2+wdkappa​i=1∑n−1​j=0∑m−1​(θi′′​(sj​))2\nbool SpiralProblemInterface::eval_f(int n, const double* x, bool new_x,                                    double&amp; obj_value) &#123;  CHECK_EQ(n, num_of_variables_);  if (new_x) &#123;    // new_x会反馈出求解器是否更新了优化变量，如果更新了优化变量，我们就要重新更新螺旋曲线函数，利用新的优化变量构造螺旋曲线    update_piecewise_spiral_paths(x, n);  &#125;  obj_value = 0.0;  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    // num_of_points_ 表示 n    const auto&amp; spiral_curve = piecewise_paths_[i];    double delta_s = spiral_curve.ParamLength();    // 计算目标函数delta_s项    obj_value += delta_s * weight_curve_length_;    for (int j = 0; j &lt; num_of_internal_points_; ++j) &#123;      // num_of_internal_points_ 表示 m      double ratio =          static_cast&lt;double&gt;(j) / static_cast&lt;double&gt;(num_of_internal_points_);      double s = ratio * delta_s;      // 计算目标函数kappa项      double kappa = spiral_curve.Evaluate(1, s);      obj_value += kappa * kappa * weight_kappa_;      // 计算目标函数dkappa项      double dkappa = spiral_curve.Evaluate(2, s);      obj_value += dkappa * dkappa * weight_dkappa_;    &#125;  &#125;  return true;&#125;\n SpiralProblemInterface::update_piecewise_spiral_paths()\nvoid SpiralProblemInterface::update_piecewise_spiral_paths(const double* x,                                                           const int n) &#123;  int variable_offset = num_of_points_ * 5;  // 有n-1条五次螺旋曲线  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    int index0 = i * 5;    int index1 = (i + 1) * 5;    std::array&lt;double, 3&gt; x0 = &#123;x[index0], x[index0 + 1], x[index0 + 2]&#125;;    std::array&lt;double, 3&gt; x1 = &#123;x[index1], x[index1 + 1], x[index1 + 2]&#125;;    double delta_s = x[variable_offset + i];    // 每两个点之间构造成五次螺旋曲线    piecewise_paths_[i] =        std::move(QuinticSpiralPathWithDerivation&lt;N&gt;(x0, x1, delta_s));  &#125;&#125;\n SpiralProblemInterface::eval_grad_f()\ngradf=(∂f∂θ0∂f∂θ0′∂f∂θ0′′∂f∂x0∂f∂y0∂f∂θ1∂f∂θ1′∂f∂θ1′′∂f∂x1∂f∂y1⋮∂f∂θn−1∂f∂θn−1′∂f∂θn−1′′∂f∂xn−1∂f∂yn−1∂f∂Δs1∂f∂Δs2⋮∂f∂Δsn−1)(5n+n−1)×1grad_f = \\begin{pmatrix}\n\\frac{\\partial f}{\\partial \\theta_0} \\\\\n\\frac{\\partial f}{\\partial \\theta&#x27;_0} \\\\\n\\frac{\\partial f}{\\partial \\theta&#x27;&#x27;_0} \\\\\n\\frac{\\partial f}{\\partial x_0} \\\\\n\\frac{\\partial f}{\\partial y_0} \\\\\n\\frac{\\partial f}{\\partial \\theta_1} \\\\\n\\frac{\\partial f}{\\partial \\theta&#x27;_1} \\\\\n\\frac{\\partial f}{\\partial \\theta&#x27;&#x27;_1} \\\\\n\\frac{\\partial f}{\\partial x_1} \\\\\n\\frac{\\partial f}{\\partial y_1} \\\\\n\\vdots \\\\\n\\frac{\\partial f}{\\partial \\theta_{n-1}} \\\\\n\\frac{\\partial f}{\\partial \\theta&#x27;_{n-1}} \\\\\n\\frac{\\partial f}{\\partial \\theta&#x27;&#x27;_{n-1}} \\\\\n\\frac{\\partial f}{\\partial x_{n-1}} \\\\\n\\frac{\\partial f}{\\partial y_{n-1}} \\\\\n\\frac{\\partial f}{\\partial \\Delta s_1} \\\\\n\\frac{\\partial f}{\\partial \\Delta s_2} \\\\\n\\vdots \\\\\n\\frac{\\partial f}{\\partial \\Delta s_{n-1}} \\\\\n\\end{pmatrix}_{(5n+n-1) \\times 1}\ngradf​=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​∂θ0​∂f​∂θ0′​∂f​∂θ0′′​∂f​∂x0​∂f​∂y0​∂f​∂θ1​∂f​∂θ1′​∂f​∂θ1′′​∂f​∂x1​∂f​∂y1​∂f​⋮∂θn−1​∂f​∂θn−1′​∂f​∂θn−1′′​∂f​∂xn−1​∂f​∂yn−1​∂f​∂Δs1​∂f​∂Δs2​∂f​⋮∂Δsn−1​∂f​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(5n+n−1)×1​\nfff对Δsi\\Delta s_iΔsi​的求偏导，因为Δsi\\Delta s_iΔsi​只和第iii个螺旋曲线有关，和其他曲线无关，所以目标函数的其他曲线相关量求导可以直接忽略掉：\n注意：\n∂(θi′(sj))2∂Δsi=∂(θi′(sj))2∂θi′(sj)⋅∂θi′(sj)∂Δsi=2⋅θi′(sj)⋅∂θi′(sj)∂Δsi\\frac{\\partial(\\theta&#x27;_i(s_j))^2}{\\partial \\Delta s_i} \n=\\frac{\\partial(\\theta&#x27;_i(s_j))^2}{\\partial\\theta&#x27;_i(s_j)} \\cdot\n\\frac{\\partial\\theta&#x27;_i(s_j)}{\\partial \\Delta s_i} \n= 2\\cdot \\theta&#x27;_i(s_j) \\cdot \\frac{\\partial\\theta&#x27;_i(s_j)}{\\partial \\Delta s_i}\n∂Δsi​∂(θi′​(sj​))2​=∂θi′​(sj​)∂(θi′​(sj​))2​⋅∂Δsi​∂θi′​(sj​)​=2⋅θi′​(sj​)⋅∂Δsi​∂θi′​(sj​)​\n∂f∂Δsi=wlength+wkappa∑j=0m−1∂(θi′(sj))2∂Δsi+wdkappa∑j=0m−1∂(θi′′(sj))2∂Δsi=wlength+wkappa∑j=0m−12⋅θi′(sj)⋅∂θi′(sj)∂Δsi+wdkappa∑j=0m−12⋅θi′′(sj)⋅∂θi′′(sj)∂Δsi\\begin{aligned}\n\\frac{\\partial f}{\\partial \\Delta s_i} = w_{length} + \nw_{kappa}\\sum_{j=0}^{m-1}\\frac{\\partial(\\theta&#x27;_i(s_j))^2}{\\partial \\Delta s_i} + \nw_{dkappa}\\sum_{j=0}^{m-1}\\frac{\\partial(\\theta&#x27;&#x27;_i(s_j))^2}{\\partial \\Delta s_i} \\\\\n= w_{length} + \nw_{kappa}\\sum_{j=0}^{m-1}\\frac{2\\cdot \\theta&#x27;_i(s_j) \\cdot \\partial\\theta&#x27;_i(s_j)}{\\partial \\Delta s_i} + \nw_{dkappa}\\sum_{j=0}^{m-1}\\frac{2\\cdot \\theta&#x27;&#x27;_i(s_j) \\cdot \\partial\\theta&#x27;&#x27;_i(s_j)}{\\partial \\Delta s_i}\n\\end{aligned}\n∂Δsi​∂f​=wlength​+wkappa​j=0∑m−1​∂Δsi​∂(θi′​(sj​))2​+wdkappa​j=0∑m−1​∂Δsi​∂(θi′′​(sj​))2​=wlength​+wkappa​j=0∑m−1​∂Δsi​2⋅θi′​(sj​)⋅∂θi′​(sj​)​+wdkappa​j=0∑m−1​∂Δsi​2⋅θi′′​(sj​)⋅∂θi′′​(sj​)​​\nfff对θi\\theta_iθi​求偏导，θi\\theta_iθi​是曲线端点的方向角，和第i−1i-1i−1个曲线和第iii个曲线都有关系，所以它的偏导函数为：\n∂f∂θi=wkappa∑j=0m−12⋅θi′(sj)⋅∂θi′(sj)∂θi+wkappa∑j=0m−12⋅θi+1′(sj)⋅∂θi+1′(sj)∂θi+wdkappa∑j=0m−12⋅θi′′(sj)⋅∂θi′′(sj)∂θi+wdkappa∑j=0m−12⋅θi+1′′(sj)⋅∂θi+1′′(sj)∂θi\\frac{\\partial f}{\\partial \\theta_i} = \nw_{kappa}\\sum_{j=0}^{m-1}\\frac{2\\cdot \\theta&#x27;_i(s_j) \\cdot \\partial\\theta&#x27;_i(s_j)}{\\partial \\theta_i} + \nw_{kappa}\\sum_{j=0}^{m-1}\\frac{2\\cdot \\theta&#x27;_{i+1}(s_j) \\cdot \\partial\\theta&#x27;_{i+1}(s_j)}{\\partial \\theta_i} + \nw_{dkappa}\\sum_{j=0}^{m-1}\\frac{2\\cdot \\theta&#x27;&#x27;_i(s_j) \\cdot \\partial\\theta&#x27;&#x27;_i(s_j)}{\\partial \\theta_i} +\nw_{dkappa}\\sum_{j=0}^{m-1}\\frac{2\\cdot \\theta&#x27;&#x27;_{i+1}(s_j) \\cdot \\partial\\theta&#x27;&#x27;_{i+1}(s_j)}{\\partial \\theta_i}\n∂θi​∂f​=wkappa​j=0∑m−1​∂θi​2⋅θi′​(sj​)⋅∂θi′​(sj​)​+wkappa​j=0∑m−1​∂θi​2⋅θi+1′​(sj​)⋅∂θi+1′​(sj​)​+wdkappa​j=0∑m−1​∂θi​2⋅θi′′​(sj​)⋅∂θi′′​(sj​)​+wdkappa​j=0∑m−1​∂θi​2⋅θi+1′′​(sj​)⋅∂θi+1′′​(sj​)​\n同理可以推出fff对θi′,θi′′\\theta&#x27;_i,\\theta&#x27;&#x27;_iθi′​,θi′′​的偏导数。对x,yx,yx,y的偏导数都为0.00.00.0。\nbool SpiralProblemInterface::eval_grad_f(int n, const double* x, bool new_x,                                         double* grad_f) &#123;  CHECK_EQ(n, num_of_variables_);  std::fill(grad_f, grad_f + n, 0.0); // 给f的导数初始化，赋值为0  if (new_x) &#123;    // new_x会反馈出求解器是否更新了优化变量，如果更新了优化变量，我们就要重新更新螺旋曲线函数，利用新的优化变量构造螺旋曲线    update_piecewise_spiral_paths(x, n);  &#125;  int variable_offset = num_of_points_ * 5;  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    int index0 = i * 5;    int index1 = (i + 1) * 5;    auto&amp; spiral_curve = piecewise_paths_[i];    double delta_s = spiral_curve.ParamLength();    grad_f[variable_offset + i] += weight_curve_length_ * 1.0;    for (int j = 0; j &lt; num_of_internal_points_; ++j) &#123;      // num_of_internal_points_ 为 m      double ratio =          static_cast&lt;double&gt;(j) / static_cast&lt;double&gt;(num_of_internal_points_);      double s = ratio * delta_s;      double kappa = spiral_curve.Evaluate(1, s);      grad_f[index0] += weight_kappa_ * 2.0 * kappa *                        spiral_curve.DeriveKappaDerivative(                            THETA0, j, num_of_internal_points_);      grad_f[index0 + 1] += weight_kappa_ * 2.0 * kappa *                            spiral_curve.DeriveKappaDerivative(                                KAPPA0, j, num_of_internal_points_);      grad_f[index0 + 2] += weight_kappa_ * 2.0 * kappa *                            spiral_curve.DeriveKappaDerivative(                                DKAPPA0, j, num_of_internal_points_);      grad_f[index1] += weight_kappa_ * 2.0 * kappa *                        spiral_curve.DeriveKappaDerivative(                            THETA1, j, num_of_internal_points_);      grad_f[index1 + 1] += weight_kappa_ * 2.0 * kappa *                            spiral_curve.DeriveKappaDerivative(                                KAPPA1, j, num_of_internal_points_);      grad_f[index1 + 2] += weight_kappa_ * 2.0 * kappa *                            spiral_curve.DeriveKappaDerivative(                                DKAPPA1, j, num_of_internal_points_);      grad_f[variable_offset + i] += weight_kappa_ * 2.0 * kappa *                                     spiral_curve.DeriveKappaDerivative(                                         DELTA_S, j, num_of_internal_points_);      double dkappa = spiral_curve.Evaluate(2, s);      grad_f[index0] += weight_dkappa_ * 2.0 * dkappa *                        spiral_curve.DeriveDKappaDerivative(                            THETA0, j, num_of_internal_points_);      grad_f[index0 + 1] += weight_dkappa_ * 2.0 * dkappa *                            spiral_curve.DeriveDKappaDerivative(                                KAPPA0, j, num_of_internal_points_);      grad_f[index0 + 2] += weight_dkappa_ * 2.0 * dkappa *                            spiral_curve.DeriveDKappaDerivative(                                DKAPPA0, j, num_of_internal_points_);      grad_f[index1] += weight_dkappa_ * 2.0 * dkappa *                        spiral_curve.DeriveDKappaDerivative(                            THETA1, j, num_of_internal_points_);      grad_f[index1 + 1] += weight_dkappa_ * 2.0 * dkappa *                            spiral_curve.DeriveDKappaDerivative(                                KAPPA1, j, num_of_internal_points_);      grad_f[index1 + 2] += weight_dkappa_ * 2.0 * dkappa *                            spiral_curve.DeriveDKappaDerivative(                                DKAPPA1, j, num_of_internal_points_);      grad_f[variable_offset + i] += weight_dkappa_ * 2.0 * dkappa *                                     spiral_curve.DeriveDKappaDerivative(                                         DELTA_S, j, num_of_internal_points_);    &#125;  &#125;  return true;&#125;\n SpiralProblemInterface::eval_g()\n{g1i=xi+1−xi−∫0Δsicos(θ(s))dsn−1个约束g2i=yi+1−yi−∫0Δsisin(θ(s))dsn−1个约束g3i=(xi−xˉi)2+(yi−yˉi)2n个约束\\begin{cases}\ng_{1i} = x_{i+1} - x_i - \\int_0^{\\Delta s_i} cos(\\theta(s))ds &amp; n-1个约束\\\\\ng_{2i} = y_{i+1} - y_i - \\int_0^{\\Delta s_i} sin(\\theta(s))ds &amp; n-1个约束 \\\\\ng_{3i} = (x_i - \\bar{x}_i)^2 + (y_i - \\bar{y}_i)^2 &amp; n个约束\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​g1i​=xi+1​−xi​−∫0Δsi​​cos(θ(s))dsg2i​=yi+1​−yi​−∫0Δsi​​sin(θ(s))dsg3i​=(xi​−xˉi​)2+(yi​−yˉ​i​)2​n−1个约束n−1个约束n个约束​\nbool SpiralProblemInterface::eval_g(int n, const double* x, bool new_x, int m,                                    double* g) &#123;  CHECK_EQ(n, num_of_variables_);  CHECK_EQ(m, num_of_constraints_);  if (new_x) &#123;    // new_x会反馈出求解器是否更新了优化变量，如果更新了优化变量，我们就要重新更新螺旋曲线函数，利用新的优化变量构造螺旋曲线    update_piecewise_spiral_paths(x, n);  &#125;  // first, fill in the positional equality constraints  for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;    int index0 = i * 5;    int index1 = (i + 1) * 5;    const auto&amp; spiral_curve = piecewise_paths_[i];    double delta_s = spiral_curve.ParamLength();    double x_diff = x[index1 + 3] - x[index0 + 3] -                    spiral_curve.ComputeCartesianDeviationX(delta_s);    g[i * 2] = x_diff * x_diff; // ？？？为什么这里要取平方？？？    double y_diff = x[index1 + 4] - x[index0 + 4] -                    spiral_curve.ComputeCartesianDeviationY(delta_s);    g[i * 2 + 1] = y_diff * y_diff; // ？？？为什么这里要取平方？？？  &#125;  // second, fill in the positional deviation constraints  int constraint_offset = 2 * (num_of_points_ - 1);  for (int i = 0; i &lt; num_of_points_; ++i) &#123;    int variable_index = i * 5;    double x_cor = x[variable_index + 3];    double y_cor = x[variable_index + 4];    double x_diff = x_cor - init_points_[i].x();    double y_diff = y_cor - init_points_[i].y();    g[constraint_offset + i] = x_diff * x_diff + y_diff * y_diff;  &#125;  return true;&#125;\n SpiralProblemInterface::eval_jac_g()\n约束函数雅克比矩阵的定义在eval_jac_g函数中实现。\n需要注意的是，函数中雅克比矩阵是通过稀疏矩阵形式调用的，\n其中iRow，jCol分别表示雅克比矩阵非0项的行号和列号的数组\nnele_jac是雅克比矩阵非0项的个数\nvalue为雅克比矩阵非0项的值\n当求解器第一次调用该函数时，values为空指针，此时需要定义矩阵中非恒为0项的iRow，iCol。\n之后求解器调用该函数，values将始终有指针，此时求解雅克比矩阵非0项的值，数目为(n−1)∗2∗9+n∗2(n-1)*2*9+n*2(n−1)∗2∗9+n∗2\n(∂g11∂θ0∂g11∂θ0′∂g11∂θ0′′∂g11∂x0∂g11∂y0∂g11∂θ1∂g11∂θ1′∂g11∂θ1′′∂g11∂x1∂g11∂y1⋯∂g11∂θn−1∂g11∂θn−1′∂g11∂θn−1′′∂g11∂xn−1∂g11∂yn−1∂g11∂Δs1∂g11∂Δs2⋯∂g11∂Δsn−1∂g21∂θ0∂g21∂θ0′∂g21∂θ0′′∂g21∂x0∂g21∂y0∂g21∂θ1∂g21∂θ1′∂g21∂θ1′′∂g21∂x1∂g21∂y1⋯∂g21∂θn−1∂g21∂θn−1′∂g21∂θn−1′′∂g21∂xn−1∂g21∂yn−1∂g21∂Δs1∂g21∂Δs2⋯∂g21∂Δsn−1∂g12∂θ0∂g12∂θ0′∂g12∂θ0′′∂g12∂x0∂g12∂y0∂g12∂θ1∂g12∂θ1′∂g12∂θ1′′∂g12∂x1∂g12∂y1⋯∂g12∂θn−1∂g12∂θn−1′∂g12∂θn−1′′∂g12∂xn−1∂g12∂yn−1∂g12∂Δs1∂g12∂Δs2⋯∂g12∂Δsn−1∂g22∂θ0∂g22∂θ0′∂g22∂θ0′′∂g22∂x0∂g22∂y0∂g22∂θ1∂g22∂θ1′∂g22∂θ1′′∂g22∂x1∂g22∂y1⋯∂g22∂θn−1∂g22∂θn−1′∂g22∂θn−1′′∂g22∂xn−1∂g22∂yn−1∂g22∂Δs1∂g22∂Δs2⋯∂g22∂Δsn−1⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮∂g1(n−1)∂θ0∂g1(n−1)∂θ0′∂g1(n−1)∂θ0′′∂g1(n−1)∂x0∂g1(n−1)∂y0∂g1(n−1)∂θ1∂g1(n−1)∂θ1′∂g1(n−1)∂θ1′′∂g1(n−1)∂x1∂g1(n−1)∂y1⋯∂g1(n−1)∂θn−1∂g1(n−1)∂θn−1′∂g1(n−1)∂θn−1′′∂g1(n−1)∂xn−1∂g1(n−1)∂yn−1∂g1(n−1)∂Δs1∂g1(n−1)∂Δs2⋯∂g1(n−1)∂Δsn−1∂g2(n−1)∂θ0∂g2(n−1)∂θ0′∂g2(n−1)∂θ0′′∂g2(n−1)∂x0∂g2(n−1)∂y0∂g2(n−1)∂θ1∂g2(n−1)∂θ1′∂g2(n−1)∂θ1′′∂g2(n−1)∂x1∂g2(n−1)∂y1⋯∂g2(n−1)∂θn−1∂g2(n−1)∂θn−1′∂g2(n−1)∂θn−1′′∂g2(n−1)∂xn−1∂g2(n−1)∂yn−1∂g2(n−1)∂Δs1∂g2(n−1)∂Δs2⋯∂g2(n−1)∂Δsn−1∂g31∂θ0∂g31∂θ0′∂g31∂θ0′′∂g31∂x0∂g31∂y0∂g31∂θ1∂g31∂θ1′∂g31∂θ1′′∂g31∂x1∂g31∂y1⋯∂g31∂θn−1∂g31∂θn−1′∂g31∂θn−1′′∂g31∂xn−1∂g31∂yn−1∂g31∂Δs1∂g31∂Δs2⋯∂g31∂Δsn−1⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮∂g3n∂θ0∂g3n∂θ0′∂g3n∂θ0′′∂g3n∂x0∂g3n∂y0∂g3n∂θ1∂g3n∂θ1′∂g3n∂θ1′′∂g3n∂x1∂g3n∂y1⋯∂g3n∂θn−1∂g3n∂θn−1′∂g3n∂θn−1′′∂g3n∂xn−1∂g3n∂yn−1∂g3n∂Δs1∂g3n∂Δs2⋯∂g3n∂Δsn−1)[2(n−1)+n]×[5n+n−1]\\begin{pmatrix}\n\\frac{\\partial g_{11}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{11}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{11}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{11}}{\\partial x_0} &amp; \\frac{\\partial g_{11}}{\\partial y_0} &amp;\n\n\\frac{\\partial g_{11}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{11}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{11}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{11}}{\\partial x_1} &amp; \\frac{\\partial g_{11}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{11}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{11}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{11}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{11}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{11}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{11}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{11}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{11}}{\\partial \\Delta s_{n-1}} \\\\\n\n\\frac{\\partial g_{21}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{21}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{21}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{21}}{\\partial x_0} &amp; \\frac{\\partial g_{21}}{\\partial y_0} &amp;\n\n\\frac{\\partial g_{21}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{21}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{21}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{21}}{\\partial x_1} &amp; \\frac{\\partial g_{21}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{21}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{21}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{21}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{21}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{21}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{21}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{21}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{21}}{\\partial \\Delta s_{n-1}} \\\\\n\n\\frac{\\partial g_{12}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{12}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{12}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{12}}{\\partial x_0} &amp; \\frac{\\partial g_{12}}{\\partial y_0} &amp;\n\n\\frac{\\partial g_{12}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{12}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{12}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{12}}{\\partial x_1} &amp; \\frac{\\partial g_{12}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{12}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{12}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{12}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{12}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{12}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{12}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{12}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{12}}{\\partial \\Delta s_{n-1}} \\\\\n\n\\frac{\\partial g_{22}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{22}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{22}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{22}}{\\partial x_0} &amp; \\frac{\\partial g_{22}}{\\partial y_0} &amp;\n\n\\frac{\\partial g_{22}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{22}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{22}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{22}}{\\partial x_1} &amp; \\frac{\\partial g_{22}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{22}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{22}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{22}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{22}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{22}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{22}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{22}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{22}}{\\partial \\Delta s_{n-1}} \\\\\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\\n\n\\frac{\\partial g_{1(n-1)}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial x_0} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial y_0} &amp;\n\n\\frac{\\partial g_{1(n-1)}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial x_1} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{1(n-1)}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{1(n-1)}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{1(n-1)}}{\\partial \\Delta s_{n-1}} \\\\\n\n\\frac{\\partial g_{2(n-1)}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial x_0} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial y_0} &amp;\n\\frac{\\partial g_{2(n-1)}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial x_1} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{2(n-1)}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{2(n-1)}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{2(n-1)}}{\\partial \\Delta s_{n-1}} \\\\\n\n\n\\frac{\\partial g_{31}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{31}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{31}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{31}}{\\partial x_0} &amp; \\frac{\\partial g_{31}}{\\partial y_0} &amp;\n\\frac{\\partial g_{31}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{31}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{31}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{31}}{\\partial x_1} &amp; \\frac{\\partial g_{31}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{31}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{31}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{31}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{31}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{31}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{31}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{31}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{31}}{\\partial \\Delta s_{n-1}} \\\\\n\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\\\\n\n\\frac{\\partial g_{3n}}{\\partial \\theta_0} &amp; \\frac{\\partial g_{3n}}{\\partial \\theta&#x27;_0} &amp; \\frac{\\partial g_{3n}}{\\partial \\theta&#x27;&#x27;_0} &amp; \\frac{\\partial g_{3n}}{\\partial x_0} &amp; \\frac{\\partial g_{3n}}{\\partial y_0} &amp;\n\\frac{\\partial g_{3n}}{\\partial \\theta_1} &amp; \\frac{\\partial g_{3n}}{\\partial \\theta&#x27;_1} &amp; \\frac{\\partial g_{3n}}{\\partial \\theta&#x27;&#x27;_1} &amp; \\frac{\\partial g_{3n}}{\\partial x_1} &amp; \\frac{\\partial g_{3n}}{\\partial y_1} &amp; \\cdots &amp;\n\\frac{\\partial g_{3n}}{\\partial \\theta_{n-1}} &amp; \\frac{\\partial g_{3n}}{\\partial \\theta&#x27;_{n-1}} &amp; \\frac{\\partial g_{3n}}{\\partial \\theta&#x27;&#x27;_{n-1}} &amp; \\frac{\\partial g_{3n}}{\\partial x_{n-1}} &amp; \\frac{\\partial g_{3n}}{\\partial y_{n-1}} &amp; \n\\frac{\\partial g_{3n}}{\\partial \\Delta s_1} &amp; \\frac{\\partial g_{3n}}{\\partial \\Delta s_2} &amp;\n\\cdots &amp; \\frac{\\partial g_{3n}}{\\partial \\Delta s_{n-1}} \\\\\n\\end{pmatrix}_{[2(n-1)+n] \\times [5n+n-1]}\n⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​∂θ0​∂g11​​∂θ0​∂g21​​∂θ0​∂g12​​∂θ0​∂g22​​⋮∂θ0​∂g1(n−1)​​∂θ0​∂g2(n−1)​​∂θ0​∂g31​​⋮∂θ0​∂g3n​​​∂θ0′​∂g11​​∂θ0′​∂g21​​∂θ0′​∂g12​​∂θ0′​∂g22​​⋮∂θ0′​∂g1(n−1)​​∂θ0′​∂g2(n−1)​​∂θ0′​∂g31​​⋮∂θ0′​∂g3n​​​∂θ0′′​∂g11​​∂θ0′′​∂g21​​∂θ0′′​∂g12​​∂θ0′′​∂g22​​⋮∂θ0′′​∂g1(n−1)​​∂θ0′′​∂g2(n−1)​​∂θ0′′​∂g31​​⋮∂θ0′′​∂g3n​​​∂x0​∂g11​​∂x0​∂g21​​∂x0​∂g12​​∂x0​∂g22​​⋮∂x0​∂g1(n−1)​​∂x0​∂g2(n−1)​​∂x0​∂g31​​⋮∂x0​∂g3n​​​∂y0​∂g11​​∂y0​∂g21​​∂y0​∂g12​​∂y0​∂g22​​⋮∂y0​∂g1(n−1)​​∂y0​∂g2(n−1)​​∂y0​∂g31​​⋮∂y0​∂g3n​​​∂θ1​∂g11​​∂θ1​∂g21​​∂θ1​∂g12​​∂θ1​∂g22​​⋮∂θ1​∂g1(n−1)​​∂θ1​∂g2(n−1)​​∂θ1​∂g31​​⋮∂θ1​∂g3n​​​∂θ1′​∂g11​​∂θ1′​∂g21​​∂θ1′​∂g12​​∂θ1′​∂g22​​⋮∂θ1′​∂g1(n−1)​​∂θ1′​∂g2(n−1)​​∂θ1′​∂g31​​⋮∂θ1′​∂g3n​​​∂θ1′′​∂g11​​∂θ1′′​∂g21​​∂θ1′′​∂g12​​∂θ1′′​∂g22​​⋮∂θ1′′​∂g1(n−1)​​∂θ1′′​∂g2(n−1)​​∂θ1′′​∂g31​​⋮∂θ1′′​∂g3n​​​∂x1​∂g11​​∂x1​∂g21​​∂x1​∂g12​​∂x1​∂g22​​⋮∂x1​∂g1(n−1)​​∂x1​∂g2(n−1)​​∂x1​∂g31​​⋮∂x1​∂g3n​​​∂y1​∂g11​​∂y1​∂g21​​∂y1​∂g12​​∂y1​∂g22​​⋮∂y1​∂g1(n−1)​​∂y1​∂g2(n−1)​​∂y1​∂g31​​⋮∂y1​∂g3n​​​⋯⋯⋯⋯⋮⋯⋯⋯⋮⋯​∂θn−1​∂g11​​∂θn−1​∂g21​​∂θn−1​∂g12​​∂θn−1​∂g22​​⋮∂θn−1​∂g1(n−1)​​∂θn−1​∂g2(n−1)​​∂θn−1​∂g31​​⋮∂θn−1​∂g3n​​​∂θn−1′​∂g11​​∂θn−1′​∂g21​​∂θn−1′​∂g12​​∂θn−1′​∂g22​​⋮∂θn−1′​∂g1(n−1)​​∂θn−1′​∂g2(n−1)​​∂θn−1′​∂g31​​⋮∂θn−1′​∂g3n​​​∂θn−1′′​∂g11​​∂θn−1′′​∂g21​​∂θn−1′′​∂g12​​∂θn−1′′​∂g22​​⋮∂θn−1′′​∂g1(n−1)​​∂θn−1′′​∂g2(n−1)​​∂θn−1′′​∂g31​​⋮∂θn−1′′​∂g3n​​​∂xn−1​∂g11​​∂xn−1​∂g21​​∂xn−1​∂g12​​∂xn−1​∂g22​​⋮∂xn−1​∂g1(n−1)​​∂xn−1​∂g2(n−1)​​∂xn−1​∂g31​​⋮∂xn−1​∂g3n​​​∂yn−1​∂g11​​∂yn−1​∂g21​​∂yn−1​∂g12​​∂yn−1​∂g22​​⋮∂yn−1​∂g1(n−1)​​∂yn−1​∂g2(n−1)​​∂yn−1​∂g31​​⋮∂yn−1​∂g3n​​​∂Δs1​∂g11​​∂Δs1​∂g21​​∂Δs1​∂g12​​∂Δs1​∂g22​​⋮∂Δs1​∂g1(n−1)​​∂Δs1​∂g2(n−1)​​∂Δs1​∂g31​​⋮∂Δs1​∂g3n​​​∂Δs2​∂g11​​∂Δs2​∂g21​​∂Δs2​∂g12​​∂Δs2​∂g22​​⋮∂Δs2​∂g1(n−1)​​∂Δs2​∂g2(n−1)​​∂Δs2​∂g31​​⋮∂Δs2​∂g3n​​​⋯⋯⋯⋯⋮⋯⋯⋯⋮⋯​∂Δsn−1​∂g11​​∂Δsn−1​∂g21​​∂Δsn−1​∂g12​​∂Δsn−1​∂g22​​⋮∂Δsn−1​∂g1(n−1)​​∂Δsn−1​∂g2(n−1)​​∂Δsn−1​∂g31​​⋮∂Δsn−1​∂g3n​​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​[2(n−1)+n]×[5n+n−1]​\ngijg_{ij}gij​表示对于第jjj条曲线的第iii个约束方程，其中非000​项是比较少的。\ng1jg_{1j}g1j​​仅对θ(j−1),θ′(j−1),θ′′(j−1),x(j−1),θ(j),θ′(j),θ′′(j),x(j),Δsjθ(j-1),θ&#x27;(j-1),θ&#x27;&#x27;(j-1),x(j-1),θ(j),θ&#x27;(j),θ&#x27;&#x27;(j),x(j),\\Delta s_jθ(j−1),θ′(j−1),θ′′(j−1),x(j−1),θ(j),θ′(j),θ′′(j),x(j),Δsj​求导非000​；\ng2jg_{2j}g2j​​​仅对θ(j−1),θ′(j−1),θ′′(j−1),y(j−1),θ(j),θ′(j),θ′′(j),y(j),Δsjθ(j-1),θ&#x27;(j-1),θ&#x27;&#x27;(j-1),y(j-1),θ(j),θ&#x27;(j),θ&#x27;&#x27;(j),y(j),\\Delta s_jθ(j−1),θ′(j−1),θ′′(j−1),y(j−1),θ(j),θ′(j),θ′′(j),y(j),Δsj​​​求导非000；\ng3jg_{3j}g3j​​​仅对xi,yix_i,y_ixi​,yi​​​求导非000​，则有\nbool SpiralProblemInterface::eval_jac_g(int n, const double* x, bool new_x,                                        int m, int nele_jac, int* iRow,                                        int* jCol, double* values) &#123;  CHECK_EQ(n, num_of_variables_);  CHECK_EQ(m, num_of_constraints_);  if (values == nullptr) &#123;    // none zero非零值的下标    int nz_index = 0;    int variable_offset = num_of_points_ * 5;    for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;      int variable_index = i * 5;      // g1 等式约束      // theta0      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 0;      ++nz_index;      // kappa0      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 1;      ++nz_index;      // dkappa0      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 2;      ++nz_index;      // x0      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 3;      ++nz_index;      // theta1      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 5;      ++nz_index;      // kappa1      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 6;      ++nz_index;      // dkappa1      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 7;      ++nz_index;      // x1      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_index + 8;      ++nz_index;      // s      iRow[nz_index] = i * 2;      jCol[nz_index] = variable_offset + i;      ++nz_index;            // g2 等式约束      // theta0      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 0;      ++nz_index;      // kappa0      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 1;      ++nz_index;      // dkappa0      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 2;      ++nz_index;      // y0      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 4;      ++nz_index;      // theta1      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 5;      ++nz_index;      // kappa1      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 6;      ++nz_index;      // dkappa1      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 7;      ++nz_index;      // y1      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_index + 9;      ++nz_index;      // s      iRow[nz_index] = i * 2 + 1;      jCol[nz_index] = variable_offset + i;      ++nz_index;    &#125;    int constraint_offset = 2 * (num_of_points_ - 1);    for (int i = 0; i &lt; num_of_points_; ++i) &#123;      // 对x求偏导非零      iRow[nz_index] = constraint_offset + i;      jCol[nz_index] = i * 5 + 3;      ++nz_index;      // 对y求偏导非零      iRow[nz_index] = constraint_offset + i;      jCol[nz_index] = i * 5 + 4;      ++nz_index;    &#125;    CHECK_EQ(nz_index, nele_jac);  &#125; else &#123;    if (new_x) &#123;      update_piecewise_spiral_paths(x, n);    &#125;    std::fill(values, values + nele_jac, 0.0);    // first, positional equality constraints    int nz_index = 0;    for (int i = 0; i + 1 &lt; num_of_points_; ++i) &#123;      int index0 = i * 5;      int index1 = (i + 1) * 5;      auto&amp; spiral_curve = piecewise_paths_[i];      double delta_s = spiral_curve.ParamLength();      double x_diff = x[index1 + 3] - x[index0 + 3] -                      spiral_curve.ComputeCartesianDeviationX(delta_s);      double y_diff = x[index1 + 4] - x[index0 + 4] -                      spiral_curve.ComputeCartesianDeviationY(delta_s);      auto pos_theta0 = spiral_curve.DeriveCartesianDeviation(THETA0);      auto pos_kappa0 = spiral_curve.DeriveCartesianDeviation(KAPPA0);      auto pos_dkappa0 = spiral_curve.DeriveCartesianDeviation(DKAPPA0);      auto pos_theta1 = spiral_curve.DeriveCartesianDeviation(THETA1);      auto pos_kappa1 = spiral_curve.DeriveCartesianDeviation(KAPPA1);      auto pos_dkappa1 = spiral_curve.DeriveCartesianDeviation(DKAPPA1);      auto pos_delta_s = spiral_curve.DeriveCartesianDeviation(DELTA_S);      // for x coordinate      // theta0      values[nz_index] += 2.0 * x_diff * (-pos_theta0.first);      ++nz_index;      // kappa0      values[nz_index] += 2.0 * x_diff * (-pos_kappa0.first);      ++nz_index;      // dkappa0      values[nz_index] += 2.0 * x_diff * (-pos_dkappa0.first);      ++nz_index;      // x0      values[nz_index] += 2.0 * x_diff * (-1.0);      ++nz_index;      // theta1      values[nz_index] += 2.0 * x_diff * (-pos_theta1.first);      ++nz_index;      // kappa1      values[nz_index] += 2.0 * x_diff * (-pos_kappa1.first);      ++nz_index;      // dkappa1      values[nz_index] += 2.0 * x_diff * (-pos_dkappa1.first);      ++nz_index;      // x1      values[nz_index] += 2.0 * x_diff;      ++nz_index;      // delta_s      values[nz_index] += 2.0 * x_diff * (-pos_delta_s.first);      ++nz_index;      // for y coordinate      // theta0      values[nz_index] += 2.0 * y_diff * (-pos_theta0.second);      ++nz_index;      // kappa0      values[nz_index] += 2.0 * y_diff * (-pos_kappa0.second);      ++nz_index;      // dkappa0      values[nz_index] += 2.0 * y_diff * (-pos_dkappa0.second);      ++nz_index;      // y0      values[nz_index] += 2.0 * y_diff * (-1.0);      ++nz_index;      // theta1      values[nz_index] += 2.0 * y_diff * (-pos_theta1.second);      ++nz_index;      // kappa1      values[nz_index] += 2.0 * y_diff * (-pos_kappa1.second);      ++nz_index;      // dkappa1      values[nz_index] += 2.0 * y_diff * (-pos_dkappa1.second);      ++nz_index;      // y1      values[nz_index] += 2.0 * y_diff;      ++nz_index;      // delta_s      values[nz_index] += 2.0 * y_diff * (-pos_delta_s.second);      ++nz_index;    &#125;    for (int i = 0; i &lt; num_of_points_; ++i) &#123;      values[nz_index] = 2.0 * (x[i * 5 + 3] - init_points_[i].x());      ++nz_index;      values[nz_index] = 2.0 * (x[i * 5 + 4] - init_points_[i].y());      ++nz_index;    &#125;    CHECK_EQ(nz_index, nele_jac);  &#125;  return true;&#125;\napollo中也是对约束函数的实现加入了平方处理：\n∂g1i∂θi=∂(xi+1−xi−∫0Δsicos(θ(s))ds)∂θi=2[xi+1−xi−∫0Δsicos(θ(s))ds]⋅−∂∫0Δsicos(θ(s))ds∂θi\\frac{\\partial g_{1i}}{\\partial \\theta_i} = \n\\frac{\\partial (x_{i+1} - x_i - \\int_0^{\\Delta s_i} cos(\\theta(s))ds)}{\\partial \\theta_i} \n= 2[x_{i+1} - x_i - \\int_0^{\\Delta s_i} cos(\\theta(s))ds] \\cdot \\frac{-\\partial \\int_0^{\\Delta s_i} cos(\\theta(s))ds}{\\partial \\theta_i}\n∂θi​∂g1i​​=∂θi​∂(xi+1​−xi​−∫0Δsi​​cos(θ(s))ds)​=2[xi+1​−xi​−∫0Δsi​​cos(θ(s))ds]⋅∂θi​−∂∫0Δsi​​cos(θ(s))ds​\n前一项是两个点xxx方向距离差，通过螺旋曲线类函数ComputeCartesianDeviationX求解，后一项的求导可以通过类函数DeriveCartesianDeviation(THETA0)来求解，g2jg_{2j}g2j​同理。\ng3ig_{3i}g3i​仅对xi,yix_i,y_ixi​,yi​求偏导：\n∂g3i∂xi=2(xi−xˉi)∂g3i∂yi=2(yi−yˉi)\\frac{\\partial g_{3i}}{\\partial x_i} = 2(x_i - \\bar{x}_i) \\\\\n\\frac{\\partial g_{3i}}{\\partial y_i} = 2(y_i - \\bar{y}_i)\n∂xi​∂g3i​​=2(xi​−xˉi​)∂yi​∂g3i​​=2(yi​−yˉ​i​)\n SpiralProblemInterface::eval_h()\n设置了调用ipopt的拟牛顿法近似求解二阶偏导数，所以函数eval_h()这里无需实现\n...app-&gt;Options()-&gt;SetStringValue(&quot;hessian_approximation&quot;, &quot;limited-memory&quot;);...bool SpiralProblemInterface::eval_h(int n, const double* x, bool new_x,                                    double obj_factor, int m,                                    const double* lambda, bool new_lambda,                                    int nele_hess, int* iRow, int* jCol,                                    double* values) &#123;  CHECK(false);  return true;&#125;\n 基于参考线锚点平滑–锚点在平滑的作用\n没有锚点的时候，就从原始曲线上根据间隔采样出原始点集合（只有x和y值），然后用IPOPT进行平滑优化（即拟合出一条平滑曲线），得到优化后的点集合（带航向角、曲率等信息），再根据分辨率直接用螺旋曲线插入额外的点。有锚点时候，当锚点带enforced属性，意味必须强行使用该点（x和y值、航向角、曲率等），然后根据分辨率直接用螺旋曲线插入额外的点；如果不带enforced属性，则只需要锚点的x和y值组合成原始点集合，然后用IPOPT进行平滑优化（即拟合出一条平滑曲线），得到优化后的点集合（带航向角、曲率等信息），再根据分辨率直接用螺旋曲线插入额外的点。\n SpiralReferenceLineSmoother::Smooth()\nbool SpiralReferenceLineSmoother::Smooth(    const ReferenceLine&amp; raw_reference_line,    ReferenceLine* const smoothed_reference_line) &#123;  const double start_timestamp = Clock::NowInSeconds();  std::vector&lt;double&gt; opt_x;  std::vector&lt;double&gt; opt_y;  std::vector&lt;double&gt; opt_theta;  std::vector&lt;double&gt; opt_kappa;  std::vector&lt;double&gt; opt_dkappa;  std::vector&lt;double&gt; opt_s;  if (anchor_points_.empty()) &#123;    const double piecewise_length = config_.spiral().piecewise_length();    const double length = raw_reference_line.Length();    ADEBUG &lt;&lt; &quot;Length = &quot; &lt;&lt; length;    uint32_t num_of_pieces =        std::max(1u, static_cast&lt;uint32_t&gt;(length / piecewise_length));    const double delta_s = length / num_of_pieces;    double s = 0.0;    std::vector&lt;Eigen::Vector2d&gt; raw_point2d;    for (std::uint32_t i = 0; i &lt;= num_of_pieces;         ++i, s = std::fmin(s + delta_s, length)) &#123;      ReferencePoint rlp = raw_reference_line.GetReferencePoint(s);      raw_point2d.emplace_back(rlp.x(), rlp.y());    &#125;    Smooth(raw_point2d, &amp;opt_theta, &amp;opt_kappa, &amp;opt_dkappa, &amp;opt_s, &amp;opt_x,           &amp;opt_y);  &#125; else &#123;    size_t start_index = 0;    for (const auto&amp; anchor_point : anchor_points_) &#123;      if (anchor_point.enforced) &#123;        start_index++;      &#125; else &#123;        break;      &#125;    &#125;    std::vector&lt;Eigen::Vector2d&gt; raw_point2d;    if (start_index == 0) &#123;      for (const auto&amp; anchor_point : anchor_points_) &#123;        raw_point2d.emplace_back(anchor_point.path_point.x(),                                 anchor_point.path_point.y());      &#125;    &#125; else &#123;      std::vector&lt;double&gt; overhead_s;      for (size_t i = 0; i + 1 &lt; start_index; ++i) &#123;        const auto&amp; p0 = anchor_points_[i];        const auto&amp; p1 = anchor_points_[i + 1];        overhead_s.push_back(p1.path_point.s() - p0.path_point.s());      &#125;      std::vector&lt;double&gt; overhead_theta;      std::vector&lt;double&gt; overhead_kappa;      std::vector&lt;double&gt; overhead_dkappa;      std::vector&lt;double&gt; overhead_x;      std::vector&lt;double&gt; overhead_y;      for (size_t i = 0; i &lt; anchor_points_.size(); ++i) &#123;        const auto&amp; p = anchor_points_[i];        if (i + 1 &lt; start_index) &#123;          overhead_theta.push_back(p.path_point.theta());          overhead_kappa.push_back(p.path_point.kappa());          overhead_dkappa.push_back(p.path_point.dkappa());          overhead_x.push_back(p.path_point.x());          overhead_y.push_back(p.path_point.y());        &#125; else &#123;          raw_point2d.emplace_back(p.path_point.x(), p.path_point.y());        &#125;      &#125;      const auto&amp; start_anchor_point = anchor_points_[start_index - 1];      fixed_start_point_ = true;      fixed_start_x_ = start_anchor_point.path_point.x();      fixed_start_y_ = start_anchor_point.path_point.y();      fixed_start_theta_ =          common::math::NormalizeAngle(start_anchor_point.path_point.theta());      fixed_start_kappa_ = start_anchor_point.path_point.kappa();      fixed_start_dkappa_ = start_anchor_point.path_point.dkappa();      const auto&amp; end_anchor_point = anchor_points_.back();      fixed_end_x_ = end_anchor_point.path_point.x();      fixed_end_y_ = end_anchor_point.path_point.y();      Smooth(raw_point2d, &amp;opt_theta, &amp;opt_kappa, &amp;opt_dkappa, &amp;opt_s, &amp;opt_x,             &amp;opt_y);      opt_theta.insert(opt_theta.begin(), overhead_theta.begin(),                       overhead_theta.end());      opt_kappa.insert(opt_kappa.begin(), overhead_kappa.begin(),                       overhead_kappa.end());      opt_dkappa.insert(opt_dkappa.begin(), overhead_dkappa.begin(),                        overhead_dkappa.end());      opt_s.insert(opt_s.begin(), overhead_s.begin(), overhead_s.end());      opt_x.insert(opt_x.begin(), overhead_x.begin(), overhead_x.end());      opt_y.insert(opt_y.begin(), overhead_y.begin(), overhead_y.end());      std::for_each(opt_x.begin(), opt_x.end(),                    [this](double&amp; x) &#123; x += zero_x_; &#125;);      std::for_each(opt_y.begin(), opt_y.end(),                    [this](double&amp; y) &#123; y += zero_y_; &#125;);    &#125;  &#125;  std::vector&lt;common::PathPoint&gt; smoothed_point2d =      Interpolate(opt_theta, opt_kappa, opt_dkappa, opt_s, opt_x, opt_y,                  config_.resolution());  std::vector&lt;ReferencePoint&gt; ref_points;  for (const auto&amp; p : smoothed_point2d) &#123;    const double heading = p.theta();    const double kappa = p.kappa();    const double dkappa = p.dkappa();    common::SLPoint ref_sl_point;    if (!raw_reference_line.XYToSL(p, &amp;ref_sl_point)) &#123;      return false;    &#125;    if (ref_sl_point.s() &lt; 0 ||        ref_sl_point.s() &gt; raw_reference_line.Length()) &#123;      continue;    &#125;    ReferencePoint rlp = raw_reference_line.GetReferencePoint(ref_sl_point.s());    ref_points.emplace_back(        ReferencePoint(hdmap::MapPathPoint(common::math::Vec2d(p.x(), p.y()),                                           heading, rlp.lane_waypoints()),                       kappa, dkappa));  &#125;  ReferencePoint::RemoveDuplicates(&amp;ref_points);  if (ref_points.size() &lt; 2) &#123;    AERROR &lt;&lt; &quot;Fail to generate smoothed reference line.&quot;;    return false;  &#125;  *smoothed_reference_line = ReferenceLine(ref_points);  const double end_timestamp = Clock::NowInSeconds();  ADEBUG &lt;&lt; &quot;Spiral reference line smoother time: &quot;         &lt;&lt; (end_timestamp - start_timestamp) * 1000 &lt;&lt; &quot; ms.&quot;;  return true;&#125;\n SpiralSmootherUtil::Smooth()\nbool SpiralSmootherUtil::Smooth(    std::vector&lt;Eigen::Vector2d&gt; raw_points,    std::vector&lt;common::PathPoint&gt;* ptr_smooth_points) &#123;  if (raw_points.size() &lt;= 2) &#123;    AERROR &lt;&lt; &quot;the original point size is &quot; &lt;&lt; raw_points.size();    return false;  &#125;  std::vector&lt;Eigen::Vector2d&gt; processed_points;  processed_points.push_back(raw_points.front());  // FLAGS_minimum_point_spacing = 5.0  // 也就是从原始点集合里面，每隔5米取一个点，放在processed_points里面  for (const Eigen::Vector2d&amp; p : raw_points) &#123;    Eigen::Vector2d d = p - processed_points.back();    if (d.norm() &lt; FLAGS_minimum_point_spacing) &#123;      continue;    &#125;    processed_points.push_back(p);  &#125;  if (processed_points.size() &lt; 2) &#123;    processed_points.push_back(raw_points.back());  &#125;  // 以第一点为原点，标准化处理  Eigen::Vector2d start_point = processed_points.front();  std::for_each(processed_points.begin(), processed_points.end(),                [&amp;start_point](Eigen::Vector2d&amp; p) &#123; p = p - start_point; &#125;);  // 读取配置参数  ReferenceLineSmootherConfig config;  if (!cyber::common::GetProtoFromFile(          &quot;modules/planning/conf/spiral_smoother_config.pb.txt&quot;, &amp;config)) &#123;    AERROR &lt;&lt; &quot;modules/planning/conf/spiral_smoother_config.pb.txt is invalid.&quot;;    return false;  &#125;  std::vector&lt;double&gt; opt_theta;  std::vector&lt;double&gt; opt_kappa;  std::vector&lt;double&gt; opt_dkappa;  std::vector&lt;double&gt; opt_s;  std::vector&lt;double&gt; opt_x;  std::vector&lt;double&gt; opt_y;  // 创建螺旋曲线平滑器  SpiralReferenceLineSmoother spiral_smoother(config);  auto res =      spiral_smoother.SmoothStandAlone(processed_points, &amp;opt_theta, &amp;opt_kappa,                                       &amp;opt_dkappa, &amp;opt_s, &amp;opt_x, &amp;opt_y);  if (!res) &#123;    AWARN &lt;&lt; &quot;Optimization failed; the result may not be smooth&quot;;  &#125; else &#123;    AINFO &lt;&lt; &quot;Optimal solution found&quot;;  &#125;  // 将结果去标准化，还原到原始坐标系  std::for_each(opt_x.begin(), opt_x.end(),                [&amp;start_point](double&amp; x) &#123; x += start_point.x(); &#125;);  std::for_each(opt_y.begin(), opt_y.end(),                [&amp;start_point](double&amp; y) &#123; y += start_point.y(); &#125;);  // 根据分辨率对平滑解进行插值，得到最终平滑结果  *ptr_smooth_points =      spiral_smoother.Interpolate(opt_theta, opt_kappa, opt_dkappa, opt_s,                                  opt_x, opt_y, config.resolution());  return true;&#125;\n数学知识：Frobenius norm(Frobenius范数)\nFrobenius范数，简称F-范数，是一种矩阵范数，记为||·||F。\n矩阵A的Frobenius范数定义为矩阵A各项元素的绝对值平方的总和，即\n∣∣A∣∣F=∑i=1m∑j=1n∣ai,j∣2||A||_F= \\sqrt{\\sum_{i=1}^m\\sum_{j=1}^{n}|a_{i,j}|^2}\n∣∣A∣∣F​=i=1∑m​j=1∑n​∣ai,j​∣2​\n特例：二维向量，其F-范数为向量长度\n∣∣(x,y)∣∣F=x2+y2|| (x,y) ||_F= \\sqrt{x^2+y^2}\n∣∣(x,y)∣∣F​=x2+y2​\n SpiralReferenceLineSmoother::SmoothStandAlone()\nint SpiralReferenceLineSmoother::SmoothStandAlone(    std::vector&lt;Eigen::Vector2d&gt; point2d, std::vector&lt;double&gt;* ptr_theta,    std::vector&lt;double&gt;* ptr_kappa, std::vector&lt;double&gt;* ptr_dkappa,    std::vector&lt;double&gt;* ptr_s, std::vector&lt;double&gt;* ptr_x,    std::vector&lt;double&gt;* ptr_y) const &#123;  CHECK_GT(point2d.size(), 1);  SpiralProblemInterface* ptop = new SpiralProblemInterface(point2d);  ptop-&gt;set_default_max_point_deviation(config_.spiral().max_deviation());  ptop-&gt;set_element_weight_curve_length(config_.spiral().weight_curve_length());  ptop-&gt;set_element_weight_kappa(config_.spiral().weight_kappa());  ptop-&gt;set_element_weight_dkappa(config_.spiral().weight_dkappa());  Ipopt::SmartPtr&lt;Ipopt::TNLP&gt; problem = ptop;  // Create an instance of the IpoptApplication  Ipopt::SmartPtr&lt;Ipopt::IpoptApplication&gt; app = IpoptApplicationFactory();  app-&gt;Options()-&gt;SetStringValue(&quot;hessian_approximation&quot;, &quot;limited-memory&quot;);  app-&gt;Options()-&gt;SetIntegerValue(&quot;max_iter&quot;, config_.spiral().max_iteration());  app-&gt;Options()-&gt;SetNumericValue(&quot;tol&quot;, config_.spiral().opt_tol());  app-&gt;Options()-&gt;SetNumericValue(&quot;acceptable_tol&quot;,                                  config_.spiral().opt_acceptable_tol());  Ipopt::ApplicationReturnStatus status = app-&gt;Initialize();  if (status != Ipopt::Solve_Succeeded) &#123;    ADEBUG &lt;&lt; &quot;*** Error during initialization!&quot;;    return -1;  &#125;  status = app-&gt;OptimizeTNLP(problem);  if (status == Ipopt::Solve_Succeeded ||      status == Ipopt::Solved_To_Acceptable_Level) &#123;    // Retrieve some statistics about the solve    Ipopt::Index iter_count = app-&gt;Statistics()-&gt;IterationCount();    ADEBUG &lt;&lt; &quot;*** The problem solved in &quot; &lt;&lt; iter_count &lt;&lt; &quot; iterations!&quot;;    Ipopt::Number final_obj = app-&gt;Statistics()-&gt;FinalObjective();    ADEBUG &lt;&lt; &quot;*** The final value of the objective function is &quot; &lt;&lt; final_obj           &lt;&lt; &#x27;.&#x27;;  &#125; else &#123;    ADEBUG &lt;&lt; &quot;Return status: &quot; &lt;&lt; int(status);  &#125;  ptop-&gt;get_optimization_results(ptr_theta, ptr_kappa, ptr_dkappa, ptr_s, ptr_x,                                 ptr_y);  if (!(status == Ipopt::Solve_Succeeded) &amp;&amp;      !(status == Ipopt::Solved_To_Acceptable_Level)) &#123;    return -1;  &#125;  return app-&gt;Statistics()-&gt;IterationCount();&#125;\n SpiralReferenceLineSmoother::Interpolate()\nstd::vector&lt;common::PathPoint&gt; SpiralReferenceLineSmoother::Interpolate(    const std::vector&lt;double&gt;&amp; theta, const std::vector&lt;double&gt;&amp; kappa,    const std::vector&lt;double&gt;&amp; dkappa, const std::vector&lt;double&gt;&amp; s,    const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y,    const double resolution) const &#123;  std::vector&lt;common::PathPoint&gt; smoothed_point2d;  // 第一个点的s为0.0  double start_s = 0.0;  // 创建第一个Pathpoint  common::PathPoint first_point =      to_path_point(x.front(), y.front(), start_s, theta.front(), kappa.front(),                    dkappa.front());  smoothed_point2d.push_back(first_point);  for (size_t i = 0; i + 1 &lt; theta.size(); ++i) &#123;    double start_x = x[i];    double start_y = y[i];    // s[i]两点之间的s间隔    auto path_point_seg = Interpolate(        start_x, start_y, start_s, theta[i], kappa[i], dkappa[i], theta[i + 1],        kappa[i + 1], dkappa[i + 1], s[i], resolution);    // 插入插值算法得到的点    smoothed_point2d.insert(smoothed_point2d.end(), path_point_seg.begin(),                            path_point_seg.end());    start_s = smoothed_point2d.back().s();  &#125;  return smoothed_point2d;&#125;std::vector&lt;common::PathPoint&gt; SpiralReferenceLineSmoother::Interpolate(    const double start_x, const double start_y, const double start_s,    const double theta0, const double kappa0, const double dkappa0,    const double theta1, const double kappa1, const double dkappa1,    const double delta_s, const double resolution) const &#123;  std::vector&lt;common::PathPoint&gt; path_points;  const auto angle_diff = common::math::AngleDiff(theta0, theta1);  // 生成五次螺旋曲线  QuinticSpiralPath spiral_curve(theta0, kappa0, dkappa0, theta0 + angle_diff,                                 kappa1, dkappa1, delta_s);  // 计算插入的点数  size_t num_of_points =      static_cast&lt;size_t&gt;(std::ceil(delta_s / resolution) + 1);  for (size_t i = 1; i &lt;= num_of_points; ++i) &#123;    const double inter_s =        delta_s / static_cast&lt;double&gt;(num_of_points) * static_cast&lt;double&gt;(i);    const double dx = spiral_curve.ComputeCartesianDeviationX&lt;10&gt;(inter_s);    const double dy = spiral_curve.ComputeCartesianDeviationY&lt;10&gt;(inter_s);    const double theta =        common::math::NormalizeAngle(spiral_curve.Evaluate(0, inter_s));    const double kappa = spiral_curve.Evaluate(1, inter_s);    const double dkappa = spiral_curve.Evaluate(2, inter_s);    // 生成pathpoint    auto path_point = to_path_point(start_x + dx, start_y + dy,                                    start_s + inter_s, theta, kappa, dkappa);    path_points.push_back(std::move(path_point));  &#125;  return path_points;&#125;\n 参数分析\nmax_constraint_interval : 5.0longitudinal_boundary_bound : 2.0max_lateral_boundary_bound : 0.5min_lateral_boundary_bound : 0.1resolution : 0.02curb_shift : 0.2lateral_buffer : 0.2spiral &#123;  max_deviation: 0.05  piecewise_length : 10.0  max_iteration : 500  opt_tol : 1.0e-6  opt_acceptable_tol : 1e-4  opt_acceptable_iteration : 15  weight_curve_length : 1.0  weight_kappa : 1.0  weight_dkappa : 100.0&#125;\n minimum_point_spacing\n锚点采样密度\n max_deviation\n weight_curve_length\n曲线长度比重，意味着尽量地解决原始路线长度。\n weight_kappa\n曲率比重\n weight_dkappa\n max_iteration\n最大迭代次数，一旦优化次数到该值就退出优化。\n opt_tol\n opt_acceptable_tol\n resolution\n插入衔接点的距离间隔（s值），与数值解决器无关。\n","categories":["算法","Apollo源码解读"]},{"title":"Apollo v8.0.0 代码解读 之 五次螺旋曲线(QuinticSpiralPath)","url":"/2022/09/26/Apollo%20v8.0.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E4%BA%94%E6%AC%A1%E8%9E%BA%E6%97%8B%E6%9B%B2%E7%BA%BF(QuinticSpiralPath)/","content":"这篇文章详细解析了Apollo自动驾驶系统中五次螺旋曲线(QuinticSpiralPath)的算法实现。五次螺旋曲线通过弧长-切线角度的五次多项式函数来描述路径，能够有效控制曲率变化，适用于路径规划场景。\n文章从数学原理出发，推导了螺旋曲线的构造公式、笛卡尔坐标变换以及偏导数矩阵的计算方法。重点讲解了如何对航向角、曲率、曲率变化率等函数求偏导数，这些偏导数在螺旋曲线平滑优化过程中用于计算梯度。最后结合Apollo源码，详细分析了关键函数的实现，包括系数矩阵初始化、坐标计算和各类偏导数求解等核心算法。\n\n 参考文献\n螺旋曲线类\n 算法原理\n 螺旋曲线的构造\napollo中的螺旋曲线是弧长-切线角度五次多项式函数：\nθ(s)=a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f\\theta(s) = a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f\nθ(s)=a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f\n由于这种曲线的曲率是弧长的多项式函数，可以在路径规划中很好地控制曲率变化，螺旋曲线的曲率函数为：\nκ=dθds=5a⋅s4+4b⋅s3+3c⋅s2+2d⋅s+e\\kappa = \\frac{d\\theta}{ds} = 5a \\cdot s^4 + 4b\\cdot s^3 + 3c\\cdot s^2 + 2d \\cdot s +e\nκ=dsdθ​=5a⋅s4+4b⋅s3+3c⋅s2+2d⋅s+e\n根据五次多项式数学关系，已知：\n\nθ(0)=x0,θ(p)=x1\\theta(0) = x_0,\\quad \\theta(p) = x_1θ(0)=x0​,θ(p)=x1​​\nθ′(0)=dx0,θ′(p)=dx1\\theta&#x27;(0) = dx_0,\\quad \\theta&#x27;(p) = dx_1θ′(0)=dx0​,θ′(p)=dx1​​\nθ′′(0)=ddx0,θ′′(p)=ddx1\\theta&#x27;&#x27;(0) = ddx_0,\\quad \\theta&#x27;&#x27;(p) = ddx_1θ′′(0)=ddx0​,θ′′(p)=ddx1​​\n\ns(t)=a0+a1t+a2t2+a3t3+a4t4+a5t5s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4 + a_5t^5 \ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4+a5​t5\na0=x0a1=dx0a2=ddx02a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TTa5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{aligned}\na_0 = x_0 \\\\ \na_1 = dx_0 \\\\\na_2 = \\frac{ddx_0}{2} \\\\\na_3 = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\na_4 =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\na_5 =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{aligned}\na0​=x0​a1​=dx0​a2​=2ddx0​​a3​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)a4​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​a5​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n可求得a,b,c,d,e,fa,b,c,d,e,fa,b,c,d,e,f系数，将上述的T=p,a=a5,b=a4,c=a3,d=a2,e=a1,f=a0T=p,a=a_5,b=a_4,c=a_3,d=a_2,e=a_1,f=a_0T=p,a=a5​,b=a4​,c=a3​,d=a2​,e=a1​,f=a0​可得：\na=−6p5⋅x0−3p4⋅dx0−0.5p3⋅ddx0+6p5⋅x1−3p4⋅dx1+0.5p3⋅ddx1b=15p4⋅x0+8p3⋅dx0+1.5p2⋅ddx0−15p4⋅x1+7p3⋅dx1−1p2⋅ddx1c=−10p3⋅x0−6p2⋅dx0−1.5p⋅ddx0+10p3⋅x1−4p2⋅dx1+0.5p⋅ddx1d=0.5ddx0e=dx0f=x0\\begin{aligned}\na = \\frac{-6}{p^5}\\cdot x_0 - \\frac{3}{p^4}\\cdot dx_0- \\frac{0.5}{p^3}\\cdot ddx_0 + \\frac{6}{p^5}\\cdot x_1 - \\frac{3}{p^4}\\cdot dx_1 + \\frac{0.5}{p^3}\\cdot ddx_1 \\\\\n\nb = \\frac{15}{p^4}\\cdot x_0 + \\frac{8}{p^3}\\cdot dx_0 + \\frac{1.5}{p^2}\\cdot ddx_0 - \\frac{15}{p^4}\\cdot x_1 + \\frac{7}{p^3}\\cdot dx_1 - \\frac{1}{p^2}\\cdot ddx_1 \\\\\n\nc = \\frac{-10}{p^3}\\cdot x_0 - \\frac{6}{p^2}\\cdot dx_0 - \\frac{1.5}{p}\\cdot ddx_0 + \\frac{10}{p^3}\\cdot x_1 - \\frac{4}{p^2}\\cdot dx_1 + \\frac{0.5}{p}\\cdot ddx_1 \\\\\n\nd = 0.5ddx_0 \\\\\ne = dx_0 \\\\\nf = x_0\n\\end{aligned}\na=p5−6​⋅x0​−p43​⋅dx0​−p30.5​⋅ddx0​+p56​⋅x1​−p43​⋅dx1​+p30.5​⋅ddx1​b=p415​⋅x0​+p38​⋅dx0​+p21.5​⋅ddx0​−p415​⋅x1​+p37​⋅dx1​−p21​⋅ddx1​c=p3−10​⋅x0​−p26​⋅dx0​−p1.5​⋅ddx0​+p310​⋅x1​−p24​⋅dx1​+p0.5​⋅ddx1​d=0.5ddx0​e=dx0​f=x0​​\n 螺旋曲线笛卡尔坐标变换\n螺旋曲线转化为笛卡尔坐标系，xxx坐标可以将每一段弧长dsdsds投影到xxx方向：ds∗cos(θ)ds*cos(θ)ds∗cos(θ)​​，yyy坐标将每一段弧长dsdsds投影到yyy方向：ds∗sin(θ)ds*sin(θ)ds∗sin(θ)，加上曲线初始状态的x，yx，yx，y​​​值积分得到：\nx(s)=x0+∫0scos(θ(s))dsy(s)=y0+∫0ssin(θ(s))dsx(s) = x_0 + \\int_0^s cos(\\theta(s))ds \\\\\ny(s) = y_0 + \\int_0^s sin(\\theta(s))ds\nx(s)=x0​+∫0s​cos(θ(s))dsy(s)=y0​+∫0s​sin(θ(s))ds\n我们构造螺旋曲线通常都会让初始值x0,y0x_0,y_0x0​,y0​设置为000​，代入高斯积分得到：\nx(s)=s2∑i=1ncos(θ(s2ξi+s2))y(s)=s2∑i=1nsin(θ(s2ξi+s2))x(s) = \\frac{s}{2} \\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\\\\ny(s) = \\frac{s}{2} \\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\\\\nx(s)=2s​i=1∑n​cos(θ(2s​ξi​+2s​))y(s)=2s​i=1∑n​sin(θ(2s​ξi​+2s​))\n 偏导数矩阵\n使用到类变量coef_deriv_\nstd::array&lt;std::array&lt;double, 7&gt;, 6&gt; coef_deriv_;\n用到该系数矩阵的函数：\ndouble DeriveTheta(const size_t param_index, const double delta_s_ratio) const;double DeriveKappaDerivative(const size_t param_index, const double ratio) const;double DeriveDKappaDerivative(const size_t param_index, const double ratio) const;double DeriveD2KappaDerivative(const size_t param_index, const double r) const;      \n用于在螺旋曲线平滑过程中求偏导数用的。\n螺旋曲线平滑算法中定义了555个优化变量：θ,θ′,θ′′,x,y,Δs\\theta,\\theta&#x27;,\\theta&#x27;&#x27;,x,y,\\Delta sθ,θ′,θ′′,x,y,Δs​\n对于每一条螺旋曲线，需要分别对θ(0),θ′(0),θ′′(0),θ(Δs),θ′(Δs),θ′′(Δs)θ(0),θ&#x27;(0),θ&#x27;&#x27;(0),θ(Δs),θ&#x27;(Δs),θ&#x27;&#x27;(Δs)θ(0),θ′(0),θ′′(0),θ(Δs),θ′(Δs),θ′′(Δs)​​(Δs=p\\Delta s = pΔs=p写成θ0,θ0′,θ0′′,θp,θp′,θp′′θ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​)求偏导数。刚才我们介绍了θ(s)\\theta(s)θ(s)可以基于五次多项式通过初始点状态和终止点构造出来。对θ(0)\\theta(0)θ(0)求偏导，也就是上述的x0x_0x0​​：\n∂θ(s)∂θ0=∂θ(s)∂x0=∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)∂x0=−6s5p5+15s4p4+−10s3p3+1\\frac{\\partial \\theta(s)}{\\partial \\theta_0} = \\frac{\\partial \\theta(s)}{\\partial x_0} = \\frac{\\partial( a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f)}{\\partial x_0} = \\frac{-6 s^5}{p^5} + \\frac{15 s^4}{p^4} + \\frac{-10 s^3}{p^3} + 1\n∂θ0​∂θ(s)​=∂x0​∂θ(s)​=∂x0​∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)​=p5−6s5​+p415s4​+p3−10s3​+1\n同理对θ′(0)\\theta&#x27;(0)θ′(0)​求偏导，也就是上述的dx0dx_0dx0​：\n∂θ(s)∂θ0′=∂θ(s)∂dx0=∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)∂dx0=−3s5p4+8s4p3+−6s3p2+s\\frac{\\partial \\theta(s)}{\\partial \\theta&#x27;_0} = \\frac{\\partial \\theta(s)}{\\partial dx_0} = \\frac{\\partial( a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f)}{\\partial dx_0} = \\frac{-3 s^5}{p^4} + \\frac{8 s^4}{p^3} + \\frac{-6 s^3}{p^2} + s\n∂θ0′​∂θ(s)​=∂dx0​∂θ(s)​=∂dx0​∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)​=p4−3s5​+p38s4​+p2−6s3​+s\n同理：\n∂θ(s)∂θ0′′=∂θ(s)∂ddx0=∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)∂ddx0=−0.5s5p3+1.5s4p2+−1.5s3p+0.5s2∂θ(s)∂θ1=∂θ(s)∂x1=∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)∂x1=6s5p5+−15s4p4+10s3p3∂θ(s)∂θ1′=∂θ(s)∂dx1=∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)∂dx1=−3s5p4+7s4p3+−4s3p2∂θ(s)∂θ1′′=∂θ(s)∂ddx1=∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)∂ddx1=0.5s5p3+−1s4p2+0.5s3p\\begin{aligned}\n\\frac{\\partial \\theta(s)}{\\partial \\theta&#x27;&#x27;_0} = \\frac{\\partial \\theta(s)}{\\partial ddx_0} = \\frac{\\partial( a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f)}{\\partial ddx_0} = \\frac{-0.5 s^5}{p^3} + \\frac{1.5 s^4}{p^2} + \\frac{-1.5 s^3}{p} + 0.5s^2 \\\\\n\n\\frac{\\partial \\theta(s)}{\\partial \\theta_1} = \\frac{\\partial \\theta(s)}{\\partial x_1} = \\frac{\\partial( a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f)}{\\partial x_1} = \\frac{6 s^5}{p^5} + \\frac{-15 s^4}{p^4} + \\frac{10 s^3}{p^3} \\\\\n\n\\frac{\\partial \\theta(s)}{\\partial \\theta_1&#x27;} = \\frac{\\partial \\theta(s)}{\\partial dx_1} = \\frac{\\partial( a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f)}{\\partial dx_1} = \\frac{-3 s^5}{p^4} + \\frac{7 s^4}{p^3} + \\frac{-4 s^3}{p^2} \\\\\n\n\\frac{\\partial \\theta(s)}{\\partial \\theta_1&#x27;&#x27;} = \\frac{\\partial \\theta(s)}{\\partial ddx_1} = \\frac{\\partial( a\\cdot s^5 + b\\cdot s^4 + c\\cdot s^3 + d\\cdot s^2 + e\\cdot s + f)}{\\partial ddx_1} = \\frac{0.5 s^5}{p^3} + \\frac{-1 s^4}{p^2} + \\frac{0.5 s^3}{p} \\\\\n\\end{aligned}\n∂θ0′′​∂θ(s)​=∂ddx0​∂θ(s)​=∂ddx0​∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)​=p3−0.5s5​+p21.5s4​+p−1.5s3​+0.5s2∂θ1​∂θ(s)​=∂x1​∂θ(s)​=∂x1​∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)​=p56s5​+p4−15s4​+p310s3​∂θ1′​∂θ(s)​=∂dx1​∂θ(s)​=∂dx1​∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)​=p4−3s5​+p37s4​+p2−4s3​∂θ1′′​∂θ(s)​=∂ddx1​∂θ(s)​=∂ddx1​∂(a⋅s5+b⋅s4+c⋅s3+d⋅s2+e⋅s+f)​=p30.5s5​+p2−1s4​+p0.5s3​​\n可以看出来，coef_deriv_系数矩阵正好对应着a,b,c,d,e,f各次参数的矩阵去掉x0,x0′,x0′′,x1,x1′,x1′′x_0,x_0&#x27;,x_0&#x27;&#x27;,x_1,x_1&#x27;,x_1&#x27;&#x27;x0​,x0′​,x0′′​,x1​,x1′​,x1′′​的参数值，也就是可以归纳为下式（这里遵从apollo中矩阵顺序从低次到高次排序，令p=Δsp=\\Delta sp=Δs）：\nθ(s)=(1ss2s3s4s5)⋅(fedcba)(fedcba)=(100000010000000.5000−10p3−6p2−1.5p10p3−4p20.5p15p48p31.5p2−15p47p3−1p2−6p5−3p4−0.5p36p5−3p40.5p3)⋅(x0dx0ddx0x1dx1ddx1)\\theta(s) = \\begin{pmatrix} 1 &amp; s &amp; s^2 &amp; s^3 &amp; s^4 &amp; s^5 \\end{pmatrix} \\cdot \\begin{pmatrix} \nf \\\\ e \\\\ d \\\\ c \\\\ b \\\\ a\n\\end{pmatrix} \\\\\n\n\\begin{pmatrix} f \\\\ e \\\\ d \\\\ c \\\\ b \\\\ a \\end{pmatrix} \n= \\begin{pmatrix} \n1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 0.5 &amp; 0 &amp; 0 &amp; 0 \\\\\n\\frac{-10}{p^3} &amp; \\frac{-6}{p^2} &amp; \\frac{-1.5}{p} &amp; \\frac{10}{p^3} &amp; \\frac{-4}{p^2} &amp; \\frac{0.5}{p} \\\\\n\\frac{15}{p^4} &amp; \\frac{8}{p^3} &amp; \\frac{1.5}{p^2} &amp; \\frac{-15}{p^4} &amp; \\frac{7}{p^3} &amp; \\frac{-1}{p^2} \\\\\n\\frac{-6}{p^5} &amp; \\frac{-3}{p^4} &amp; \\frac{-0.5}{p^3} &amp; \\frac{6}{p^5} &amp; \\frac{-3}{p^4} &amp; \\frac{0.5}{p^3} \\\\\n\\end{pmatrix} \n\\cdot \\begin{pmatrix} \nx_0 \\\\ dx_0 \\\\ ddx_0 \\\\ x_1 \\\\ dx_1 \\\\ ddx_1\n\\end{pmatrix}\nθ(s)=(1​s​s2​s3​s4​s5​)⋅⎝⎜⎜⎜⎜⎜⎜⎜⎛​fedcba​⎠⎟⎟⎟⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎜⎜⎜⎛​fedcba​⎠⎟⎟⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎜⎜⎛​100p3−10​p415​p5−6​​010p2−6​p38​p4−3​​000.5p−1.5​p21.5​p3−0.5​​000p310​p4−15​p56​​000p2−4​p37​p4−3​​000p0.5​p2−1​p30.5​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎜⎜⎜⎜⎛​x0​dx0​ddx0​x1​dx1​ddx1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\n 偏导函数推导\n 航向角函数求偏导\nθ(s)\\theta(s)θ(s)对θ0,θ0′,θ0′′,θp,θp′,θp′′θ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​​​​偏导上述以及推导完，实际使用中也需要对Δs\\Delta sΔs，也就是ppp​求偏导。\n假设对当前段的螺旋曲线上的点sis_isi​求对于ppp的偏导，其中si=p∗ris_i = p * r_isi​=p∗ri​​\n\n有两部分都与ppp​相关，系数a,b,c,d,e,fa,b,c,d,e,fa,b,c,d,e,f​和si=p⋅ris_i=p\\cdot r_isi​=p⋅ri​\n∂θ(si)∂p=∂θ(p⋅ri)∂p=∂(a⋅(p⋅ri)5+b⋅(p⋅ri)4+c⋅(p⋅ri)3+d⋅(p⋅ri)2+e⋅(p⋅ri)+f)∂p=∂a∂p⋅(p⋅ri)5+a⋅5⋅(p⋅ri)4⋅ri+∂b∂p⋅(p⋅ri)4+b⋅4⋅(p⋅ri)3⋅ri+∂c∂p⋅(p⋅ri)3+c⋅3⋅(p⋅ri)2⋅ri+∂d∂p⋅(p⋅ri)2+d⋅2⋅(p⋅ri)⋅ri+∂e∂p⋅(p⋅ri)+e⋅ri+∂f∂p=∂a∂p⋅s5+a⋅5⋅s4⋅ri+∂b∂p⋅s4+b⋅4⋅s3⋅ri+∂c∂p⋅s3+c⋅3⋅s2⋅ri+∂d∂p⋅s2+d⋅2⋅s⋅ri+∂e∂p⋅s+e⋅ri+∂f∂p\\begin{aligned}\n\\frac{\\partial \\theta(s_i)}{\\partial p} = \\frac{\\partial \\theta(p\\cdot r_i)}{\\partial p} = \\frac{\\partial( a\\cdot (p\\cdot r_i)^5 + b\\cdot (p\\cdot r_i)^4 + c\\cdot (p\\cdot r_i)^3 + d\\cdot (p\\cdot r_i)^2 + e\\cdot (p\\cdot r_i) + f)}{\\partial p} \\\\\n= \\frac{\\partial a}{\\partial p} \\cdot (p\\cdot r_i)^5 + a\\cdot 5 \\cdot (p\\cdot r_i)^4\\cdot r_i +\n  \\frac{\\partial b}{\\partial p} \\cdot (p\\cdot r_i)^4 + b\\cdot 4 \\cdot (p\\cdot r_i)^3\\cdot r_i +\n  \\frac{\\partial c}{\\partial p} \\cdot (p\\cdot r_i)^3 + c\\cdot 3 \\cdot (p\\cdot r_i)^2\\cdot r_i +\n  \\frac{\\partial d}{\\partial p} \\cdot (p\\cdot r_i)^2 + d\\cdot 2 \\cdot (p\\cdot r_i)  \\cdot r_i +\n  \\frac{\\partial e}{\\partial p} \\cdot (p\\cdot r_i)   + e                            \\cdot r_i +\n  \\frac{\\partial f}{\\partial p} \\\\\n= \\frac{\\partial a}{\\partial p} \\cdot s^5 + a\\cdot 5 \\cdot s^4\\cdot r_i +\n  \\frac{\\partial b}{\\partial p} \\cdot s^4 + b\\cdot 4 \\cdot s^3\\cdot r_i +\n  \\frac{\\partial c}{\\partial p} \\cdot s^3 + c\\cdot 3 \\cdot s^2\\cdot r_i +\n  \\frac{\\partial d}{\\partial p} \\cdot s^2 + d\\cdot 2 \\cdot s  \\cdot r_i +\n  \\frac{\\partial e}{\\partial p} \\cdot s   + e                 \\cdot r_i +\n  \\frac{\\partial f}{\\partial p} \\\\\n\\end{aligned}\n∂p∂θ(si​)​=∂p∂θ(p⋅ri​)​=∂p∂(a⋅(p⋅ri​)5+b⋅(p⋅ri​)4+c⋅(p⋅ri​)3+d⋅(p⋅ri​)2+e⋅(p⋅ri​)+f)​=∂p∂a​⋅(p⋅ri​)5+a⋅5⋅(p⋅ri​)4⋅ri​+∂p∂b​⋅(p⋅ri​)4+b⋅4⋅(p⋅ri​)3⋅ri​+∂p∂c​⋅(p⋅ri​)3+c⋅3⋅(p⋅ri​)2⋅ri​+∂p∂d​⋅(p⋅ri​)2+d⋅2⋅(p⋅ri​)⋅ri​+∂p∂e​⋅(p⋅ri​)+e⋅ri​+∂p∂f​=∂p∂a​⋅s5+a⋅5⋅s4⋅ri​+∂p∂b​⋅s4+b⋅4⋅s3⋅ri​+∂p∂c​⋅s3+c⋅3⋅s2⋅ri​+∂p∂d​⋅s2+d⋅2⋅s⋅ri​+∂p∂e​⋅s+e⋅ri​+∂p∂f​​\n∂a∂p=30p6⋅x0+12p5⋅dx0+1.5p4⋅ddx0−30p6⋅x1+12p5⋅dx1−1.5p4⋅ddx1∂b∂p=−60p5⋅x0−24p4⋅dx0−3p3⋅ddx0+60p5⋅x1−21p4⋅dx1+2p3⋅ddx1∂c∂p=30p4⋅x0+12p3⋅dx0+1.5p2⋅ddx0−30p4⋅x1+8p3⋅dx1−0.5p2⋅ddx1∂d∂p=0∂e∂p=0∂f∂p=0\\begin{aligned}\n\\frac{\\partial a}{\\partial p} = \\frac{30}{p^6}\\cdot x_0 + \\frac{12}{p^5}\\cdot dx_0 + \\frac{1.5}{p^4}\\cdot ddx_0 - \\frac{30}{p^6}\\cdot x_1 + \\frac{12}{p^5}\\cdot dx_1 - \\frac{1.5}{p^4}\\cdot ddx_1 \\\\\n\n\\frac{\\partial b}{\\partial p} = \\frac{-60}{p^5}\\cdot x_0 - \\frac{24}{p^4}\\cdot dx_0 - \\frac{3}{p^3}\\cdot ddx_0 + \\frac{60}{p^5}\\cdot x_1 - \\frac{21}{p^4}\\cdot dx_1 + \\frac{2}{p^3}\\cdot ddx_1 \\\\\n\n\\frac{\\partial c}{\\partial p} = \\frac{30}{p^4}\\cdot x_0 + \\frac{12}{p^3}\\cdot dx_0 + \\frac{1.5}{p^2}\\cdot ddx_0 - \\frac{30}{p^4}\\cdot x_1 + \\frac{8}{p^3}\\cdot dx_1 - \\frac{0.5}{p^2}\\cdot ddx_1 \\\\\n\n\\frac{\\partial d}{\\partial p} = 0 \\\\\n\\frac{\\partial e}{\\partial p} = 0 \\\\\n\\frac{\\partial f}{\\partial p} = 0\n\\end{aligned}\n∂p∂a​=p630​⋅x0​+p512​⋅dx0​+p41.5​⋅ddx0​−p630​⋅x1​+p512​⋅dx1​−p41.5​⋅ddx1​∂p∂b​=p5−60​⋅x0​−p424​⋅dx0​−p33​⋅ddx0​+p560​⋅x1​−p421​⋅dx1​+p32​⋅ddx1​∂p∂c​=p430​⋅x0​+p312​⋅dx0​+p21.5​⋅ddx0​−p430​⋅x1​+p38​⋅dx1​−p20.5​⋅ddx1​∂p∂d​=0∂p∂e​=0∂p∂f​=0​\n 曲率函数求偏导\n曲率函数：\nκ(s)=dθ(s)ds=5as4+4bs3+3cs2+2ds+e=(1ss2s3s4)⋅(e2d3c4b5a)\\kappa(s) = \\frac{d\\theta(s)}{ds} = 5as^4 + 4bs^3 + 3cs^2 + 2ds + e \\\\\n= \\begin{pmatrix} 1 &amp; s &amp; s^2 &amp; s^3 &amp; s^4 \\end{pmatrix} \\cdot \\begin{pmatrix} \ne \\\\ 2d \\\\ 3c \\\\ 4b \\\\ 5a\n\\end{pmatrix} \\\\\nκ(s)=dsdθ(s)​=5as4+4bs3+3cs2+2ds+e=(1​s​s2​s3​s4​)⋅⎝⎜⎜⎜⎜⎜⎛​e2d3c4b5a​⎠⎟⎟⎟⎟⎟⎞​\n同理可求κ(s)\\kappa(s)κ(s)对θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p的偏导。\n 曲率变化率的偏导函数\n曲率变化率函数：\nκ′(s)=dκ(s)ds=20as3+12bs2+6cs+2d=(1ss2s3)⋅(2d6c12b20a)\\kappa&#x27;(s) = \\frac{d\\kappa(s)}{ds} = 20as^3 + 12bs^2 + 6cs + 2d \\\\\n= \\begin{pmatrix} 1 &amp; s &amp; s^2 &amp; s^3 \\end{pmatrix} \\cdot \\begin{pmatrix} \n2d \\\\ 6c \\\\ 12b \\\\ 20a\n\\end{pmatrix} \\\\\nκ′(s)=dsdκ(s)​=20as3+12bs2+6cs+2d=(1​s​s2​s3​)⋅⎝⎜⎜⎜⎛​2d6c12b20a​⎠⎟⎟⎟⎞​\n 曲率变化率的变化率的偏导函数\n曲率变化的变化率函数：\nκ′′(s)=dκ′(s)ds=60as2+24bs+6c=(1ss2)⋅(6c24b60a)\\kappa&#x27;&#x27;(s) = \\frac{d\\kappa&#x27;(s)}{ds} = 60as^2 + 24bs + 6c \\\\\n= \\begin{pmatrix} 1 &amp; s &amp; s^2 \\end{pmatrix} \\cdot \\begin{pmatrix} \n6c \\\\ 24b \\\\ 60a\n\\end{pmatrix} \\\\\nκ′′(s)=dsdκ′(s)​=60as2+24bs+6c=(1​s​s2​)⋅⎝⎛​6c24b60a​⎠⎞​\n 笛卡尔坐标的偏导数\nx(s)=s2∑i=1ncos(θ(s2ξi+s2))y(s)=s2∑i=1nsin(θ(s2ξi+s2))x(s) = \\frac{s}{2} \\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\\\\ny(s) = \\frac{s}{2} \\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\\\\nx(s)=2s​i=1∑n​cos(θ(2s​ξi​+2s​))y(s)=2s​i=1∑n​sin(θ(2s​ξi​+2s​))\n分别求x(s),y(s)x(s),y(s)x(s),y(s)​对θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p​​的偏导：\n∂x(s)∂θ0=∂x(s)∂θ⋅∂θ∂θ0=−s2∑i=1nsin(θ(s2ξi+s2))⋅∂θ(s2ξi+s2)∂θ0\\frac{\\partial x(s)}{\\partial \\theta_0} = \\frac{\\partial x(s) }{\\partial \\theta} \\cdot \\frac{\\partial \\theta}{\\partial \\theta_0} = -\\frac{s}{2}\\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\cdot \\frac{\\partial \\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})}{\\partial \\theta_0}\n∂θ0​∂x(s)​=∂θ∂x(s)​⋅∂θ0​∂θ​=−2s​i=1∑n​sin(θ(2s​ξi​+2s​))⋅∂θ0​∂θ(2s​ξi​+2s​)​\n∂y(s)∂θ0=∂y(s)∂θ⋅∂θ∂θ0=s2∑i=1ncos(θ(s2ξi+s2))⋅∂θ(s2ξi+s2)∂θ0\\frac{\\partial y(s)}{\\partial \\theta_0} = \\frac{\\partial y(s) }{\\partial \\theta} \\cdot \\frac{\\partial \\theta}{\\partial \\theta_0}  = \\frac{s}{2}\\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\cdot \\frac{\\partial \\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})}{\\partial \\theta_0}\n∂θ0​∂y(s)​=∂θ∂y(s)​⋅∂θ0​∂θ​=2s​i=1∑n​cos(θ(2s​ξi​+2s​))⋅∂θ0​∂θ(2s​ξi​+2s​)​\n转换成求θ(s2ξi+s2)\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})θ(2s​ξi​+2s​)对θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p​的偏导：\n对ppp​求偏导推导（其中sss也是与ppp相关的）：\n∂x(s)∂p=∂s2∑i=1ncos(θ(s2ξi+s2))∂p=∂s2∂p⋅∑i=1ncos(θ(s2ξi+s2))+s2⋅∂∑i=1ncos(θ(s2ξi+s2))∂p=12∑i=1ncos(θ(s2ξi+s2))+−s2∑i=1nsin(θ(s2ξi+s2))⋅∂θ(s2ξi+s2)∂p\\begin{aligned}\n\\frac{\\partial x(s)}{\\partial p} = \\frac{\\partial  \\frac{s}{2} \\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) }{\\partial p} = \n\\frac{\\partial  \\frac{s}{2} }{\\partial p} \\cdot \\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \n+ \\frac{s}{2} \\cdot \\frac{\\partial   \\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) }{\\partial p} \\\\\n= \\frac{1}{2}\\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) + -\\frac{s}{2}\\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\cdot \\frac{\\partial \\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})}{\\partial p}\n\\end{aligned}\n∂p∂x(s)​=∂p∂2s​∑i=1n​cos(θ(2s​ξi​+2s​))​=∂p∂2s​​⋅i=1∑n​cos(θ(2s​ξi​+2s​))+2s​⋅∂p∂∑i=1n​cos(θ(2s​ξi​+2s​))​=21​i=1∑n​cos(θ(2s​ξi​+2s​))+−2s​i=1∑n​sin(θ(2s​ξi​+2s​))⋅∂p∂θ(2s​ξi​+2s​)​​\n∂y(s)∂p=∂s2∑i=1nsin(θ(s2ξi+s2))∂p=∂s2∂p⋅∑i=1nsin(θ(s2ξi+s2))+s2⋅∂∑i=1nsin(θ(s2ξi+s2))∂p=12∑i=1nsin(θ(s2ξi+s2))+s2∑i=1ncos(θ(s2ξi+s2))⋅∂θ(s2ξi+s2)∂p\\begin{aligned}\n\\frac{\\partial y(s)}{\\partial p} = \\frac{\\partial  \\frac{s}{2} \\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) }{\\partial p} = \n\\frac{\\partial  \\frac{s}{2} }{\\partial p} \\cdot \\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \n+ \\frac{s}{2} \\cdot \\frac{\\partial   \\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) }{\\partial p} \\\\\n= \\frac{1}{2}\\sum_{i=1}^n sin(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) + \\frac{s}{2}\\sum_{i=1}^n cos(\\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})) \\cdot \\frac{\\partial \\theta(\\frac{s}{2}\\xi_i + \\frac{s}{2})}{\\partial p}\n\\end{aligned}\n∂p∂y(s)​=∂p∂2s​∑i=1n​sin(θ(2s​ξi​+2s​))​=∂p∂2s​​⋅i=1∑n​sin(θ(2s​ξi​+2s​))+2s​⋅∂p∂∑i=1n​sin(θ(2s​ξi​+2s​))​=21​i=1∑n​sin(θ(2s​ξi​+2s​))+2s​i=1∑n​cos(θ(2s​ξi​+2s​))⋅∂p∂θ(2s​ξi​+2s​)​​\n 代码实现\n QuinticSpiralPath::QuinticSpiralPath()\ncoef_deriv_[5][0]第一个下标555是表示555次项的系数，第二个下标0，1，2，3，4，50，1，2，3，4，50，1，2，3，4，5依次表示x0,dx0,ddx0,x1,dx1,ddx1x_0,dx_0,ddx_0,x_1,dx_1,ddx_1x0​,dx0​,ddx0​,x1​,dx1​,ddx1​的系数。\ncoef_deriv_[5][6]表示555此项系数对ppp​的求导。\nQuinticSpiralPath::QuinticSpiralPath(const std::array&lt;double, 3&gt;&amp; start,                                     const std::array&lt;double, 3&gt;&amp; end,                                     const double delta_s)    : QuinticSpiralPath(start[0], start[1], start[2], end[0], end[1], end[2],                        delta_s) &#123;&#125;QuinticSpiralPath::QuinticSpiralPath(const double x0, const double dx0,                                     const double ddx0, const double x1,                                     const double dx1, const double ddx1,                                     const double p)    : QuinticPolynomialCurve1d(x0, dx0, ddx0, x1, dx1, ddx1, p) &#123;  CHECK(p &gt; 0.0);  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double p5 = p2 * p3;  double p6 = p3 * p3;  // derive a  // double a = -6.0 * x0 / p5 - 3.0 * dx0 / p4 - 0.5 * ddx0 / p3 + 6.0 * x1 /  // p5 - 3.0 * dx1 / p4 + 0.5 * ddx1 / p3;  coef_deriv_[5][0] = -6.0 / p5;  coef_deriv_[5][1] = -3.0 / p4;  coef_deriv_[5][2] = -0.5 / p3;  coef_deriv_[5][3] = 6.0 / p5;  coef_deriv_[5][4] = -3.0 / p4;  coef_deriv_[5][5] = 0.5 / p3;  coef_deriv_[5][6] = 30.0 * x0 / p6 + 12.0 * dx0 / p5 + 1.5 * ddx0 / p4 -                      30.0 * x1 / p6 + 12.0 * dx1 / p5 - 1.5 * ddx1 / p4;  // derive b  // double b = 15.0 * x0 / p4 + 8.0 * dx0 / p3 + 1.5 * ddx0 / p2 - 15.0 * x1 /  // p4 + 7.0 * dx1 / p3 - ddx1 / p2;  coef_deriv_[4][0] = 15.0 / p4;  coef_deriv_[4][1] = 8.0 / p3;  coef_deriv_[4][2] = 1.5 / p2;  coef_deriv_[4][3] = -15.0 / p4;  coef_deriv_[4][4] = 7.0 / p3;  coef_deriv_[4][5] = -1.0 / p2;  coef_deriv_[4][6] = -60.0 * x0 / p5 - 24.0 * dx0 / p4 - 3.0 * ddx0 / p3 +                      60.0 * x1 / p5 - 21.0 * dx1 / p4 + 2.0 * ddx1 / p3;  // derive c  // double c = -10.0 * x0 / p3 - 6.0 * dx0 / p2 - 1.5 * ddx0 / p + 10.0 * x1 /  // p3 - 4.0 * dx1 / p2 + 0.5 * ddx1 / p;  coef_deriv_[3][0] = -10.0 / p3;  coef_deriv_[3][1] = -6.0 / p2;  coef_deriv_[3][2] = -1.5 / p;  coef_deriv_[3][3] = 10.0 / p3;  coef_deriv_[3][4] = -4.0 / p2;  coef_deriv_[3][5] = 0.5 / p;  coef_deriv_[3][6] = 30.0 * x0 / p4 + 12.0 * dx0 / p3 + 1.5 * ddx0 / p2 -                      30.0 * x1 / p4 + 8.0 * dx1 / p3 - 0.5 * ddx1 / p2;  // derive d  // double d = 0.5 * ddx0;  coef_deriv_[2][0] = 0.0;  coef_deriv_[2][1] = 0.0;  coef_deriv_[2][2] = 0.5;  coef_deriv_[2][3] = 0.0;  coef_deriv_[2][4] = 0.0;  coef_deriv_[2][5] = 0.0;  coef_deriv_[2][6] = 0.0;  // derive e  // double e = dx0;  coef_deriv_[1][0] = 0.0;  coef_deriv_[1][1] = 1.0;  coef_deriv_[1][2] = 0.0;  coef_deriv_[1][3] = 0.0;  coef_deriv_[1][4] = 0.0;  coef_deriv_[1][5] = 0.0;  coef_deriv_[1][6] = 0.0;  // derive f  // double f = x0;  coef_deriv_[0][0] = 1.0;  coef_deriv_[0][1] = 0.0;  coef_deriv_[0][2] = 0.0;  coef_deriv_[0][3] = 0.0;  coef_deriv_[0][4] = 0.0;  coef_deriv_[0][5] = 0.0;  coef_deriv_[0][6] = 0.0;&#125;\n ComputeCartesianDeviationX()和ComputeCartesianDeviationY()\n求x(s),y(s)x(s),y(s)x(s),y(s)\ntemplate &lt;size_t N&gt;double ComputeCartesianDeviationX(const double s) const &#123;  auto cos_theta = [this](const double s) &#123;    const auto a = Evaluate(0, s); // Evaluate是父函数 五次多项式的类函数，求角度    return std::cos(a);  &#125;;  return common::math::IntegrateByGaussLegendre&lt;N&gt;(cos_theta, 0.0, s);&#125;template &lt;size_t N&gt;double ComputeCartesianDeviationY(const double s) const &#123;  auto sin_theta = [this](const double s) &#123;    const auto a = Evaluate(0, s);    return std::sin(a);  &#125;;  return common::math::IntegrateByGaussLegendre&lt;N&gt;(sin_theta, 0.0, s);&#125;\n QuinticSpiralPath::DeriveTheta()\n求θ(s)\\theta(s)θ(s)​对优化变量θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p​​的偏导。\ndouble QuinticSpiralPath::DeriveTheta(const size_t param_index,                                      const double r) const &#123;  double s = param_ * r; // r是比例系数，param_是p，也就是delta_s  double s2 = s * s;  double s3 = s2 * s;  double s4 = s2 * s2;  double s5 = s3 * s2;  double derivative =      coef_deriv_[5][param_index] * s5 + coef_deriv_[4][param_index] * s4 +      coef_deriv_[3][param_index] * s3 + coef_deriv_[2][param_index] * s2 +      coef_deriv_[1][param_index] * s + coef_deriv_[0][param_index];  if (param_index == DELTA_S) &#123;    derivative += coef_[5] * 5.0 * s4 * r + coef_[4] * 4.0 * s3 * r +                  coef_[3] * 3.0 * s2 * r + coef_[2] * 2.0 * s * r +                  coef_[1] * r;  &#125;  return derivative;&#125;\n// param_index表示求偏导的变量，如下所示，0和1分别表示了螺旋曲线的起点和终点  static const size_t THETA0 = 0;  static const size_t KAPPA0 = 1;  static const size_t DKAPPA0 = 2;  static const size_t THETA1 = 3;  static const size_t KAPPA1 = 4;  static const size_t DKAPPA1 = 5;  static const size_t DELTA_S = 6;\n QuinticSpiralPath::DeriveKappaDerivative()\n求κ(s)\\kappa(s)κ(s)​对优化变量θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p​的偏导。\ndouble QuinticSpiralPath::DeriveKappaDerivative(const size_t param_index,                                                const double r) const &#123;  double s = param_ * r;  double s2 = s * s;  double s3 = s2 * s;  double s4 = s2 * s2;  double derivative = 5.0 * coef_deriv_[5][param_index] * s4 +                      4.0 * coef_deriv_[4][param_index] * s3 +                      3.0 * coef_deriv_[3][param_index] * s2 +                      2.0 * coef_deriv_[2][param_index] * s +                      coef_deriv_[1][param_index];  if (param_index == DELTA_S) &#123;    derivative += 5.0 * coef_[5] * 4.0 * s3 * r +                  4.0 * coef_[4] * 3.0 * s2 * r + 3.0 * coef_[3] * 2.0 * s * r +                  2.0 * coef_[2] * r;  &#125;  return derivative;&#125;\n QuinticSpiralPath::DeriveDKappaDerivative()\n求κ′(s)\\kappa&#x27;(s)κ′(s)​对优化变量θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p​的偏导。\ndouble QuinticSpiralPath::DeriveDKappaDerivative(const size_t param_index,                                                 const double r) const &#123;  double s = param_ * r;  double s2 = s * s;  double s3 = s2 * s;  double derivative = 20.0 * coef_deriv_[5][param_index] * s3 +                      12.0 * coef_deriv_[4][param_index] * s2 +                      6.0 * coef_deriv_[3][param_index] * s +                      2.0 * coef_deriv_[2][param_index];  if (param_index == DELTA_S) &#123;    derivative += 20.0 * coef_[5] * 3.0 * s2 * r +                  12.0 * coef_[4] * 2.0 * s * r + 6.0 * coef_[3] * r;  &#125;  return derivative;&#125;\n QuinticSpiralPath::DeriveD2KappaDerivative()\n求κ′′(s)\\kappa&#x27;&#x27;(s)κ′′(s)​对优化变量θ0,θ0′,θ0′′,θp,θp′,θp′′,pθ_0,θ&#x27;_0,θ&#x27;&#x27;_0,θ_p,θ&#x27;_p,θ&#x27;&#x27;_p,pθ0​,θ0′​,θ0′′​,θp​,θp′​,θp′′​,p​的偏导。\ndouble QuinticSpiralPath::DeriveD2KappaDerivative(const size_t param_index,                                                  const double r) const &#123;  double s = param_ * r;  double s2 = s * s;  double derivative = 60.0 * coef_deriv_[5][param_index] * s2 +                      24.0 * coef_deriv_[4][param_index] * s +                      6.0 * coef_deriv_[3][param_index];  if (param_index == DELTA_S) &#123;    derivative += 60.0 * coef_[5] * 2.0 * s * r + 24.0 * coef_[4] * r;  &#125;  return derivative;&#125;\n DeriveCartesianDeviation()\ntemplate &lt;size_t N&gt;std::pair&lt;double, double&gt; DeriveCartesianDeviation(    const size_t param_index) const &#123;    auto gauss_points = common::math::GetGaussLegendrePoints&lt;N&gt;();    std::array&lt;double, N&gt; x = gauss_points.first;    std::array&lt;double, N&gt; w = gauss_points.second;    std::pair&lt;double, double&gt; cartesian_deviation = &#123;0.0, 0.0&#125;; // 表示(dx/d , dy/d )    for (size_t i = 0; i &lt; N; ++i) &#123;        double r = 0.5 * x[i] + 0.5;        auto curr_theta = Evaluate(0, r * param_);        double derived_theta = DeriveTheta(param_index, r);        cartesian_deviation.first +=            w[i] * (-std::sin(curr_theta)) * derived_theta;        cartesian_deviation.second += w[i] * std::cos(curr_theta) * derived_theta;    &#125;    cartesian_deviation.first *= param_ * 0.5;    cartesian_deviation.second *= param_ * 0.5;    if (param_index == DELTA_S) &#123;        for (size_t i = 0; i &lt; N; ++i) &#123;            double r = 0.5 * x[i] + 0.5;            auto theta_angle = Evaluate(0, r * param_);            cartesian_deviation.first += 0.5 * w[i] * std::cos(theta_angle);            cartesian_deviation.second += 0.5 * w[i] * std::sin(theta_angle);        &#125;    &#125;    return cartesian_deviation;&#125;\n","categories":["算法","Apollo源码解读"]},{"title":"CyberRT自定义部署流程 之 从零搭建交叉编译Docker镜像","url":"/2025/07/08/CyberRT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E4%B9%8B%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91Docker%E9%95%9C%E5%83%8F/","content":"本文章主要提供思路，许多地方都可以根据自定义修改以适配自己的实际情况。\n\n 准备好目标平台的交叉编译工具\n存放在toolchains/文件夹下。\n这个根据自己项目需求，网上或者找厂家获取交叉编译工具。\n比如：\n\n 准备好依赖库\n 依赖库是二进制库\n存放在sysroot/文件夹下。\n最好一份是x86，一份是目标平台。\n\n 依赖库是源码\n以压缩包形式存放在thirdparty/tarball/文件夹下。\n\n CyberRT v9.0.0版本依赖库\n\n本人梳理了CyberRT v9.0.0版本的依赖库，并从下载地址以压缩包形式下载下来：\n\nfast-rtps-1.5.0\nFast-CDR源码地址\nFast-DDS/Fast-rtps源码地址\n注意：不能使用源码库安装，不适配CyberRT，见talker listener 不能配通信 #115\n；需要使用作者提供的预编译库。\nncurses-6.4（源码压缩包）\nncurses源码地址\nutil-linux-2.39（源码压缩包）\nutil-linux源码地址\nglog（通过git拉取源码）源码地址\nnlohmann_json（通过git拉取源码）源码地址\npython源码压缩包地址\nprotobuf源码压缩包地址\n\n 搭建Docker镜像\n 创建docker_release_xcyber.sh脚本\n该脚本用于一键创建镜像，bash docker_release_xcyber.sh。\n#!/usr/bin/env bash# 自定义镜像名字DOCKER_REGISTRY=i-nogIMAGE_REPO=nog-cyber-kitIMAGE_TAG=$&#123;1:-&quot;1.1.0&quot;&#125;PLATFORM_X86=x86PLATFORM_ORIN=orin# 镜像名称ORIN_IMAGE_REPO=$&#123;DOCKER_REGISTRY&#125;/$&#123;IMAGE_REPO&#125;/plat_$&#123;PLATFORM_ORIN&#125;_devTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;# 指定dockerfile文件DOCKERFILE_ORIN_XCYBER=$&#123;TOP_DIR&#125;/dockerfile/Dockerfile.orin.xcyber# 创建一个文件夹，专门用于docker镜像构建的上下文CYBER_KIT=$&#123;TOP_DIR&#125;/cyber-kitORIN_IMAGE_CONTEXT=$&#123;CYBER_KIT&#125;-$&#123;PLATFORM_ORIN&#125;# 在上下文中创建所需文件夹，用于存放库和工具链mkdir -p $&#123;ORIN_IMAGE_CONTEXT&#125;/&#123;sysroot,toolchains&#125;echo &quot;=== prepare cyber-kit files for x86 ... ===&quot;# 压缩已有的 x86 版本的系统库，并拷贝到上下文中cd $&#123;TOP_DIR&#125;/sysroottar czf $&#123;PLATFORM_X86&#125;.tar.gz $&#123;PLATFORM_X86&#125;cp $&#123;PLATFORM_X86&#125;.tar.gz $&#123;ORIN_IMAGE_CONTEXT&#125;/sysrootecho &quot;=== prepare cyber-kit files for x86 done ===&quot;echo &quot;=== prepare cyber-kit files for ORIN ... ===&quot;# 压缩已有的 orin 版本的系统库，并拷贝到上下文中cd $&#123;TOP_DIR&#125;/sysroottar czf $&#123;PLATFORM_ORIN&#125;.tar.gz $&#123;PLATFORM_ORIN&#125;mv $&#123;PLATFORM_ORIN&#125;.tar.gz $&#123;ORIN_IMAGE_CONTEXT&#125;/sysroot# 拷贝交叉编译工具链cp -r $&#123;TOP_DIR&#125;/&#123;cmake,scripts&#125; $&#123;ORIN_IMAGE_CONTEXT&#125;cp -r $&#123;TOP_DIR&#125;/toolchains/$&#123;PLATFORM_ORIN&#125; $&#123;ORIN_IMAGE_CONTEXT&#125;/toolchainsecho &quot;=== prepare cyber-kit files for ORIN done ===&quot;# 删除压缩包cd $&#123;TOP_DIR&#125;/sysrootrm *.gzecho &quot;=== build platform orin docker images ... ===&quot;# 基于dockerfile文件创建镜像docker build --network=host \\    --build-arg platform=$&#123;PLATFORM_ORIN&#125; \\    --build-arg plat_version_value=$&#123;IMAGE_TAG&#125; \\    # 同时打两个标签（版本号和latest）    -t $&#123;ORIN_IMAGE_REPO&#125;:$&#123;IMAGE_TAG&#125; -t $&#123;ORIN_IMAGE_REPO&#125;:latest \\    -f $DOCKERFILE_ORIN_XCYBER $ORIN_IMAGE_CONTEXTecho &quot;=== build platform orin docker images done ===&quot;# 创建镜像成功，删除上下文rm -rf $ORIN_IMAGE_CONTEXT\n 创建Dockerfile.orin.xcyber\n操作的内容都是在上下文里面。\nFROM ubuntu:20.04# 传入参数ARG platformARG plat_version_valueARG DEBIAN_FRONTEND=noninteractiveUSER root # 以下指令使用root权限# stage 1: install dev and debug tools# 安装必备的基础工具，根据实际需求需要RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends build-essential cmake \\    pkg-config flex bison autoconf m4 gdb sudo file ca-certificates lsb-release git vim \\    bash-completion &amp;&amp; update-ca-certificates &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libpng-dev libjpeg-dev \\    libopenblas-dev libeigen3-dev libtbb-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libavcodec-dev \\    libavformat-dev libswscale-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgstreamer1.0-dev \\    libgstreamer-plugins-base1.0-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgtk-3-0 librsvg2-2 libgvc6 \\    openscenegraph &amp;&amp; apt-get clean## Set a passwordless sudoer user# 创建一个无密码用户RUN adduser --disabled-password --gecos &quot;&quot; autometa &amp;&amp; usermod -aG sudo autometa &amp;&amp; \\    mkdir -p /etc/sudoers.d &amp;&amp; touch /etc/sudoers.d/nopasswd &amp;&amp; \\    echo &quot;autometa ALL=(ALL) NOPASSWD: ALL&quot; &gt; /etc/sudoers.d/nopasswd# fix LANG for displaying Chinese textRUN echo &quot;export LANG=C.UTF-8&quot; &gt;&gt; $&#123;HOME&#125;/.bashrc# stage 2: add cyber-kitRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;mkdir -p /opt/cyber-kit/&#123;cmake,scripts,sysroot,toolchains&#125;&quot;]# 拷贝目标平台的工具链COPY toolchains /opt/cyber-kit/toolchains# 这里其实只拷贝 x86 的系统库ADD sysroot/$&#123;x86&#125;.tar.gz /opt/cyber-kit/sysrootADD sysroot/$&#123;platform&#125;.tar.gz /opt/cyber-kit/sysroot# setup toolchains# 拷贝工具链环境配置脚本，并执行，这里使用root权限COPY scripts/setup.sh /opt/cyber-kit/scripts# 主要就是配置环境变量，及解压目标平台的交叉编译工具链RUN /opt/cyber-kit/scripts/setup.sh# update cmake files &amp; scriptsCOPY cmake /opt/cyber-kit/cmakeCOPY scripts /opt/cyber-kit/scripts# setup env for user autometaUSER autometa# 使用用户权限，再执行一遍工具链环境配置脚本RUN /opt/cyber-kit/scripts/setup.sh# git config settings# 配置git命令简写RUN git config --global alias.ci commit &amp;&amp; \\    git config --global alias.co checkout &amp;&amp; \\    git config --global alias.br branch &amp;&amp; \\    git config --global alias.st status &amp;&amp; \\    git config --global alias.au add -u &amp;&amp; \\    git config --global alias.ca commit --amend &amp;&amp; \\    git config --global core.editor vim# set plat versionENV PLAT_VERSION &quot;$&#123;plat_version_value&#125;&quot;# docker start command or argsCMD [&quot;bash&quot;]\n\n\n由于拉取基础镜像要联网，有时不好拉取，所以可以把基础镜像先保存起来：\n  docker save -o ubuntu-20.04-base.tar ubuntu:20.04\n\n\n载入镜像\n  docker load -i ubuntu-20.04-base.tar\n\n\n 创建setup.sh环境配置脚本\n#!/usr/bin/env bashplatform_array=(all xavier rk356x orin cv22)usage()&#123;cat &lt;&lt; EOFUsage: $1 &lt;platform&gt;platform: [$&#123;platform_array[*]&#125;]EOF&#125;platform=$&#123;1:-&quot;all&quot;&#125;echo &quot;platform: $platform&quot;platform_valid=falsefor target in $&#123;platform_array[@]&#125;do    if [ x$target = x$platform ]; then        platform_valid=true    fidoneif ! $&#123;platform_valid&#125;; then    echo &quot;platform is not valid&quot;    usage $&#123;BASH_SOURCE[0]&#125;        if [ $0 = $&#123;BASH_SOURCE[0]&#125; ]; then        exit -1    else        return -1    fifiKIT_PATH=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;/ORIGIN_KIT_PATH=$CYBER_KIT_PATHecho &quot;New cyber kit path is : $&#123;KIT_PATH&#125;&quot;echo &quot;Origin cyber kit path is : $&#123;ORIGIN_KIT_PATH&#125;&quot;HOST_ARCH=$(arch)if [[ $&#123;KIT_PATH&#125; != $&#123;ORIGIN_KIT_PATH&#125; ]]; then    echo &quot;*** The Cyber Kit Path is not set or changed!, Now setting...&quot;    BASH_RC=$&#123;HOME&#125;/.bashrc    touch $BASH_RC    sed -i &#x27;/CYBER_KIT_PATH/d&#x27; $&#123;BASH_RC&#125;    echo &quot;export CYBER_KIT_PATH=$&#123;KIT_PATH&#125;&quot; &gt;&gt; $BASH_RC    if [ $&#123;HOST_ARCH&#125; = &quot;x86&quot; ]; then        echo &#x27;export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/bin&#x27; &gt;&gt; $BASH_RC        echo &#x27;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib&#x27; &gt;&gt; $BASH_RC        if [ $platform = &quot;orin&quot; ]; then            echo &#x27;export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/orin/bin&#x27; &gt;&gt; $BASH_RC            echo &#x27;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/orin/lib&#x27; &gt;&gt; $BASH_RC        fi    fi    source $BASH_RC    echo &quot;*** The Poseidon Kit Path env setting done&quot;fi# unpack and install different platform cross toolchains# check whether the tar file need to be unpackif [ $&#123;HOST_ARCH&#125; = &quot;aarch64&quot; ]; then    echo &quot;The host arch is : $&#123;HOST_ARCH&#125;, do not need to unpack cross compile toolchains.&quot;        if [ $0 = $&#123;BASH_SOURCE[0]&#125; ]; then        exit 0    else        return 0    fifiecho &quot;The host arch is : $&#123;HOST_ARCH&#125;, need to unpack cross compile toolchains.&quot;# orinORIN_GCC_NAME=aarch64--glibc--stable-finalORIN_TOOLCHAIN_FILE=$&#123;KIT_PATH&#125;/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;.tar.gzif [ -f $ORIN_TOOLCHAIN_FILE ] &amp;&amp; [[ $platform = &quot;all&quot; || $platform = &quot;orin&quot; ]]; then    if [ ! -d  /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125; ]; then        echo -e &quot;\\e[33m############### orin: unpack ###############\\e[0m&quot;        sudo mkdir -p /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;        sudo tar -xvf $ORIN_TOOLCHAIN_FILE -C /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;        echo -e &quot;\\e[33m############### orin: unpack done ###############\\e[0m&quot;    else        echo &quot;The orin platform cross compile toolchains is already exists.&quot;    fifi\n整个流程里首次配置环境变量 CYBER_KIT_PATH。\n# docker 容器里 $&#123;HOME&#125;/.bashrcexport CYBER_KIT_PATH=/opt/cyber-kit/export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/binexport LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib\n （交叉）编译依赖库\n创建build_thirdparty.sh用于编译所需依赖库。\n# 编译安装指定版本的依赖库bash build_thirdparty.sh x86bash build_thirdparty.sh orin\n#!/usr/bin/env bashset -o errexit# 这里是这两个依赖库为例GLOG_SOURCE=glog-0.4.0NLOHMANN_JSON_SOURCE=json-3.12.0target_array=(x86 rk356x orin)BUILD_TARGET=x86if [ $# -gt 0 ]; then    BUILD_TARGET=$1else    echo -e &quot;\\e[33m* target arch not given ($&#123;target_array[*]&#125;), use x86 as default!\\e[0m&quot;fitarget_valid=falsefor target in $&#123;target_array[@]&#125;do    if [ x$&#123;BUILD_TARGET&#125; = x$target ]; then        target_valid=true    fidoneif ! $&#123;target_valid&#125;; then    echo -e &quot;\\e[33m* target arch should be in ($&#123;target_array[*]&#125;)\\e[0m&quot;    exit -1fiecho &quot;* BUILD_TARGET=$&#123;BUILD_TARGET&#125;&quot;# 1 setup toolchainecho -e &quot;\\e[33m=== setup toolchain ===\\e[0m&quot;if $&#123;BUILD_TARGET&#125; = &quot;orin&quot; ]; then    COMPILER_PATH=/opt/toolchains/orin/aarch64--glibc--stable-final/bin    TARGET_HOST=aarch64-buildroot-linux-gnu    COMPILER_PREFIX=aarch64-linux-fiexport PATH=$&#123;COMPILER_PATH&#125;:$&#123;PATH&#125;export CROSS_COMPILE=$&#123;COMPILER_PREFIX&#125;# 2 build packagesecho -e &quot;\\e[33m=== build packages ===\\e[0m&quot;TOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;## 指定安装目录和目标平台的cmake文件export CYBER_KIT_PATH=/opt/cyber-kit/INSTALL_PREFIX=$&#123;CYBER_KIT_PATH&#125;sysroot/$BUILD_TARGETTOOLCHAIN_FILE=$&#123;CYBER_KIT_PATH&#125;cmake/sysroot/$&#123;BUILD_TARGET&#125;.cmakeexport PKG_CONFIG_PATH=$&#123;INSTALL_PREFIX&#125;/share/pkgconfig:$&#123;INSTALL_PREFIX&#125;/lib/pkgconfigTHIRDPARTY_DIR=$&#123;TOP_DIR&#125;/thirdpartyPROGRESS_FILE=$&#123;THIRDPARTY_DIR&#125;/build-log.conftouch $PROGRESS_FILEcd $THIRDPARTY_DIR## glogif [[ $(cat $&#123;PROGRESS_FILE&#125; | grep $&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125;) ]]; then    echo &quot;$&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125; already build&quot;else    rm -rf $GLOG_SOURCE    tar xf tarball/$&#123;GLOG_SOURCE&#125;.tar.gz &amp;&amp; cd $GLOG_SOURCE    mkdir -p build-$&#123;BUILD_TARGET&#125; &amp;&amp; cd build-$&#123;BUILD_TARGET&#125;        # 使用新的 C++11 ABI（默认 GCC 5+ 的行为）    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\    -DCMAKE_POSITION_INDEPENDENT_CODE=ON \\    -DBUILD_SHARED_LIBS=ON \\    -DCMAKE_CXX_FLAGS=-D_GLIBCXX_USE_CXX11_ABI=1 \\    -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; ..    make -j$(nproc) install &amp;&amp; echo $&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125; &gt;&gt; $PROGRESS_FILE        cd ../..fi## nlohmann jsonif [[ $(cat $&#123;PROGRESS_FILE&#125; | grep $&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125;) ]]; then    echo &quot;$&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125; already build&quot;else    rm -rf $NLOHMANN_JSON_SOURCE    tar xf tarball/$&#123;NLOHMANN_JSON_SOURCE&#125;.tar.gz &amp;&amp; cd $NLOHMANN_JSON_SOURCE    mkdir -p build-$&#123;BUILD_TARGET&#125; &amp;&amp; cd build-$&#123;BUILD_TARGET&#125;        # 使用新的 C++11 ABI（默认 GCC 5+ 的行为）    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\    -DBUILD_SHARED_LIBS=ON \\    -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; ..    make -j$(nproc) install &amp;&amp; echo $&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125; &gt;&gt; $PROGRESS_FILE        cd ../..firm -rf $GLOG_SOURCErm -rf $NLOHMANN_JSON_SOURCEecho &quot;all done !&quot;\n orin.cmake文件分析\n交叉编译使用到该脚本，主要用于指定编译器以及编译根目录。\nif(NOT DEFINED ENV&#123;CYBER_KIT_PATH&#125;)    message(FATAL_ERROR &quot;Environment \\&quot;CYBER_KIT_PATH\\&quot; not set!&quot;)endif()set(TARGET_ARCH aarch64)set(TARGET_PLATFORM orin)set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR aarch64)set(HOST_PROCESSOR $&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125;)set(TOOLCHAIN_ROOT /usr)if($&#123;HOST_PROCESSOR&#125; STREQUAL &quot;x86_64&quot;)    set(TOOLCHAIN_ROOT /opt/toolchains/orin/aarch64--glibc--stable-final)    set(CROSS_COMPILE aarch64-linux-)endif()set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_ROOT&#125;/bin/$&#123;CROSS_COMPILE&#125;gcc)set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_ROOT&#125;/bin/$&#123;CROSS_COMPILE&#125;g++)set(CMAKE_FIND_ROOT_PATH $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin)if($&#123;HOST_PROCESSOR&#125; STREQUAL &quot;x86_64&quot;)    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)else()    set(CMAKE_SYSROOT /)    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)endif()set(CYBER_SYSROOT_LIB_DIR $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin/lib)set(CYBER_SYSROOT_INCLUDE_DIR $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin/include)\n 重新保存镜像\ndocker commit d063a8a6bdd5 i-nog/nog-cyber-kit/plat_orin_dev:v1.1.0\n工作区的改动会被保存进新镜像，前提是这些改动是在容器的文件系统内进行的。\n\n\n✅ 情况 1：改动在容器内部\n如果你在容器中运行了如下操作：\n  cd /workspaceapt install ...touch somefile.txtpip install ...\n然后执行：\n  docker commit &lt;容器名&gt; &lt;镜像名&gt;\n这些文件、安装的软件、代码改动 都会被保存进新镜像 ✅。\n\n\n❌ 情况 2：挂载的目录（如-v $&#123;WORK_DIR&#125;:/workspace）\n如果启动容器时使用了：\n  -v $&#123;WORK_DIR&#125;:/workspace\n则：\n\n/workspace实际是宿主机的目录；\n改动发生在宿主机，不属于容器文件系统；\ndocker commit不会保存这些改动 ❌。\n\n\n\n📌 举例说明\n\n有挂载：  docker run -v /home/lxp/code:/workspace ...\n你在容器内/workspace修改的所有内容，其实是修改的宿主机/home/lxp/code，不属于容器，docker commit不会打包它。\n无挂载（纯容器内）：  docker run ...# 没有 -v /workspace\n创建或修改/workspace的文件，commit后会保存在镜像里。\n\n","categories":["CyberRT中间件"]},{"title":"CyberRT自定义部署流程 之 部署cyber Cmake工程","url":"/2025/07/11/CyberRT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E4%B9%8B%E9%83%A8%E7%BD%B2cyber%20Cmake%E5%B7%A5%E7%A8%8B/","content":"CyberRT编译原本是基于Bazel，但入行以来都是基于Cmake搭建编译工程，所以更习惯用Cmake搭建工程。\nCmake工程搭建可以参考Baidu Apollo CyberRT Framework CMake Build。不过个人项目操作逻辑不一致，所以对其进行了魔改。\n\n CyberRT工程创建\n将CyberRT源码拷贝到自定义目录下，比如nog-cyber-kit。\n 进入构建好的镜像\n在工程目录下创建进入镜像脚本enter_docker.sh，脚本如下：\n#!/bin/bashplatform_array=(rk356x orin orin_cuda all all_cuda)usage()&#123;cat &lt;&lt; EOFUsage: $1 &lt;platform&gt; [docker_image_tag]platform: [$&#123;platform_array[*]&#125;]docker_image_tag: default is latestEOF&#125;log_highlight()&#123;    echo -e &quot;\\e[30;31m&quot;$1&quot;$(tput sgr0)&quot;&#125;if [[ $# -lt 1 || $1 == &quot;-h&quot; || $1 == &quot;--help&quot; ]]; then    usage $0    exit 0fiplatform=$&#123;1-&quot;xavier&quot;&#125;echo &quot;platform: $platform&quot;platform_valid=falsefor target in $&#123;platform_array[@]&#125;do    if [ x$platform = x$target ]; then        platform_valid=true    fidoneif ! $&#123;platform_valid&#125;; then    echo &quot;platform is not valid&quot;    usage $0    exit -1fi# sudo apt install x11-xserver-utilsxhost +docker_image_tag=$&#123;2-&quot;latest&quot;&#125;docker_image_repo=&quot;i-nog/nog-cyber-kit/plat_$&#123;platform&#125;_dev&quot;machine_name=plat-$&#123;platform&#125;-$&#123;docker_image_tag&#125;machine_id=`docker ps -a -q -f name=$&#123;machine_name&#125;`if [[ $&#123;machine_id&#125; != &#x27;&#x27; ]]; then    log_highlight &quot;Enter docker: $&#123;machine_name&#125;/$&#123;machine_id&#125; ...&quot;    docker start $&#123;machine_id&#125;    docker exec -it $&#123;machine_id&#125; /bin/bashelse    WORK_DIR=$PWD    docker_image_url=$&#123;docker_image_repo&#125;:$&#123;docker_image_tag&#125;    log_highlight &quot;Run docker from $&#123;docker_image_url&#125;&quot;    docker run  -it --privileged \\      --name $&#123;machine_name&#125; --net=host -v /dev:/dev \\      -v $&#123;WORK_DIR&#125;:/workspace -w /workspace \\      -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY \\      -v /media:/media \\      --gpus all \\      $&#123;docker_image_url&#125;fi\nbash enter_docker.sh orin v1.1.0进入容器。\n 顶层CMakeLists.txt\n根据自己项目修改：\ncmake_minimum_required(VERSION 3.5.1)project(cyber VERSION 9.0.0)set(TARGET_NAME $&#123;PROJECT_NAME&#125;)include(&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../cmake/nog.cmake&quot;)if(NOT CMAKE_BUILD_TYPE)  set(CMAKE_BUILD_TYPE Debug)endif()enable_language(ASM)# Use ccache if availablefind_program(CCACHE_FOUND ccache)if(CCACHE_FOUND)  message(STATUS &quot;### use ccache&quot;)  set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)  set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)endif()# PIC flagsset(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fPIC&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fPIC&quot;)# Architecture-specific assembly fileif(CMAKE_SYSTEM_PROCESSOR STREQUAL &quot;x86_64&quot;)  set(CROUTINE_FILE &quot;cyber/croutine/detail/swap_x86_64.S&quot;)else()  set(CROUTINE_FILE &quot;cyber/croutine/detail/swap_aarch64.S&quot;)endif()message(&quot;### SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125; $&#123;CROUTINE_FILE&#125;&quot;)set(CYBER_PYTHON_PATH &quot;lib/python$&#123;Python_VERSION&#125;/site-packages/cyber/python&quot;)set(CYBER_PYTHON_INTERNAL_PATH &quot;$&#123;CYBER_PYTHON_PATH&#125;/internal&quot;)set(CYBER_PYTHON_PROTOBUF_PATH &quot;lib/python$&#123;Python_VERSION&#125;/site-packages/cyber/proto&quot;)# Add include directoriesinclude_directories(  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;  $&#123;CMAKE_BINARY_DIR&#125;)file(GLOB CYBER_PROTO_FILES  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/proto/*.proto&quot;  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/examples/proto/*.proto&quot;)# Only generate proto files onceset(CYBER_MSGS_CACHE ON CACHE BOOL &quot;generate cyber proto msgs flag.&quot; FORCE)if(CYBER_MSGS_CACHE)  message(STATUS &quot;Generating proto files...&quot;)  foreach(FIL $&#123;CYBER_PROTO_FILES&#125;)    message(&quot;### generate proto file: $&#123;FIL&#125;&quot;)    execute_process(      COMMAND $&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;      -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;      --cpp_out=$&#123;CMAKE_BINARY_DIR&#125;      --python_out=$&#123;CMAKE_BINARY_DIR&#125;      $&#123;FIL&#125;    )  endforeach()  # Avoid regenerating in subsequent runs  set(CYBER_MSGS_CACHE OFF CACHE BOOL &quot;generate cyber proto msgs flag.&quot; FORCE)endif()file(GLOB CYBER_PROTO_SRCS  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/*.pb.cc&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/*.pb.h&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/*.pb.cc&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/*.pb.h&quot;)file(GLOB CYBER_SRCS  &quot;cyber/base/*.cc&quot;  &quot;cyber/blocker/*.cc&quot;  &quot;cyber/class_loader/*.cc&quot;  &quot;cyber/class_loader/*/*.cc&quot;  &quot;cyber/common/*.cc&quot;  &quot;cyber/component/*.cc&quot;  &quot;cyber/croutine/*.cc&quot;  &quot;cyber/croutine/*/*.cc&quot;  &quot;cyber/data/*.cc&quot;  &quot;cyber/event/*.cc&quot;  &quot;cyber/io/*.cc&quot;  &quot;cyber/logger/*.cc&quot;  &quot;cyber/message/*.cc&quot;  &quot;cyber/node/*.cc&quot;  &quot;cyber/parameter/*.cc&quot;  &quot;cyber/plugin_manager/*.cc&quot;  &quot;cyber/record/*.cc&quot;  &quot;cyber/record/*/*.cc&quot;  &quot;cyber/scheduler/*.cc&quot;  &quot;cyber/scheduler/*/*.cc&quot;  &quot;cyber/service/*.cc&quot;  &quot;cyber/service_discovery/*.cc&quot;  &quot;cyber/service_discovery/*/*.cc&quot;  &quot;cyber/task/*.cc&quot;  &quot;cyber/time/*.cc&quot;  &quot;cyber/timer/*.cc&quot;  &quot;cyber/transport/*.cc&quot;  &quot;cyber/transport/*/*.cc&quot;  &quot;cyber/*.cc&quot;  &quot;cyber/sysmo/*.cc&quot;  $&#123;CROUTINE_FILE&#125;)# Exclude test files robustlylist(FILTER CYBER_SRCS EXCLUDE REGEX &quot;.*test[.]cc&quot;)list(FILTER CYBER_SRCS EXCLUDE REGEX &quot;.*/cyber/class_loader/test/.*&quot;)list(REMOVE_ITEM CYBER_SRCS &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/class_loader/shared_library/sample.cc&quot;)add_library($&#123;TARGET_NAME&#125; SHARED  $&#123;CYBER_PROTO_SRCS&#125;  $&#123;CYBER_SRCS&#125;)target_link_libraries($&#123;TARGET_NAME&#125;  fastcdr   fastrtps  $&#123;Protobuf_LIBRARIES&#125;  z  glog  atomic  dl  rt  pthread  gflags  tinyxml2  uuid)add_subdirectory(cyber/mainboard)add_subdirectory(cyber/examples)add_subdirectory(cyber/tools)add_subdirectory(cyber/python)install(DIRECTORY cyber/  DESTINATION include/cyber/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/  DESTINATION include/cyber/proto/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/  DESTINATION include/cyber/examples/proto/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY cyber/conf/ DESTINATION share/conf/)configure_file(&quot;setup.bash.in&quot; &quot;$&#123;CMAKE_BINARY_DIR&#125;/setup.bash&quot; @ONLY)install(FILES $&#123;CMAKE_BINARY_DIR&#125;/setup.bash DESTINATION .)install(DIRECTORY cyber/python/  DESTINATION $&#123;CYBER_PYTHON_PATH&#125;  FILES_MATCHING PATTERN &quot;*.py&quot;)file(WRITE $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;/__init__.py   &quot;import os\\nimport sys\\nsys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))\\n&quot;)file(COPY $&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/  DESTINATION $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;  FILES_MATCHING PATTERN &quot;*.py&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;/  DESTINATION $&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;)install(TARGETS $&#123;TARGET_NAME&#125;  EXPORT $&#123;TARGET_NAME&#125;-targets  ARCHIVE DESTINATION lib  LIBRARY DESTINATION lib  RUNTIME DESTINATION bin)\n 构建build.sh编译脚本\nbash build.sh -t x86 -i -r\n#!/usr/bin/env bashset -eTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;0&#125;&quot;)&quot; &amp;&amp; pwd -P)&quot;# script usageusage()&#123;    echo &quot;Usage: $&#123;0&#125; [-t &lt;x86|xavier|rk356x&gt;] [-r (cmake reconfig)] [-i (install)] [-d (Debug)]&quot; 1&gt;&amp;2;    exit 0;&#125;# default settings: target architecture, build type, if reconfig, if installTARGET_ARCH=&quot;x86&quot;BUILD_TYPE=&quot;Release&quot;RECONFIG=falseMAKE_INSTALL=false# parse command line argswhile getopts &#x27;t:rid&#x27; OPTION; do    case &quot;$OPTION&quot; in        t)            TARGET_ARCH=&quot;$&#123;OPTARG&#125;&quot;            ;;        r)            RECONFIG=true            ;;        i)            MAKE_INSTALL=true            ;;        d)            BUILD_TYPE=&quot;Debug&quot;            ;;        *)            usage            ;;    esacdoneshift &quot;$(($&#123;OPTIND&#125; - 1))&quot; # delete option argsecho &quot;* build taget arch: $&#123;TARGET_ARCH&#125;&quot;echo &quot;* build type: $&#123;BUILD_TYPE&#125;&quot;# check if the environment variable POSEIDON_KIT_PATH existsif [ ! -v CYBER_KIT_PATH ]; then    echo -e &quot;\\e[31m[ERROR]The environment variable CYBER_KIT_PATH was not set, please &quot;\\            &quot;run &#x27;source &lt;path/to/dvpn-cyber-kit&gt;/scripts/setup.sh&#x27; first!\\e[0m&quot;    exit 1fiecho &quot;CYBER_KIT_PATH=$&#123;CYBER_KIT_PATH&#125;&quot;export PATH=$&#123;CYBER_KIT_PATH&#125;sysroot/x86/bin:$PATHexport LD_LIBRARY_PATH=$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib:$LD_LIBRARY_PATHPROJECT_DIR=$&#123;TOP_DIR&#125;export OUTPUT_DIR=$&#123;TOP_DIR&#125;/../output/$&#123;TARGET_ARCH&#125;INSTALL_PREFIX=$&#123;OUTPUT_DIR&#125;/cyberBUILD_DIR=$&#123;TOP_DIR&#125;/../build/$&#123;TARGET_ARCH&#125;/cyberTOOLCHAIN_FILE=$&#123;CYBER_KIT_PATH&#125;cmake/sysroot/$&#123;TARGET_ARCH&#125;.cmake# if reconfig delete the build cache filesif $&#123;RECONFIG&#125;; then    rm -rf $&#123;BUILD_DIR&#125;/*fimkdir -pv $&#123;BUILD_DIR&#125; &amp;&amp; cd $&#123;BUILD_DIR&#125;if [ ! -f &quot;CMakeCache.txt&quot; ] || [ ! -f &quot;Makefile&quot; ]; then    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\          -DCMAKE_BUILD_TYPE=$&#123;BUILD_TYPE&#125; \\          -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; \\          $&#123;PROJECT_DIR&#125;fimake -j$(nproc)# installif $&#123;MAKE_INSTALL&#125;; then    make installfi","categories":["CyberRT中间件"]},{"title":"LQR算法推演","url":"/2023/05/08/LQR%E7%AE%97%E6%B3%95/","content":" LQR简介\nLQR：Linear Quadratic Regulator线性二次型调节器，常用于车辆的横向控制中。\n那么，什么是LQR呢？\n如果所研究的系统是线性的，且性能指标为状态变量和控制变量的二次型函数，则最优控制问题称为线性二次型问题。\n而LQR，Linear Quadratic Regulator，即线性二次型调节器， 是求解线性二次型问题常用的求解方法。\n\nLQR，其对象是现代控制理论中以状态空间形式给出的线性系统，而目标函数为对象状态和控制输入的二次型函数。\nLQR最优设计是指设计出的状态反馈控制器KKK要使二次型目标函数JJJ取最小值，而KKK由权矩阵QQQ与RRR唯一决定，故此Q、RQ、RQ、R的选择尤为重要。\nLQR理论是现代控制理论中发展最早也最为成熟的一种状态空间设计法。特别可贵的是，LQR可得到状态线性反馈的最优控制规律，易于构成闭环最优控制。\n 现代控制理论基础\n 状态空间描述\n一个线性定常连续系统的状态空间描述包含两个部分：状态方程和输出方程。\n\n状态方程（输入维度为rrr, 状态维度为nnn, 输出维度为mmm）。状态方程描述了系统下一状态与当前状态和当前行为的关系，即\n\nx˙(t)=Ax(t)+Bu(t)\\dot x(t) = A x(t) +Bu(t)\nx˙(t)=Ax(t)+Bu(t)\nAAA是n∗nn*nn∗n的常系数矩阵，称为系统矩阵；BBB是n∗rn*rn∗r的常系数矩阵，称为控制矩阵；AAA和BBB都是由系统本身的参数决定的。 uuu是输入信号向量，xxx是状态向量。\n\n输出方程\n\ny(t)=Cx(t)+Du(t)y(t) = Cx(t) + Du(t)\ny(t)=Cx(t)+Du(t)\nCCC是m∗nm*nm∗n的常系数矩阵，称为输出矩阵，它表达了输出变量与状态变量之间的关系；DDD是m∗rm*rm∗r的常系数矩阵，称为直接转移矩阵，它表示输入变量通过矩阵DDD直接转移到输出。（注：大多数时候，D=0D=0D=0）\n因此，对于线性定常连续系统，其状态空间描述为（或者状态空间表达式）：\n{x˙(t)=Ax(t)+Bu(t)y(t)=Cx(t)+Du(t)\\begin{cases}\n\\dot x(t) = A x(t) +Bu(t) \\\\\ny(t) = Cx(t) + Du(t)\n\\end{cases}\n{x˙(t)=Ax(t)+Bu(t)y(t)=Cx(t)+Du(t)​\nx(t)∈Rn;u(t)∈Rr;y(t)∈Rmx(t) \\in R^n; u(t)\\in R^r;y(t)\\in R^mx(t)∈Rn;u(t)∈Rr;y(t)∈Rm。\n类似地：\n\n对于一般连续时间系统，其状态空间描述为：\n\n{x˙(t)=f[x(t),u(t),t]y(t)=g[x(t),u(t),t]\\begin{cases}\n\\dot x(t) = f[x(t), u(t),t] \\\\\ny(t) = g[x(t), u(t), t]\n\\end{cases}\n{x˙(t)=f[x(t),u(t),t]y(t)=g[x(t),u(t),t]​\n\n对于线性时变连续系统，其空间描述为：\n\n{x˙(t)=A(t)x(t)+B(t)u(t)y(t)=C(t)x(t)+D(t)u(t)\\begin{cases}\n\\dot x(t) = A(t) x(t) +B(t) u(t) \\\\\ny(t) = C(t) x(t) + D(t) u(t)\n\\end{cases}\n{x˙(t)=A(t)x(t)+B(t)u(t)y(t)=C(t)x(t)+D(t)u(t)​\nx(t)∈Rn;u(t)∈Rr;y(t)∈Rmx(t) \\in R^n; u(t)\\in R^r;y(t)\\in R^mx(t)∈Rn;u(t)∈Rr;y(t)∈Rm。\n 线性定常连续系统的状态空间描述框图（开环）\n根据线性定常连续系统的状态描述可以得到其一般性的状态空间描述框图，如下图：\n\n 线性定常连续系统的反馈控制\n经典控制理论中，我们依据描述对象输入输出行为的传递函数模型来设计控制器，因此只能用系统的可测量输出作为反馈信号。\n而现代控制理论则是用刻画系统内部特征的状态空间模型来描述对象，除了可测量的输出信号外，还可以用系统的内部状态来作为反馈信号。根据可利用的信息是系统的输出还是状态，相应的反馈控制可分为输出反馈和状态反馈。\n现代控制理论中，更多地使用状态反馈，由于状态反馈能提供更丰富的状态信息和可供选择的自由度，因而能使系统更容易获得更为优异的性能。其实，输出反馈是可以看做是部分状态反馈。\n 全状态反馈控制器\n\n设计一个状态反馈控制器，如下图所示：\n\n\n增加反馈环节KKK，使得闭环系统能够满足我们期望的系统性能：\nu(t)=r(t)−Kx(t)(1)u(t) = r(t) - Kx(t) \\tag 1\nu(t)=r(t)−Kx(t)(1)\n已知系统的状态空间描述为：\n{x˙(t)=Ax(t)+Bu(t)y(t)=Cx(t)+Du(t)(2)\\begin{cases}\n\\dot x(t) = A x(t) +Bu(t) \\\\\ny(t) = Cx(t) + Du(t)\n\\end{cases} \\tag 2\n{x˙(t)=Ax(t)+Bu(t)y(t)=Cx(t)+Du(t)​(2)\nx(t)∈Rn;u(t)∈Rr;y(t)∈Rmx(t) \\in R^n; u(t)\\in R^r;y(t)\\in R^mx(t)∈Rn;u(t)∈Rr;y(t)∈Rm。\n将(1)(1)(1)式代入(2)(2)(2)式得到闭环系统状态空间描述：\n{x˙(t)=Ax(t)+B[r(t)−Kx(t)]y(t)=Cx(t)+D[r(t)−Kx(t)]=(C−DK)x(t)+Dr(t)\\begin{cases}\n\\dot x(t) = A x(t) +B[r(t) - Kx(t)] \\\\\ny(t) = Cx(t) + D[r(t) - Kx(t)] = (C-DK)x(t) + Dr(t)\n\\end{cases}\n{x˙(t)=Ax(t)+B[r(t)−Kx(t)]y(t)=Cx(t)+D[r(t)−Kx(t)]=(C−DK)x(t)+Dr(t)​\n{x˙(t)=(A−BK)x(t)+Br(t)y(t)=(C−DK)x(t)+Dr(t)(3)\\begin{cases}\n\\dot x(t) =  (A - BK)x(t) +Br(t) \\\\\ny(t) = (C - DK)x(t) + Dr(t)\n\\end{cases} \\tag 3\n{x˙(t)=(A−BK)x(t)+Br(t)y(t)=(C−DK)x(t)+Dr(t)​(3)\n\n设计完反馈控制器的架构，下面要保证反馈系统的稳定性。\n\n反馈系统稳定性的充要条件是系统闭环传递函数的所有极点均有负实部，即均在复频域S平面的左侧。\n根据稳定性判定的条件，首先求闭环系统的传递函数。\n为了书写一致性，我们重写系统状态表达式将rrr替换成uuu：\n{x˙(t)=(A−BK)x(t)+Bu(t)y(t)=(C−DK)x(t)+Du(t)(4)\\begin{cases}\n\\dot x(t) =  (A - BK)x(t) +Bu(t) \\\\\ny(t) = (C - DK)x(t) + Du(t)\n\\end{cases} \\tag 4\n{x˙(t)=(A−BK)x(t)+Bu(t)y(t)=(C−DK)x(t)+Du(t)​(4)\n对系统状态空间表达式进行拉普拉斯变换：\n{sX(s)=(A−BK)X(s)+BU(s)Y(s)=(C−DK)X(s)+DU(s)(5)\\begin{cases}\nsX(s) =  (A - BK)X(s) +BU(s) \\\\\nY(s) = (C - DK)X(s) + DU(s)\n\\end{cases} \\tag 5\n{sX(s)=(A−BK)X(s)+BU(s)Y(s)=(C−DK)X(s)+DU(s)​(5)\n⇒{X(s)=BU(s)sI−(A−BK)Y(s)=(C−DK)X(s)+DU(s)\\Rightarrow\n\\begin{cases}\nX(s) =  \\frac{BU(s)}{sI -(A - BK)} \\\\\nY(s) = (C - DK)X(s) + DU(s)\n\\end{cases} \\\\\n⇒{X(s)=sI−(A−BK)BU(s)​Y(s)=(C−DK)X(s)+DU(s)​\n⇒Y(s)=(C−DK)BU(s)sI−(A−BK)+DU(s)\\Rightarrow\nY(s) = \\frac{(C - DK)BU(s)}{sI -(A - BK)} + DU(s)\n⇒Y(s)=sI−(A−BK)(C−DK)BU(s)​+DU(s)\n可得传递函数：\nY(s)U(s)=(C−DK)BU(s)+sI−(A−BK)sI−(A−BK)(6)\\frac{Y(s)}{U(s)} = \\frac{(C - DK)BU(s) + sI -(A - BK)}{sI -(A - BK)} \\tag 6\nU(s)Y(s)​=sI−(A−BK)(C−DK)BU(s)+sI−(A−BK)​(6)\n可以得到系统的闭环传递函数的形式如式(6)(6)(6)所示。可见系统传递的极点就是矩阵A−BKA-BKA−BK的特征值。\n因此，可以通过配置KKK，使闭环系统达到我们期望的状态。\n问题是：当系统变量很多的时候，即使设计好了极点，但是矩阵KKK也不好计算。接下来开始引入LQR帮助求解KKK值。\n LQR 设计控制器的方法\n 什么是二次型\n在不指定优化标准的前提下，控制领域中的“最优”体现在“输出能够完全跟踪控制，即在每一时刻输出量与控制量完全一致”。实际过程并不是这样完美的过程，每一时刻都会存在误差。退而求其次，追求在整个工作时间的范围内误差最小，与轨迹误差类似，我们研究状态误差。\n因此，把整个工作时间内每一时刻状态的误差都累加起来，只要累加值更小，便会更加接近系统性能的期望。\n\n首先，假设状态向量x(t)x(t)x(t)的维度为111以及闭环系统稳定。\n令e(t)=x(t)−x∗(t)e(t) = x(t)-x^*(t)e(t)=x(t)−x∗(t)，x(t)x(t)x(t)为实际状态，x∗(t)x^*(t)x∗(t)为期望状态。\n\nJ=∫0∞∣e(t)∣dt=∫0∞∣x(t)−x∗(t)∣dtJ = \\int_0^\\infty {|e(t)|}dt = \\int_0^\\infty {|x(t)-x^*(t)|}dt\nJ=∫0∞​∣e(t)∣dt=∫0∞​∣x(t)−x∗(t)∣dt\n显然，理想状态下x(t)=x∗(t)x(t)=x^*(t)x(t)=x∗(t)，JJJ为零，达到最小值。非理想情况下JJJ越小越好，JJJ一般被称为代价函数（cost function）。\n由于绝对值操作，不太方便数学运算，因此可以改写成平方的形式：\nJ=∫0∞e(t)2dt=∫0∞(x(t)−x∗(t))2dtJ = \\int_0^\\infty {e(t)^2}dt = \\int_0^\\infty {(x(t)-x^*(t))^2}dt\nJ=∫0∞​e(t)2dt=∫0∞​(x(t)−x∗(t))2dt\n系统稳定之后，系统的状态处于平衡状态，即x∗(t)x^*(t)x∗(t)，不妨取x∗(t)=0x^*(t)=0x∗(t)=0作为期望状态。\nJ=∫0∞x2(t)dtJ = \\int_0^\\infty {x^2(t)}dt\nJ=∫0∞​x2(t)dt\n\n扩充状态为nnn个，则代价函数为：\n\nJ=∫0∞x12(t)+x22(t)+...+xn2(t)dtJ = \\int_0^\\infty x_1^2(t) + x_2^2(t) + ... + x_n^2(t)dt\nJ=∫0∞​x12​(t)+x22​(t)+...+xn2​(t)dt\n考虑到不同状态对累计误差所占的权重不同，赋予每个状态权重wiw_iwi​ :\nJ=∫0∞(w1x1)2(t)+(w2x2)2(t)+...+(wnxn)2(t)dtJ = \\int_0^\\infty (w_1x_1)^2(t) + (w_2x_2)^2(t) + ... + (w_nx_n)^2(t)dt\nJ=∫0∞​(w1​x1​)2(t)+(w2​x2​)2(t)+...+(wn​xn​)2(t)dt\n写成紧凑表达式为：\nJ=∫0∞(wx)T(wx)dt=xT(wTw)xdtJ = \\int_0^\\infty (wx)^T(wx)dt = x^T(w^Tw)xdt\nJ=∫0∞​(wx)T(wx)dt=xT(wTw)xdt\n其中：\nwx=[w1x1w2x2⋮wnxn]wx = \\begin{bmatrix}\nw_1x_1 \\\\\nw_2x_2 \\\\\n\\vdots \\\\\nw_nx_n\n\\end{bmatrix} \\\\\nwx=⎣⎢⎢⎢⎢⎡​w1​x1​w2​x2​⋮wn​xn​​⎦⎥⎥⎥⎥⎤​\n(wx)T=[w1x1w2x2⋯wnxn](wx)^T = \\begin{bmatrix}\nw_1x_1 &amp; w_2x_2 &amp; \\cdots &amp; w_nx_n\n\\end{bmatrix}\n(wx)T=[w1​x1​​w2​x2​​⋯​wn​xn​​]\n其中：\nx=[x1x2⋮xn]x = \\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_n\n\\end{bmatrix} \\\\\nx=⎣⎢⎢⎢⎢⎡​x1​x2​⋮xn​​⎦⎥⎥⎥⎥⎤​\nw=[w1w2⋱xn]=wTw = \\begin{bmatrix}\nw_1 &amp; \\\\\n&amp; w_2 \\\\\n&amp;  &amp;\\ddots \\\\\n&amp; &amp; &amp; x_n\n\\end{bmatrix} = w^T\nw=⎣⎢⎢⎢⎡​w1​​w2​​⋱​xn​​⎦⎥⎥⎥⎤​=wT\n则：\nwTw=wwT=[w12w22⋱xn2]w^Tw = ww^T = \\begin{bmatrix}\nw_1^2 &amp; \\\\\n&amp; w_2^2 \\\\\n&amp;  &amp;\\ddots \\\\\n&amp; &amp; &amp; x_n^2\n\\end{bmatrix}\nwTw=wwT=⎣⎢⎢⎢⎡​w12​​w22​​⋱​xn2​​⎦⎥⎥⎥⎤​\n数学规范：xxx默认是列向量，xTx^TxT是行向量。\n类似的JJJ的函数称为二次型函数，变量的最高次数是2。\n所有展开的函数最高次数为2的，这种类型的函数统称为二次型函数。\n 二次型最优控制\n令Q=wTwQ=w^TwQ=wTw，则原来的代价方程改写为：\nJ=∫0∞xTQxdtJ = \\int_0^\\infty x^TQxdt\nJ=∫0∞​xTQxdt\n显然QQQ是半正定矩阵。\n思考：系统的状态发生的原因是在上一个状态时，有外界干扰或者系统输入发生改变引起的。外界干扰因素我们暂不考虑，说明代价函数不仅仅和系统的状态有关，而且和系统的输入有关。\n因此，参考误差的处理方式，将控制量uuu也引入到代价函数里面，而且形式保持一致，具体如下：\nJ=∫0∞(xTQx+uTRu)dtJ = \\int_0^\\infty (x^TQx + u^TRu)dt\nJ=∫0∞​(xTQx+uTRu)dt\n其中，QQQ和RRR均为自己设计的半正定矩阵。\n上式也称为能量函数，二次型最优控制的目的就是使能量函数最小。\n那如何设计反馈矩阵KKK使得能量函数JJJ最小呢？\n LQR 调节器设计\nLQR控制器是计算反馈矩阵KKK主要分为三步：\n\nQRQRQR矩阵选取；\n求解Riccati方程得到矩阵PPP；\n计算K=R−1BTPK=R^{-1}B^TPK=R−1BTP；\n\n Q R 矩阵选取\n矩阵Q,RQ,RQ,R的选取，一般来说，QQQ值选得大意味着，要使得JJJ小，那x(t)x(t)x(t)需要更小，也就是意味着闭环系统的矩阵(A−BK)(A-BK)(A−BK)的特征值处于SSS平面左边更远的地方，这样状态x(t)x(t)x(t)就以更快的速度衰减到000。另一方面，大的RRR表示更加关注输入变量u(t)u(t)u(t)，u(t)u(t)u(t)的减小，意味着状态衰减将变慢。\n 解 Riccati 方程得到矩阵 P\n我们求解的前提是假定系统处于稳定状态，此时的状态反馈为u(t)=−Kx(t)u(t)=-Kx(t)u(t)=−Kx(t)\n代价函数：\nJ=∫0∞(xTQx+uTRu)dt=∫0∞[xTQx+(−Kx)TR(−Kx)]dt=∫0∞[xTQx+xTKTRKx]dt=∫0∞xT(Q+KTRK)xdt\\begin{aligned}\nJ = \\int_0^\\infty (x^TQx + u^TRu)dt \\\\\n= \\int_0^\\infty [x^TQx + (-Kx)^TR(-Kx)] dt \\\\\n= \\int_0^\\infty [x^TQx + x^T K^T R Kx] dt \\\\\n= \\int_0^\\infty x^T(Q + K^T R K)x dt\n\\end{aligned}\nJ=∫0∞​(xTQx+uTRu)dt=∫0∞​[xTQx+(−Kx)TR(−Kx)]dt=∫0∞​[xTQx+xTKTRKx]dt=∫0∞​xT(Q+KTRK)xdt​\n我们要找到这个积分的原函数，为了找到KKK，假设存在一个常量矩阵PPP，使得\nddt(xTPx)=−xT(Q+KTRK)x\\frac{d}{dt}(x^TPx) = - x^T(Q + K^T R K)x\ndtd​(xTPx)=−xT(Q+KTRK)x\n注意，假设时有个负号。\n两边取微分\nx˙TPx+xTPx˙+xTQx+xTKTRKx=0\\dot x^T P x + x^TP \\dot x +  x^TQx + x^T K^T R Kx = 0\nx˙TPx+xTPx˙+xTQx+xTKTRKx=0\n将状态方程\nx˙=Ax+Bu=Ax−BKx=(A−BK)x\\dot x = A x + Bu = Ax - BKx = (A-BK)xx˙=Ax+Bu=Ax−BKx=(A−BK)x\n代入得：\n[(A−BK)x]TPx+xTP[(A−BK)x]+xTQx+xTKTRKx=0[(A-BK)x]^T P x + x^TP [(A-BK)x] +  x^TQx + x^T K^T R Kx = 0\n[(A−BK)x]TPx+xTP[(A−BK)x]+xTQx+xTKTRKx=0\n⇒xT(A−BK)TPx+xTP[(A−BK)x]+xTQx+xTKTRKx=0\\Rightarrow\nx^T(A-BK)^TPx + x^TP [(A-BK)x] +  x^TQx + x^T K^T R Kx = 0\n⇒xT(A−BK)TPx+xTP[(A−BK)x]+xTQx+xTKTRKx=0\n⇒xT[(A−BK)TP+P(A−BK)+Q+KTRK]x=0\\Rightarrow\nx^T[(A-BK)^TP + P (A-BK) + Q + K^T R K]x = 0\n⇒xT[(A−BK)TP+P(A−BK)+Q+KTRK]x=0\n这个式子要成立的话，括号里的项必须为恒为零。\n(A−BK)TP+P(A−BK)+Q+KTRK=0(A-BK)^TP + P (A-BK) + Q + K^T R K = 0\n(A−BK)TP+P(A−BK)+Q+KTRK=0\n进一步化简：\nATP+PA+Q+KTRK−KTBTP−PBK=0A^TP + PA + Q + K^T R K - K^T B^T P - PBK = 0\nATP+PA+Q+KTRK−KTBTP−PBK=0\n取K=R−1BTPK = R^{-1}B^TPK=R−1BTP(推导方式见LQR最优控制方法小结)，代入上式得：\nATP+PA+Q+(R−1BTP)TR(R−1BTP)−(R−1BTP)TBTP−PB(R−1BTP)=0A^TP + PA + Q + (R^{-1}B^TP)^T R (R^{-1}B^TP) - (R^{-1}B^TP)^T B^T P - PB(R^{-1}B^TP) = 0 \nATP+PA+Q+(R−1BTP)TR(R−1BTP)−(R−1BTP)TBTP−PB(R−1BTP)=0\n⇒ATP+PA+Q+PTB(R−1)TR(R−1BTP)−PTB(R−1)TBTP−PB(R−1BTP)=0\\Rightarrow\nA^TP + PA + Q + P^T B (R^{-1})^T R (R^{-1}B^TP) - P^T B (R^{-1})^T B^T P - PB(R^{-1}B^TP) = 0\n⇒ATP+PA+Q+PTB(R−1)TR(R−1BTP)−PTB(R−1)TBTP−PB(R−1BTP)=0\n⇒ATP+PA+Q+PTB(R−1)TBTP−PTB(R−1)TBTP−PB(R−1BTP)=0\\Rightarrow\nA^TP + PA + Q + P^T B (R^{-1})^T B^TP - P^T B (R^{-1})^T B^T P - PB(R^{-1}B^TP) = 0 \n⇒ATP+PA+Q+PTB(R−1)TBTP−PTB(R−1)TBTP−PB(R−1BTP)=0\n⇒ATP+PA+Q−PB(R−1BTP)=0\\Rightarrow\nA^TP + PA + Q - PB(R^{-1}B^TP) = 0 \\\\ \n⇒ATP+PA+Q−PB(R−1BTP)=0\n等价\n⇒ATP+PA+Q−PBR−1BTP=0(7)\\Rightarrow\nA^TP+PA+Q-PBR^{-1} B^T P =0 \\tag 7\n⇒ATP+PA+Q−PBR−1BTP=0(7)\n\nKKK的二次项没有了，可KKK的取值和PPP有关，而PPP是我们假设的一个量，PPP只要使得的(7)(7)(7)式成立就行了。而(7)(7)(7)式在现代控制理论中极其重要，它就是著名的连续时间代数Riccati方程(CARE)。\n 计算反馈矩阵\n根据PPP，可计算出反馈矩阵K=R−1BTPK=R^{-1}B^TPK=R−1BTP；\n 离散时间下的 LQR 调节器的设计\nLQR - 离散时间有限边界\n 对状态方程进行离散化\n状态方程x˙=Ax+Bu\\dot x = Ax+ Bux˙=Ax+Bu离散化\n∫tt+dtx˙dt=∫tt+dt(Ax+Bu)dt\\int_t^{t +dt} \\dot x dt = \\int_t^{t+dt} (Ax + Bu)dt\n∫tt+dt​x˙dt=∫tt+dt​(Ax+Bu)dt\n根据积分中值定理得：\nx(t+dt)−x(t)=Ax(ξ1)dt+Bu(ξ2)dtx(t+dt) - x(t) = Ax(\\xi_1)dt + Bu(\\xi_2)dt\nx(t+dt)−x(t)=Ax(ξ1​)dt+Bu(ξ2​)dt\n\n由向前欧拉法可得：\n\nx(t+dt)=x(t)+Ax(t)dt+Bu(t)dtx(t+dt) = x(t) + Ax(t)dt + Bu(t)dt\nx(t+dt)=x(t)+Ax(t)dt+Bu(t)dt\n⇒x(k+1)=x(k)+Ax(k)dt+Bu(k)dt\\Rightarrow\nx(k+1) = x(k) + Ax(k)dt + Bu(k)dt\n⇒x(k+1)=x(k)+Ax(k)dt+Bu(k)dt\n⇒x(k+1)=(I+Adt)x(k)+(Bdt)u(k)\\Rightarrow\nx(k+1) = (I + Adt)x(k) + (Bdt)u(k)\n⇒x(k+1)=(I+Adt)x(k)+(Bdt)u(k)\n⇒x(k+1)=A‾⋅x(k)+B‾⋅u(k)\\Rightarrow\nx(k+1) = \\overline{A}\\cdot x(k) + \\overline{B} \\cdot u(k)\n⇒x(k+1)=A⋅x(k)+B⋅u(k)\nA‾,B‾\\overline{A}, \\overline{B}A,B与A,BA,BA,B是不同的\n\nx(t)x(t)x(t)采用中点欧拉法，u(t)u(t)u(t)采用向前欧拉法：\n\nx(t+dt)=x(t)+Adtx(t)+x(t+dt)2+Bdtu(t)x(t+dt) = x(t) + Adt\\frac{x(t) + x(t+dt)}{2} + Bdtu(t)\nx(t+dt)=x(t)+Adt2x(t)+x(t+dt)​+Bdtu(t)\n⇒x(t+dt)=x(t)+12A⋅dt⋅x(t)+12A⋅dt⋅x(t+dt)+B⋅dt⋅u(t)\\Rightarrow\nx(t+dt) = x(t) + \\frac{1}{2}A \\cdot dt \\cdot x(t) + \\frac{1}{2}A \\cdot dt \\cdot x(t+dt) + B\\cdot dt\\cdot u(t)\n⇒x(t+dt)=x(t)+21​A⋅dt⋅x(t)+21​A⋅dt⋅x(t+dt)+B⋅dt⋅u(t)\n⇒(I−A⋅dt2)⋅x(t+dt)=(I+A⋅dt2)⋅x(t)+B⋅dt⋅u(t)\\Rightarrow\n(I - \\frac{A \\cdot dt}{2}) \\cdot x(t+dt) = (I + \\frac{A \\cdot dt}{2}) \\cdot x(t) + B\\cdot dt\\cdot u(t)\n⇒(I−2A⋅dt​)⋅x(t+dt)=(I+2A⋅dt​)⋅x(t)+B⋅dt⋅u(t)\n⇒x(t+dt)=(I−A⋅dt2)−1(I+A⋅dt2)⋅x(t)+(I−A⋅dt2)−1B⋅dt⋅u(t)\\Rightarrow\nx(t+dt) = (I - \\frac{A \\cdot dt}{2})^{-1}(I + \\frac{A \\cdot dt}{2}) \\cdot x(t) + (I - \\frac{A \\cdot dt}{2})^{-1}B\\cdot dt\\cdot u(t)\n⇒x(t+dt)=(I−2A⋅dt​)−1(I+2A⋅dt​)⋅x(t)+(I−2A⋅dt​)−1B⋅dt⋅u(t)\n⇒x(t+dt)≈(I−A⋅dt2)−1(I+A⋅dt2)⋅x(t)+B⋅dt⋅u(t)\\Rightarrow\nx(t+dt) \\approx (I - \\frac{A \\cdot dt}{2})^{-1}(I + \\frac{A \\cdot dt}{2}) \\cdot x(t) + B\\cdot dt\\cdot u(t) \n⇒x(t+dt)≈(I−2A⋅dt​)−1(I+2A⋅dt​)⋅x(t)+B⋅dt⋅u(t)\ndtdtdt为采样周期：x(k+1)=A‾⋅x(k)+B‾⋅u(k)x(k+1) = \\overline{A}\\cdot x(k) + \\overline{B} \\cdot u(k)x(k+1)=A⋅x(k)+B⋅u(k)\n接着，以这个离散的系统进行dlqr推导。\n使用了中点欧拉和前向欧拉来离散化车辆的动力学模型。\n 构造离散化 LQR 代价函数\n对于一个离散时间系统：\nxk+1=A‾xk+B‾ukx0=xinitx_{k+1} = \\overline{A}x_k + \\overline{B}u_k\\quad x_0 = x_{init}\nxk+1​=Axk​+Buk​x0​=xinit​\n其中，A‾∈Rn×n,B‾∈Rn×m\\overline{A} \\in R^{n\\times n}, \\overline{B} \\in R^{n \\times m}A∈Rn×n,B∈Rn×m\n关于最优问题，就在于如何选择合适的u0,u1,...u_0,u_1,...u0​,u1​,...，使得状态量x0,x1,...x_0,x_1,...x0​,x1​,...足够小，因此得到好的调节和控制；或者使得u0,u1,...u_0,u_1,...u0​,u1​,...足够小，以使用更少的能量。这两个量通常相互制约，如果采用更大的输入uuu，就会驱使状态量 xxx更快达到000。采用线性二次调节原理可以解决这个问题。\n为了表示控制系统达到稳定控制所付出的代价，定义如下二次型代价函数：\nJ=∑k=0∞(xkTQxk+ukTRuk)约束：xk+1=A‾xk+B‾ukJ = \\sum_{k=0}^{\\infty} (x_k^T Q x_k + u_k^TRu_k) \\\\\n约束：  x_{k+1} = \\overline{A}x_k + \\overline{B}u_k\nJ=k=0∑∞​(xkT​Qxk​+ukT​Ruk​)约束：xk+1​=Axk​+Buk​\n转换成离散时间有限边界：\nJ(U)=∑k=0n−1(xkTQxk+ukTRuk)+xnTQfxnJ(U) = \\sum_{k=0}^{n-1} (x_k^T Q x_k + u_k^TRu_k) + x_n^T Q_f x_n \\\\\nJ(U)=k=0∑n−1​(xkT​Qxk​+ukT​Ruk​)+xnT​Qf​xn​\n约束：{A‾x0+B‾u0−x1=0A‾x1+B‾u1−x2=0⋮A‾xk−1+B‾uk−1−xk=0⋮A‾xn−1+B‾un−1−xn=0约束： \\\\\n\\begin{cases}\n\\overline{A}x_0 + \\overline{B}u_0 - x_1 = 0 \\\\\n\\overline{A}x_1 + \\overline{B}u_1 - x_2 = 0 \\\\\n\\vdots \\\\\n\\overline{A}x_{k-1} + \\overline{B}u_{k-1} - x_k = 0 \\\\\n\\vdots \\\\\n\\overline{A}x_{n-1} + \\overline{B}u_{n-1} - x_n = 0 \\\\\n\\end{cases}\n约束：⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​Ax0​+Bu0​−x1​=0Ax1​+Bu1​−x2​=0⋮Axk−1​+Buk−1​−xk​=0⋮Axn−1​+Bun−1​−xn​=0​\n其中函数参数U=(u0,u1,...,un)U = (u_0, u_1, ..., u_n)U=(u0​,u1​,...,un​),并且矩阵Q,Qf,RQ,Q_f,RQ,Qf​,R为正定矩阵，即\nQ=QT≥0，Qf=QfT≥0，R=RT&gt;0Q=Q^T\\geq 0，Q_f=Q_f^T\\geq 0，R=R^T&gt; 0\nQ=QT≥0，Qf​=QfT​≥0，R=RT&gt;0\n\n\n\nQQQ\nQfQ_fQf​\nR\n\n\n\n\n给定状态代价矩阵\n最终状态代价矩阵\n输入代价矩阵\n\n\n\n\nNNN： 时间范围\nQ,RQ,RQ,R：分别设定状态偏差和输入的相对权重\nR&gt;0R&gt;0R&gt;0：意味着任何非零输入都增加JJJ的代价\nxkTQxkx_k^T Q x_kxkT​Qxk​：衡量状态偏差\nukTRuku_k^TRu_kukT​Ruk​：衡量输入大小\nxnTQfxnx_n^T Q_f x_nxnT​Qf​xn​：衡量最终状态偏差\n\n因此，关于LQR问题就是找出使得代价函数J(U)J(U)J(U)最小的一组控制输入(u0,u1,...,un−1)lqr(u_0,u_1,...,u_{n-1})_{lqr}(u0​,u1​,...,un−1​)lqr​。\n 求解 LQR 方法\n 拉格朗日乘子法\n对于等式约束的最优化问题，常见的方法有拉格朗日乘子法。\nL=∑k=0n−1(xkTQxk+ukTRuk)+xnTQfxn+∑k=0n−1λk+1T(A‾xk+B‾uk−xk+1)L = \\sum_{k=0}^{n-1} (x_k^T Q x_k + u_k^TRu_k) + x_n^T Q_f x_n + \\sum_{k=0}^{n-1}\\lambda_{k+1}^T(\\overline{A}x_k + \\overline{B} u_k - x_{k+1})\nL=k=0∑n−1​(xkT​Qxk​+ukT​Ruk​)+xnT​Qf​xn​+k=0∑n−1​λk+1T​(Axk​+Buk​−xk+1​)\n=∑k=0n−1[xkTQxk+ukTRuk+λk+1T(A‾xk+B‾uk)−λk+1Txk+1]+xnTQfxn= \\sum_{k=0}^{n-1} [x_k^T Q x_k + u_k^TRu_k + \\lambda_{k+1}^T(\\overline{A}x_k + \\overline{B} u_k)  - \\lambda_{k+1}^Tx_{k+1}] + x_n^T Q_f x_n\n=k=0∑n−1​[xkT​Qxk​+ukT​Ruk​+λk+1T​(Axk​+Buk​)−λk+1T​xk+1​]+xnT​Qf​xn​\n其中A‾xk+B‾uk−xk+1\\overline{A}x_k + \\overline{B} u_k - x_{k+1}Axk​+Buk​−xk+1​是列向量，所以λk+1\\lambda_{k+1}λk+1​需要转置。\n令Hk=xkTQxk+ukTRuk+λk+1T(A‾xk+B‾uk)H_k = x_k^T Q x_k + u_k^TRu_k + \\lambda_{k+1}^T(\\overline{A}x_k + \\overline{B} u_k)Hk​=xkT​Qxk​+ukT​Ruk​+λk+1T​(Axk​+Buk​)，则：\nL=∑k=0n−1[Hk−λk+1Txk+1]+xnTQfxn=∑k=0n−1Hk+∑k=1n(−λkTxk)+xnTQfxn=∑k=0n−1Hk+∑k=1n−1(−λkTxk)+(−λnTxn)+xnTQfxn+(−λ0Tx0)−(−λ0Tx0)=∑k=0n−1Hk+∑k=0n−1(−λkTxk)+(−λnTxn)+xnTQfxn−(−λ0Tx0)=∑k=0n−1(Hk−λkTxk)+xnTQfxn−λnTxn+λ0Tx0\\begin{aligned}\nL = \\sum_{k=0}^{n-1} [H_k  - \\lambda_{k+1}^Tx_{k+1}] + x_n^T Q_f x_n\\\\\n=  \\sum_{k=0}^{n-1} H_k + \\sum_{k=1}^{n} (- \\lambda_{k}^Tx_{k}) + x_n^T Q_f x_n \\\\\n= \\sum_{k=0}^{n-1} H_k + \\sum_{k=1}^{n-1} (- \\lambda_{k}^Tx_{k}) + (-\\lambda_n^Tx_n) + x_n^T Q_f x_n + (-\\lambda_0^Tx_0) - (-\\lambda_0^Tx_0) \\\\\n= \\sum_{k=0}^{n-1} H_k + \\sum_{k=0}^{n-1} (- \\lambda_{k}^Tx_{k}) + (-\\lambda_n^Tx_n) + x_n^T Q_f x_n - (-\\lambda_0^Tx_0) \\\\\n= \\sum_{k=0}^{n-1} (H_k - \\lambda_{k}^Tx_{k}) + x_n^T Q_f x_n -\\lambda_n^Tx_n + \\lambda_0^Tx_0 \\\\\n\\end{aligned}\nL=k=0∑n−1​[Hk​−λk+1T​xk+1​]+xnT​Qf​xn​=k=0∑n−1​Hk​+k=1∑n​(−λkT​xk​)+xnT​Qf​xn​=k=0∑n−1​Hk​+k=1∑n−1​(−λkT​xk​)+(−λnT​xn​)+xnT​Qf​xn​+(−λ0T​x0​)−(−λ0T​x0​)=k=0∑n−1​Hk​+k=0∑n−1​(−λkT​xk​)+(−λnT​xn​)+xnT​Qf​xn​−(−λ0T​x0​)=k=0∑n−1​(Hk​−λkT​xk​)+xnT​Qf​xn​−λnT​xn​+λ0T​x0​​\n在求解目标函数极小值时，利用向量导数的知识：\n{∂(xTA)∂x=A∂(Ax)∂x=AT∂(xTAx)∂x=(A+AT)x\\begin{cases}\n\\frac{\\partial(x^TA)}{\\partial x} = A \\\\\n\\frac{\\partial(Ax)}{\\partial x} = A^T \\\\\n\\frac{\\partial(x^TAx)}{\\partial x} = (A+A^T)x \\\\\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​∂x∂(xTA)​=A∂x∂(Ax)​=AT∂x∂(xTAx)​=(A+AT)x​\n\n使用向量导数的知识分别对xk,uk,xn,λkx_k,u_k,x_n,\\lambda _kxk​,uk​,xn​,λk​求偏导：\nL=∑k=0n−1(Hk−λkTxk)+xnTQfxn−λnTxn+λ0Tx0L = \\sum_{k=0}^{n-1} (H_k - \\lambda_{k}^Tx_{k}) + x_n^T Q_f x_n -\\lambda_n^Tx_n + \\lambda_0^Tx_0\nL=k=0∑n−1​(Hk​−λkT​xk​)+xnT​Qf​xn​−λnT​xn​+λ0T​x0​\n其中：Hk=xkTQxk+ukTRuk+λk+1T(A‾xk+B‾uk)其中：\nH_k = x_k^T Q x_k + u_k^TRu_k + \\lambda_{k+1}^T(\\overline{A}x_k + \\overline{B} u_k)\n其中：Hk​=xkT​Qxk​+ukT​Ruk​+λk+1T​(Axk​+Buk​)\n\nLLL对xkx_kxk​求偏导\n\n∂L∂x0=0→⇒∂(λ0Tx0)∂x0=0→⇒λ0=0→\\begin{aligned}\n\\frac{\\partial L}{\\partial x_0} = \\overrightarrow{0} \\\\\n\\Rightarrow \n\\frac{\\partial (\\lambda_0^Tx_0)}{\\partial x_0} = \\overrightarrow{0} \\\\\n\\Rightarrow\n\\lambda_0 = \\overrightarrow{0} \\\\\n\\end{aligned}\n∂x0​∂L​=0⇒∂x0​∂(λ0T​x0​)​=0⇒λ0​=0​\n同理，依次对x1,...,xkx_1,...,x_kx1​,...,xk​求偏导：\n∂L∂xk=0→⇒∂[∑k=0n−1(Hk−λkTxk)]∂xk=0→⇒∂(Hk−λkTxk)∂xk=0→⇒∂Hk∂xk−λk=0→⇒λk=∂Hk∂xk(k=1,2,3,...,n−1)\\begin{aligned}\n\\frac{\\partial L}{\\partial x_k} = \\overrightarrow{0} \\\\\n\\Rightarrow \n\\frac{\\partial  [\\sum_{k=0}^{n-1} (H_k - \\lambda_{k}^Tx_{k})]}{\\partial x_k} = \\overrightarrow{0}  \\\\\n\\Rightarrow \n\\frac{\\partial (H_k - \\lambda_{k}^Tx_{k})}{\\partial x_k} = \\overrightarrow{0}  \\\\\n\\Rightarrow \n\\frac{\\partial H_k }{\\partial x_k} - \\lambda_{k} = \\overrightarrow{0}  \\\\\n\\Rightarrow \n\\lambda_{k} =\\frac{\\partial H_k }{\\partial x_k} \\quad (k=1,2,3,...,n-1) \\\\\n\\end{aligned}\n∂xk​∂L​=0⇒∂xk​∂[∑k=0n−1​(Hk​−λkT​xk​)]​=0⇒∂xk​∂(Hk​−λkT​xk​)​=0⇒∂xk​∂Hk​​−λk​=0⇒λk​=∂xk​∂Hk​​(k=1,2,3,...,n−1)​\n∂Hk∂xk=2Qxk+A‾Tλk+1=λk\\frac{\\partial H_k }{\\partial x_k} = 2Qx_k+ \\overline{A}^T\\lambda_{k+1} = \\lambda_k \n∂xk​∂Hk​​=2Qxk​+ATλk+1​=λk​\n\nLLL对uku_kuk​求偏导\n\n∂L∂uk=0→⇒∂Hk∂uk=0→(k=1,2,3,...,n−1)\\begin{aligned}\n\\frac{\\partial L}{\\partial u_k} = \\overrightarrow{0}  \\\\\n\\Rightarrow \n\\frac{\\partial H_k }{\\partial u_k} =  \\overrightarrow{0}  \\quad (k=1,2,3,...,n-1) \\\\\n\\end{aligned}\n∂uk​∂L​=0⇒∂uk​∂Hk​​=0(k=1,2,3,...,n−1)​\n∂Hk∂uk=2Ruk+B‾Tλk+1=0→⇒uk=−12R−1B‾Tλk+1\\begin{aligned}\n\\frac{\\partial H_k }{\\partial u_k}  = 2Ru_k + \\overline{B}^T\\lambda_{k+1} = \\overrightarrow{0}  \\\\\n\\Rightarrow\nu_k = -\\frac{1}{2}R^{-1}\\overline{B}^T\\lambda_{k+1}\n\\end{aligned}\n∂uk​∂Hk​​=2Ruk​+BTλk+1​=0⇒uk​=−21​R−1BTλk+1​​\n\nLLL对xnx_nxn​求偏导\n\n∂L∂xn=0→⇒∂(xnTQfxn−λnTxn)∂xn=0⇒2Qfxn−λn=0\\begin{aligned}\n\\frac{\\partial L}{\\partial x_n} = \\overrightarrow{0}  \\\\\n\\Rightarrow \n\\frac{\\partial ( x_n^T Q_f x_n -\\lambda_n^Tx_n)}{\\partial x_n} = 0  \\\\\n\\Rightarrow \n2Q_fx_n - \\lambda_n = 0 \n\\end{aligned}\n∂xn​∂L​=0⇒∂xn​∂(xnT​Qf​xn​−λnT​xn​)​=0⇒2Qf​xn​−λn​=0​\n\nLLL对λk\\lambda_kλk​求偏导\n\n∂L∂λk=0→⇒A‾xk+B‾uk−xk+1=0(k=1,2,3,...,n−1)\\begin{aligned}\n\\frac{\\partial L}{\\partial \\lambda_k} = \\overrightarrow{0}  \\\\\n\\Rightarrow \n\\overline{A}x_k + \\overline{B} u_k - x_{k+1} = 0 \\quad (k = 1, 2,3,...,n-1)\n\\end{aligned}\n∂λk​∂L​=0⇒Axk​+Buk​−xk+1​=0(k=1,2,3,...,n−1)​\n也就是等式约束。\n综上所述：\n{λk=2Qxk+A‾Tλk+1(k=1,2,3,...,n−1)uk=−12R−1B‾Tλk+1(k=1,2,3,...,n−1)xk+1=A‾xk+B‾uk(k=1,2,3,...,n−1)λn=2Qfxn\\begin{cases}\n\\lambda_k = 2Qx_k+\\overline{A}^T\\lambda_{k+1} \\quad (k = 1, 2,3,...,n-1)  \\\\\nu_k = -\\frac{1}{2}R^{-1}\\overline{B}^T\\lambda_{k+1} \\quad (k = 1, 2,3,...,n-1) \\\\\nx_{k+1} = \\overline{A}x_k + \\overline{B} u_k \\quad (k = 1, 2,3,...,n-1) \\\\\n\\lambda_n = 2Q_fx_n \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​λk​=2Qxk​+ATλk+1​(k=1,2,3,...,n−1)uk​=−21​R−1BTλk+1​(k=1,2,3,...,n−1)xk+1​=Axk​+Buk​(k=1,2,3,...,n−1)λn​=2Qf​xn​​\n递推式：\n{λn=2Qfxnuk=−12R−1B‾Tλk+1(k=n−1)\\begin{cases}\n\\lambda_n = 2Q_fx_n \\\\\nu_k = -\\frac{1}{2}R^{-1}\\overline{B}^T\\lambda_{k+1} \\quad (k = n-1) \\\\\n\\end{cases}\n{λn​=2Qf​xn​uk​=−21​R−1BTλk+1​(k=n−1)​\n⇒un−1=−12R−1B‾T2Qfxn=−R−1B‾TQfxn\\Rightarrow \nu_{n-1} =  -\\frac{1}{2}R^{-1}\\overline{B}^T2Q_fx_n = -R^{-1}\\overline{B}^TQ_fx_n\n⇒un−1​=−21​R−1BT2Qf​xn​=−R−1BTQf​xn​\n则：\n{xk+1=A‾xk+B‾uk(k=n−1)un−1=−R−1B‾TQfxn\\begin{cases}\nx_{k+1} = \\overline{A}x_k + \\overline{B} u_k \\quad (k = n-1) \\\\\nu_{n-1} = -R^{-1}\\overline{B}^TQ_fx_n\n\\end{cases}\n{xk+1​=Axk​+Buk​(k=n−1)un−1​=−R−1BTQf​xn​​\n⇒xn=A‾xn−1+B‾(−R−1B‾TQfxn)\\Rightarrow \nx_n = \\overline{A}x_{n-1} + \\overline{B}(-R^{-1}\\overline{B}^TQ_fx_n)\n⇒xn​=Axn−1​+B(−R−1BTQf​xn​)\n⇒xn=(I+B‾R−1B‾TQf)−1A‾xn−1\\Rightarrow \nx_n = (I + \\overline{B}R^{-1}\\overline{B}^TQ_f)^{-1}\\overline{A}x_{n-1} \n⇒xn​=(I+BR−1BTQf​)−1Axn−1​\n再有：\n{λk=2Qxk+A‾Tλk+1(k=n−1)λn=2Qfxn\\begin{cases}\n\\lambda_k = 2Qx_k+\\overline{A}^T\\lambda_{k+1} \\quad (k = n-1)  \\\\\n\\lambda_n = 2Q_fx_n \\\\\n\\end{cases} \n{λk​=2Qxk​+ATλk+1​(k=n−1)λn​=2Qf​xn​​\n⇒λn−1=2Qxn−1+A‾T2Qfxn\\Rightarrow\n\\lambda_{n-1} = 2Qx_{n-1} + \\overline{A}^T   2Q_fx_n\n⇒λn−1​=2Qxn−1​+AT2Qf​xn​\n则：\n{λn−1=2Qxn−1+A‾T2Qfxnxn=(I+B‾R−1B‾TQf)−1A‾xn−1\\begin{cases}\n\\lambda_{n-1} = 2Qx_{n-1} + \\overline{A}^T   2Q_fx_n \\\\\nx_n = (I + \\overline{B}R^{-1}\\overline{B}^TQ_f)^{-1}\\overline{A}x_{n-1} \n\\end{cases} \n{λn−1​=2Qxn−1​+AT2Qf​xn​xn​=(I+BR−1BTQf​)−1Axn−1​​\n⇒λn−1=2Qxn−1+2A‾TQf(I+B‾R−1B‾TQf)−1A‾xn−1\\Rightarrow \n\\lambda_{n-1} = 2Qx_{n-1} + 2 \\overline{A}^T  Q_f  (I + \\overline{B}R^{-1}\\overline{B}^TQ_f)^{-1}\\overline{A}x_{n-1} \n⇒λn−1​=2Qxn−1​+2ATQf​(I+BR−1BTQf​)−1Axn−1​\n=2[Q+A‾TQf(I+B‾R−1B‾TQf)−1A‾]xn−1= 2 [Q  + \\overline{A}^T  Q_f  (I + \\overline{B}R^{-1}\\overline{B}^TQ_f)^{-1}\\overline{A}]x_{n-1} \n=2[Q+ATQf​(I+BR−1BTQf​)−1A]xn−1​\n也就是：\n{λn−1=2[Q+A‾TQf(I+B‾R−1B‾TQf)−1A‾]xn−1λn=2Qfxn\\begin{cases}\n\\lambda_{n-1} = 2 [Q  + \\overline{A}^T  Q_f  (I + \\overline{B}R^{-1}\\overline{B}^TQ_f)^{-1}\\overline{A}]x_{n-1}  \\\\\n\\lambda_n = 2Q_fx_n \\\\\n\\end{cases}\n{λn−1​=2[Q+ATQf​(I+BR−1BTQf​)−1A]xn−1​λn​=2Qf​xn​​\n观察，可设λk=2Pkxk,(k=1,2,3,...,n)\\lambda_k = 2P_kx_k,(k = 1,2,3,...,n)λk​=2Pk​xk​,(k=1,2,3,...,n)，可知Pn=QfP_n = Q_fPn​=Qf​\n\n则：\n{λk=2Pkxk(k=1,2,3,...,n)uk=−12R−1B‾Tλk+1(k=1,2,3,...,n−1)\\begin{cases}\n\\lambda_k = 2P_kx_k \\quad (k = 1, 2,3,...,n)\\\\\nu_k = -\\frac{1}{2}R^{-1}\\overline{B}^T\\lambda_{k+1} \\quad (k = 1, 2,3,...,n-1) \\\\\n\\end{cases} \n{λk​=2Pk​xk​(k=1,2,3,...,n)uk​=−21​R−1BTλk+1​(k=1,2,3,...,n−1)​\n⇒uk−1=−12R−1B‾T2Pkxk=−R−1B‾TPkxkk=1,2,3,...,n\\Rightarrow \nu_{k-1} =  -\\frac{1}{2}R^{-1}\\overline{B}^T2P_kx_k = -R^{-1}\\overline{B}^TP_kx_k \\\\\nk = 1,2,3,...,n\n⇒uk−1​=−21​R−1BT2Pk​xk​=−R−1BTPk​xk​k=1,2,3,...,n\n则：\n{uk−1=−R−1B‾TPkxkxk+1=A‾xk+B‾uk(k=1,2,3,...,n−1)\\begin{cases}\nu_{k-1} = -R^{-1}\\overline{B}^TP_kx_k \\\\\nx_{k+1} = \\overline{A}x_k + \\overline{B} u_k \\quad (k =1,2,3,..., n-1) \\\\\n\\end{cases}\n{uk−1​=−R−1BTPk​xk​xk+1​=Axk​+Buk​(k=1,2,3,...,n−1)​\n⇒xk=A‾xk−1+B‾(−R−1B‾TPkxk)\\Rightarrow\nx_k = \\overline{A}x_{k -1} + \\overline{B}(-R^{-1}\\overline{B}^TP_kx_k) \\\\\n⇒xk​=Axk−1​+B(−R−1BTPk​xk​)\n⇒xk=(I+B‾R−1B‾TPk)−1A‾xk−1\\Rightarrow\nx_k = (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A}x_{k-1}\n⇒xk​=(I+BR−1BTPk​)−1Axk−1​\n所以：\n{λk=2Pkxkλk−1=2Qxk−1+A‾Tλkxk=(I+B‾R−1B‾TPk)−1A‾xk−1\\begin{cases}\n\\lambda_k = 2P_kx_k \\\\\n\\lambda_{k-1} = 2Qx_{k-1} + \\overline{A}^T\\lambda_k  \\\\\nx_k = (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A}x_{k-1}\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​λk​=2Pk​xk​λk−1​=2Qxk−1​+ATλk​xk​=(I+BR−1BTPk​)−1Axk−1​​\n⇒λk−1=2Qxk−1+A‾T2Pk(I+B‾R−1B‾TPk)−1A‾xk−1\\Rightarrow\n\\lambda_{k-1} = 2Qx_{k-1} + \\overline{A}^T 2P_k  (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A}x_{k-1} \\\\\n⇒λk−1​=2Qxk−1​+AT2Pk​(I+BR−1BTPk​)−1Axk−1​\n⇒λk−1=2[Q+A‾TPk(I+B‾R−1B‾TPk)−1A‾]xk−1=2Pk−1xk−1\\Rightarrow\n\\lambda_{k-1} = 2[Q + \\overline{A}^T P_k  (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A}]x_{k-1}  = 2P_{k-1}x_{k-1} \\\\\n⇒λk−1​=2[Q+ATPk​(I+BR−1BTPk​)−1A]xk−1​=2Pk−1​xk−1​\n则可以得到递推式：\nPk−1=Q+A‾TPk(I+B‾R−1B‾TPk)−1A‾P_{k-1} = Q + \\overline{A}^T P_k  (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A}\nPk−1​=Q+ATPk​(I+BR−1BTPk​)−1A\n因此：Pn=Qf⇒Pn−1⇒Pn−2⇒...P_n = Q_f \\Rightarrow P_{n-1} \\Rightarrow P_{n-2} \\Rightarrow ...Pn​=Qf​⇒Pn−1​⇒Pn−2​⇒...\n特别的：\nuk−1=−R−1B‾TPkxk⇒uk=−R−1B‾TPk+1xk+1=−R−1B‾TPk+1(A‾xk+B‾uk)\\begin{aligned}\nu_{k-1} = -R^{-1}\\overline{B}^TP_kx_k \\\\\n\\Rightarrow\nu_k = -R^{-1}\\overline{B}^TP_{k+1}x_{k+1} \\\\\n=  -R^{-1}\\overline{B}^TP_{k+1}( \\overline{A}x_k + \\overline{B} u_k) \\\\\n\\end{aligned}\nuk−1​=−R−1BTPk​xk​⇒uk​=−R−1BTPk+1​xk+1​=−R−1BTPk+1​(Axk​+Buk​)​\n⇒uk=−(I+R−1B‾TPk+1B‾)−1R−1B‾TPk+1A‾xk⇒uk=−(R+B‾TPk+1B‾)−1B‾TPk+1A‾xk\\begin{aligned}\n\\Rightarrow \nu_k = - (I + R^{-1}\\overline{B}^TP_{k+1}\\overline{B})^{-1} R^{-1}\\overline{B}^TP_{k+1}\\overline{A}x_k  \\\\\n\\Rightarrow \nu_k = - (R + \\overline{B}^TP_{k+1}\\overline{B})^{-1} \\overline{B}^TP_{k+1}\\overline{A}x_k\n\\end{aligned}\n⇒uk​=−(I+R−1BTPk+1​B)−1R−1BTPk+1​Axk​⇒uk​=−(R+BTPk+1​B)−1BTPk+1​Axk​​\n\n考虑\n{∑k=0n−1(xkTQxk+ukTRuk)+xnTQfxnn→∞Pn=Qf\\begin{cases}\n \\sum_{k=0}^{n-1} (x_k^T Q x_k + u_k^TRu_k) + x_n^T Q_f x_n \\\\\n n \\rightarrow \\infty \\\\\nP_n =Q_f\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​∑k=0n−1​(xkT​Qxk​+ukT​Ruk​)+xnT​Qf​xn​n→∞Pn​=Qf​​\n要迭代无穷多次。\n实际上，一般迭代几次就会收敛，Pk=Pk−1=Pk−2=...P_k = P_{k-1} = P_{k-2} = ...Pk​=Pk−1​=Pk−2​=...\n也就是说：\nPk−1P_{k-1}Pk−1​实际上是P=Q+A‾TP(I+B‾R−1B‾TP)−1A‾P = Q + \\overline{A}^T P (I + \\overline{B}R^{-1}\\overline{B}^TP)^{-1}\\overline{A}P=Q+ATP(I+BR−1BTP)−1A的解。\n\n 其他计算方式\n基础算法-LQR-离散时间有限边界 | Henry-Z\n 离散 LQR 算法步骤\n\n输入A、B、Q、RA、B、Q、RA、B、Q、R、最大迭代次数NNN，以及精度，即PkP_kPk​变化量多少时可以看做不变收敛了；\n设置迭代初始值Pn=QfP_n = Q_fPn​=Qf​ ；\n循环迭代，k=n,n−1,...,1k = n,n-1,...,1k=n,n−1,...,1，从未来时刻推算回来，直到PkP_kPk​趋于稳定；\n\nPk−1=Q+A‾TPk(I+B‾R−1B‾TPk)−1A‾P_{k-1} = Q + \\overline{A}^T P_k  (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A}\nPk−1​=Q+ATPk​(I+BR−1BTPk​)−1A\n假设在k=ik=ik=i时趋于稳定，设稳定值为PstableP_{stable}Pstable​，则P0=P1=P2=...=Pi−1=Pi=PstableP_0 = P_1 = P_2 = ... = P_{i-1} = P_i =P_{stable}P0​=P1​=P2​=...=Pi−1​=Pi​=Pstable​\n4. 计算反馈系数 ，根据\nuk=−(R+B‾TPk+1B‾)−1B‾TPk+1A‾⋅xku_k = - (R + \\overline{B}^TP_{k+1}\\overline{B})^{-1} \\overline{B}^TP_{k+1}\\overline{A}\\cdot x_k\nuk​=−(R+BTPk+1​B)−1BTPk+1​A⋅xk​\n则：\n\nKk=(R+B‾TPstableB‾)−1B‾TPstableA‾k=0,1,2,...,i−1K_k = (R + \\overline{B}^TP_{stable}\\overline{B})^{-1} \\overline{B}^TP_{stable}\\overline{A} \\\\\nk = 0,1,2,...,i-1\nKk​=(R+BTPstable​B)−1BTPstable​Ak=0,1,2,...,i−1\n\n\n计算优化的控制量\n\nuklqr=−Kkxk(k=0,1,2,...,i−1)u_k^{lqr} = - K_kx_k \\quad (k = 0,1,2,...,i-1)\nuklqr​=−Kk​xk​(k=0,1,2,...,i−1)\n 离散时间的代数 Riccati 方程( DARE )\n矩阵求逆引理：(A+BCD)−1=A−1−A−1B(C−1+DA−1B)−1DA−1(A+BCD)^{-1} = A^{-1} - A^{-1}B(C^{-1}+DA^{-1}B)^{-1}DA^{-1}(A+BCD)−1=A−1−A−1B(C−1+DA−1B)−1DA−1\n\n化简下面公式：\nPk−1=Q+A‾TPk(I+B‾R−1B‾TPk)−1A‾P_{k-1} = Q + \\overline{A}^T P_k  (I + \\overline{B}R^{-1}\\overline{B}^TP_k)^{-1}\\overline{A} \\\\\nPk−1​=Q+ATPk​(I+BR−1BTPk​)−1A\n对应\nA=I,B=B‾,C=R−1,D=B‾TPkA = I , B=\\overline{B} , C=R^{-1} , D=\\overline{B}^TP_k\nA=I,B=B,C=R−1,D=BTPk​\n则：\nPk−1=Q+A‾TPk[I−B‾(R+B‾TPkB‾)−1B‾TPk]A‾P_{k-1} =  Q + \n\\overline{A}^T P_k  [I -\\overline{B}(R + \\overline{B}^TP_k\\overline{B})^{-1}\\overline{B}^TP_k]\\overline{A}\nPk−1​=Q+ATPk​[I−B(R+BTPk​B)−1BTPk​]A\n=Q+A‾TPkA‾−A‾TPkB‾(R+B‾TPkB‾)−1B‾TPkA‾= Q + \n\\overline{A}^T P_k \\overline{A} - \\overline{A}^T P_k\\overline{B}(R + \\overline{B}^TP_k\\overline{B})^{-1}\\overline{B}^TP_k \\overline{A}\n=Q+ATPk​A−ATPk​B(R+BTPk​B)−1BTPk​A\nPk−1=Q+A‾TPkA‾−A‾TPkB‾(R+B‾TPkB‾)−1B‾TPkA‾P_{k-1} =Q + \n\\overline{A}^T P_k \\overline{A} - \\overline{A}^T P_k\\overline{B}(R + \\overline{B}^TP_k\\overline{B})^{-1}\\overline{B}^TP_k \\overline{A}Pk−1​=Q+ATPk​A−ATPk​B(R+BTPk​B)−1BTPk​A\n就是离散时间的代数Riccati方程(DARE)\n\n 参考文档\n车辆控制知识总结（一）：LQR算法\n自动驾驶控制算法（四）离散LQR算法推导\nLQR：Linear Quadratic Regulator 线性二次型调节器\n","categories":["算法"]},{"title":"Latex数学公式测试","url":"/2025/07/03/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95/","content":"测试博客 markdown 相关语法书写。\n\n 列表\n\n文本：\n\n[ ] 你好[x] 你好\n\n效果：\n\n你好\n你好\n 行内公式\n\n文本：\n\n$E = mc^2$\n\n效果：E=mc2E = mc^2E=mc2\n\n 块级公式\n\n文本：\n\n$$i\\hbar \\frac&#123;\\partial \\psi&#125;&#123;\\partial t&#125; = -\\frac&#123;\\hbar^2&#125;&#123;2m&#125; \\nabla^2 \\psi + V \\psi$$\n\n效果：\n\niℏ∂ψ∂t=−ℏ22m∇2ψ+Vψi\\hbar \\frac{\\partial \\psi}{\\partial t} = -\\frac{\\hbar^2}{2m} \\nabla^2 \\psi + V \\psi\niℏ∂t∂ψ​=−2mℏ2​∇2ψ+Vψ\n 字体颜色\n\n文本：\n\n1. ==高亮文本==2. &lt;span style=&quot;color: green;&quot;&gt;绿色文本&lt;/span&gt;3. **&lt;span style=&quot;color: green;&quot;&gt;绿色文本加粗&lt;/span&gt;**4. &lt;code style=&quot;color: green;&quot;&gt;green Codes: abcdef&lt;/code&gt;5. **&lt;code style=&quot;color: green;&quot;&gt;blod green Codes: abcdef&lt;/code&gt;**# 老式写法，需要打开# markdown_it_plus:#    html: true                 # 允许原始 HTML 标签6. &lt;font color=green&gt;文本&lt;/font&gt;7. &lt;font color=red size=5&gt;文本&lt;/font&gt;\n\n效果：\n\n\n高亮文本\n绿色文本\n绿色文本加粗\ngreen Codes: abcdef\nblod green Codes: abcdef\n文本\n文本\n\n 字体大小\n\n文本：\n\n&lt;span style=&quot;font-size: 18px;&quot;&gt;这是 18px 大小的文字&lt;/span&gt;\n\n效果：\n这是 18px 大小的文字\n\n 公式换行\n\n文本：\n\n$$\\begin&#123;aligned&#125;\\theta(s)=\\theta_&#123;start&#125;+s(\\theta_&#123;end&#125;-\\theta_&#123;start&#125;),s\\in[0,1] \\\\s=s(t),t\\in[0,T]\\end&#123;aligned&#125;$$# 带对齐符号$$\\begin&#123;aligned&#125;\\theta(s)&amp;=\\theta_&#123;start&#125;+s(\\theta_&#123;end&#125;-\\theta_&#123;start&#125;),s\\in[0,1] \\\\s&amp;=s(t),t\\in[0,T]\\end&#123;aligned&#125;$$# 不带aligned$$a = b+c \\\\d = e+f$$\n\n效果：\n\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns=s(t),t\\in[0,T]\n\\end{aligned}\nθ(s)=θstart​+s(θend​−θstart​),s∈[0,1]s=s(t),t∈[0,T]​\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)&amp;=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns&amp;=s(t),t\\in[0,T]\n\\end{aligned}\nθ(s)s​=θstart​+s(θend​−θstart​),s∈[0,1]=s(t),t∈[0,T]​\na=b+cd=e+fa = b+c \\\\\nd = e+f\na=b+cd=e+f\n 矩阵\nxT⋅wxI4×4⋅x=(x1x2x3x4)1×4⋅wx(1000010000100001)4×4⋅(x1x2x3x4)4×1=wxx12+wxx22+wxx32+wxx42=wx∑i=14xi2\\begin{aligned}\nx^T\\cdot w_{x}\\textbf{I}_{4\\times4} \\cdot x &amp; =\\begin{pmatrix} x_1 &amp; x_2 &amp; x_3 &amp; x_4 \\end{pmatrix}_{1\\times4} \n\\cdot w_{x}\n\\begin{pmatrix} \n1 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\end{pmatrix}_{4\\times4}\n\\cdot\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1} \\\\\n&amp; = w_{x}x_1^2+w_{x}x_2^2+w_{x}x_3^2+w_{x}x_4^2 \\\\\n&amp; = w_{x} \\sum_{i=1}^{4}x_i^2\n\\end{aligned}\nxT⋅wx​I4×4​⋅x​=(x1​​x2​​x3​​x4​​)1×4​⋅wx​⎝⎜⎜⎜⎛​1000​0100​0010​0001​⎠⎟⎟⎟⎞​4×4​⋅⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​=wx​x12​+wx​x22​+wx​x32​+wx​x42​=wx​i=1∑4​xi2​​\n","categories":["博客搭建"]},{"title":"Linux下QT使用appimage打包程序","url":"/2024/08/05/Linux%E4%B8%8BQT%E4%BD%BF%E7%94%A8appimage%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F/","content":"本文详细介绍了在 Linux 下使用 linuxdeployqt 将 Qt 应用程序打包为可移植的 .AppImage 文件的完整流程。内容涵盖环境配置、依赖库处理、patchelf 工具的作用、打包命令的使用、.desktop 文件与图标的自定义，以及显式加载库的特殊处理方法。通过该流程，开发者可实现“一键打包、跨平台分发”的效果，极大提升 Qt 应用在 Linux 系统下的部署效率与兼容性。\n\n部分借鉴linux下将qt程序打包成appimage程序\n 1. 配置linuxdeployqt\nlinuxdeployqt 下载地址\n\n\n点击点击下载linuxdeploy-continuous-x86_64.AppImage\n然后执行如下代码，将改名字后的linuxdeployqt移动到/usr/local/bin目录下\n\nsudo mv linuxdeployqt-continuous-x86_64.AppImage linuxdeployqtsudo mv ./linuxdeployqt /usr/local/bincd /usr/local/binchmod 777 linuxdeployqt\n显示版本表示安装成功\n\nlinuxdeployqt是一个用于将Qt应用程序打包成独立的可执行文件的工具，适用于Linux平台。该工具的主要目的是简化Qt应用程序的分发过程，使得应用程序可以在目标系统上独立运行，而无需用户手动安装所有的依赖项。\n linuxdeployqt的使用示例\n以下是一个使用linuxdeployqt打包Qt应用程序的简单示例：\n\n\n构建 Qt 应用程序：\n\n假设你已经使用Qt构建了一个应用程序，并生成了可执行文件myapp。\n\n\n\n准备 AppDir 目录：\n\n创建一个名为 AppDir 的目录，并将可执行文件和所有必要的资源（如图标和 .desktop 文件）放入该目录中。\n目录结构可能如下所示：AppDir/├── myapp├── myapp.desktop├── myapp.png└── usr/    ├── bin/    └── lib/\n\n\n\n\n运行 linuxdeployqt：\n\n使用 linuxdeployqt 工具来打包应用程序。以下是一个简单的命令示例：linuxdeployqt AppDir/myapp -appimage\n\nlinuxdeployqt 会自动处理依赖关系、设置 RPATH/RUNPATH，并最终生成一个AppImage文件。\n\n\n\n linuxdeployqt的一些选项\n\n-appimage：生成AppImage文件，这是一个常用选项，可以将应用程序打包成便携式的AppImage格式。\n-bundle-non-qt-libs：同时打包非Qt库。\n-qmldir=path：指定QML文件的目录。\n\n 重要注意事项\n\n依赖性处理：linuxdeployqt主要关注Qt应用程序的依赖性处理，但在某些情况下，可能需要手动调整某些库路径或依赖关系。\n权限：确保你有足够的权限来运行linuxdeployqt并修改目标文件。\n\n 2. 安装patchelf\nsudo apt install patchelf\npatchelf 是一个用于修改 ELF（Executable and Linkable Format）文件的工具。ELF 文件是 Linux 和 Unix 系统上常见的可执行文件、共享库和目标文件格式。patchelf 可以用于调整和修改这些文件的某些属性，以适应特定的需求。常见的用途包括更改动态链接库的路径、修改 RPATH 和 RUNPATH 以及改变可执行文件的解释器路径。\n patchelf的常见用途\n\n\n更改动态库路径（SONAME）：\n\n使用 --set-soname 选项可以更改共享库的 SONAME。\n例如，将共享库的SONAME设置为 libnewname.so：patchelf --set-soname libnewname.so libexample.so\n\n\n\n\n修改 RPATH 和 RUNPATH：\n\nRPATH 和 RUNPATH 是 ELF 文件中的两个属性，它们指定了运行时动态链接器查找共享库的路径。\n使用 --set-rpath 选项可以更改 ELF 文件的 RPATH：patchelf --set-rpath /new/library/path executable\n\n使用 --set-runpath 选项可以更改 ELF 文件的 RUNPATH：patchelf --set-runpath /new/library/path executable\n\n\n\n\n更改解释器路径：\n\nELF 可执行文件中的解释器（interpreter）指定了运行时用于加载和执行程序的动态链接器路径。\n使用 --set-interpreter 选项可以更改解释器路径：patchelf --set-interpreter /new/path/to/ld-linux.so.2 executable\n\n\n\n\n添加或删除依赖：\n\n使用 --add-needed 选项可以向 ELF 文件中添加一个新的动态库依赖：patchelf --add-needed libnewdependency.so executable\n\n使用 --remove-needed 选项可以从 ELF 文件中移除一个动态库依赖：patchelf --remove-needed libolddependency.so executable\n\n\n\n\n显示当前设置：\n\n使用 --print-rpath 可以显示 ELF 文件的当前 RPATH：patchelf --print-rpath executable\n\n使用 --print-interpreter 可以显示 ELF 文件的当前解释器路径：patchelf --print-interpreter executable\n\n\n\n\n linuxdeployqt和patchelf的关系\nlinuxdeployqt 在打包过程中需要处理可执行文件和共享库的依赖关系，以确保打包后的应用程序能够正确找到并加载所需的库。为此，linuxdeployqt 会使用 patchelf 来修改ELF文件（可执行文件和共享库）的某些属性，包括但不限于以下内容：\n\n\n设置 RPATH/RUNPATH：\n\nlinuxdeployqt 使用 patchelf 来设置可执行文件和共享库的RPATH或RUNPATH，使其能够在运行时正确地找到所需的依赖库。\n\n\n\n更改解释器路径：\n\n在某些情况下，linuxdeployqt 可能需要修改可执行文件的解释器路径，以确保应用程序在目标系统上能够正确运行。\n\n\n\n调整库路径：\n\n当应用程序依赖的库被打包到AppDir目录中时，linuxdeployqt 使用 patchelf 修改这些库的路径，使得它们在运行时能够相互找到。\n\n\n\nlinuxdeployqt 在打包 Qt 应用程序时确实会使用到 patchelf 来处理 ELF 文件的依赖关系和路径设置。通过这种方式，linuxdeployqt 能够确保生成的 AppImage 文件包含所有必要的依赖，并且在目标系统上能够正确运行。这样，无论用户的系统环境如何，应用程序都能顺利启动并运行。\n 3. Qt库路径设置到环境变量\n\n配置qmake环境\n\n用linuxdeployqt打包程序遇到qmake找不到的问题如何解决\n本地存在多个版本的qmake，需要正确指定所用版本，可以通过设置环境变量的方式让操作系统找到它。\n修改用户目录下的.bashrc文件，仅对当前用户永久有效，也可以配置成一次性的，防止环境混乱。\nsudo vim ~/.bashrc\n我的QT安装目录在/opt/Qt5.14.2/5.14.2/gcc_64/bin\n# ~/.bashrc文件增加该文本export PATH=/opt/Qt5.14.2/5.14.2/gcc_64/bin:$PATHexport LD_LIBRARY_PATH=/opt/Qt5.14.2/5.14.2/gcc_64/lib:$LD_LIBRARY_PATHexport QT_PLUGIN_PATH=/opt/Qt5.14.2/5.14.2/gcc_64/plugins:$QT_PLUGIN_PATHexport QML2_IMPORT_PATH=/opt/Qt5.14.2/5.14.2/gcc_64/qml:$QML2_IMPORT_PATH\n此时再次在终端中运行qmake -v，就能找到相应的执行路径了：\n\n根据linuxdeployqt在线帮助文档介绍，其实上述最重要的环境变量就是PATH这条，其他的并没有说，或许其他不要也没啥问题。\n LIB_PATH和LD_LIBRARY_PATH区别\n\n\nLIB_PATH\nLIB_PATH通常不是一个标准的环境变量，但在某些特定的构建系统或脚本中可能会被用作一个自定义变量来指定库路径。在这些情况下，它的用途取决于具体的构建工具或脚本是如何解释它的。例如，在某些自定义构建系统中，可能会使用LIB_PATH来指定链接时查找库的路径。\n\n\nLD_LIBRARY_PATH\nLD_LIBRARY_PATH是Unix和Linux系统上的一个标准环境变量。它用于指定在运行时动态链接器查找共享库的目录。当一个程序运行时，动态链接器会按照以下顺序查找共享库：\n\n程序的运行时路径（通常由编译器设置）。\n环境变量LD_LIBRARY_PATH指定的目录。\n系统默认的共享库路径（通常是/lib和/usr/lib等目录）。\n\n在运行时，如果LD_LIBRARY_PATH指定了目录，动态链接器会优先在这些目录中查找共享库。\n\n\n 4. 配置其他依赖库的路径\n# ~/.bashrc文件增加该文本POSEIDON_ENV=/home/lxp/projects/dvpn-poseidon-kitexport LD_LIBRARY_PATH=$&#123;POSEIDON_ENV&#125;/sysroot/x86/lib:$&#123;POSEIDON_ENV&#125;/platform_sdk/x86/lib:/home/lxp/projects/l2_plot_tool_new/plot_tool/control_plot_tool/output/lib:$LD_LIBRARY_PATHexport PATH=$&#123;POSEIDON_ENV&#125;/platform_sdk/x86/bin:$PATH\n其中/home/lxp/projects/l2_plot_tool_new/plot_tool/control_plot_tool/output/lib:是自己编译出来库的存放位置\n\n 5. 编译出可执行程序（release版本）\n\n并将可执行文件以及所需配置文件拷贝到打包目录，比如放在app_test/\n\n 6. 使用linuxdeployqt\n直接对可执行程序进行操作\nlinuxdeployqt control_plot_tool -appimage\n\n生成以下文件：\n\n可以看到创建了lib等目录。\n重要提示：\n\n因为linuxdeployqt将在内部使用ldd命令，来确定从何处将库复制到包中。ldd命令本身只能查找隐式加载的so，故若程序中代码使用显式加载的so，它是找不到的，这时需要开发者自己去保证显式加载so的路径可被搜索。\n举个例子：若存在程序A显式加载B.so，B.so隐式加载C.so，则对程序A使用linuxdeployqt拷贝依赖时，程序A的间接依赖文件C.so，将不会被拷贝。当程序跑起来加载B.so时，就会报找不到C.so的错误。这一点尤其需要注意。此时我们需要再对B.so使用一次linuxdeployqt拷贝依赖。这样程序A加载B.so，B.so加载C.so，就都可以找到了。\n\n 7. 修改desktop\n因为默认生成的default.desktop存在问题\nDesktop file: /home/lxp/projects/l2_plot_tool_new/plot_tool/app_test/default.desktopCategories entry not found in desktop file.desktop file is missing a Categories= key\n// default.desktop文件内容[Desktop Entry]Type=ApplicationName=ApplicationExec=AppRun %FIcon=defaultComment=Edit this default fileTerminal=true\n\n\n替换default.desktop成control_plot_tool.desktop\n  // control_plot_tool.desktop文件内容[Desktop Entry]Type=ApplicationName=ControlPlotToolComment=This is a tool for control plotExec=control_plot_toolIcon=control_plot_toolCategories=Application;X-AppImage-Version=59b7e67\n\n\n将default.png替换成自定义图表control_plot_tool.png\n\n\n\n\n再次使用linuxdeployqt\n\nlinuxdeployqt control_plot_tool -appimage\n\n生成*.AppImage文件\n\n\n\nAppRun：这是一个可执行文件，作为AppImage的入口点。\n.desktop文件：这是一个标准的桌面条目文件，描述了应用程序的基本信息，如名称、图标和可执行文件路径。\n图标文件：通常是.png格式的图标文件，用于在应用程序启动器和其他界面中显示。\n\n\n 8. 增加运行脚本\n正常双击*.AppImage文件就可以运行程序，但由于权限原因可能无法正常使用程序。\n\n所以增加以下运行脚本run.sh，通过脚本启动程序：\n# run.sh 文件内容./*.AppImage --appimage-extract-and-run\n--appimage-extract-and-run 是一个用于AppImage文件的命令行选项。AppImage是一种便携式软件打包格式，主要用于在Linux系统上分发应用程序。它允许开发者将应用程序及其所有依赖项打包成一个单一的可执行文件，用户可以通过下载并运行这个文件来使用应用程序，而无需进行传统的安装过程。\n当你使用 --appimage-extract-and-run 选项运行AppImage文件时，会发生以下情况：\n\n提取内容：AppImage文件的内容会被提取到一个临时目录中。\n运行应用程序：从提取的临时目录中直接运行应用程序。\n\n这种方式的优点在于，可以在不实际提取文件到系统的情况下运行应用程序，同时也方便进行调试和测试。\n\n示例\n\n假设你有一个名为 example.AppImage 的AppImage文件，你可以使用以下命令来提取并运行它：\n./example.AppImage --appimage-extract-and-run\n\n工作原理\n\n\n\n提取内容：\n\nAppImage文件本质上是一个压缩文件，包含了应用程序及其所有依赖项。\n使用 --appimage-extract-and-run 选项时，AppImage会在一个临时目录（通常是 /tmp 目录下）中解压缩其内容。\n\n\n\n运行应用程序：\n\n在提取内容之后，AppImage会找到主可执行文件并运行它。\n运行完成后，临时目录会被清理（如果程序正常退出）。\n\n\n\n\n\n使用场景\n\n调试：在开发和测试过程中，可以使用 --appimage-extract-and-run 选项来查看AppImage内部的文件结构，并直接运行应用程序，以便快速找到并解决问题。\n临时运行：如果你只想临时运行一个AppImage文件，而不想提取其内容到系统的某个固定位置，这个选项非常方便。\n环境隔离：有时你可能希望在一个临时隔离的环境中运行应用程序，以确保它不会影响系统的其他部分。\n\n\n\n注意事项\n\n由于内容被提取到临时目录中，因此在运行过程中可能会占用一些额外的磁盘空间。\n这个选项主要用于调试和测试，通常情况下，直接运行AppImage文件（不使用 --appimage-extract-and-run 选项）会更加高效。\n\n\n\n 9. 拷贝依赖库脚本copylib.sh\n#!/bin/bashLibDir=$PWD&quot;/lib&quot;Target=$1lib_array=($(ldd $Target | grep -o &quot;/.*&quot; | grep -o &quot;/.*/[^[:space:]]*&quot;))$(mkdir $LibDir)for Variable in $&#123;lib_array[@]&#125;do    cp &quot;$Variable&quot; $LibDirdone\n# control_plot_tool是生成的可执行文件bash copylib.sh control_plot_tool\n","categories":["Linux软件开发"]},{"title":"NFS挂载","url":"/2024/02/15/NFS%E6%8C%82%E8%BD%BD/","content":" NFS介绍\nNFS（Network File System的简称，即网络文件系统）可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。NFS可以将远程的计算机磁盘挂载到本地，读写文件像访问本地磁盘一样操作。NFS只是一种文件系统，本身并没有传输功能，是基于RPC（远程过程调用）协议实现的，采用C/S架构。\n\n\n\n首先服务器端启动RPC服务，并开启111端口\n服务器端启动NFS服务，并向RPC注册登记端口信息\n客户端启动RPC，向服务端的RPC服务请求服务端的NFS端口\n服务端的RPC服务反馈NFS端口信息给客户端\n客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输\n\n 安装NFS软件包\n服务端是自己笔记本，客户端是计算机平台。也就是客户端将服务端的文件目录挂载在自己文件系统里。可用于不同平台间共享文件，在ARM平台编译x86平台上的代码，生成ARM库。\nsudo apt-get update\nsudo apt-get install nfs-kernel-server 安装NFS服务器\nsudo apt-get install nfs-common安装NFS客户端\n 添加NFS共享目录(在服务端上处理，也就是自己电脑)\n服务端开放自己的文件目录。\nsudo vim /etc/exports\n增加下面一行代码\n/home/apollo/SanyAutoDrive/   *(rw,sync,fsid=0,crossmnt,no_subtree_check,no_root_squash)\n第一个字段总是表示需要共享的文件系统，之后列举可以访问该文件系统的客户机。每个客户机之后紧跟用括号括起来、以逗号分隔的一系列选项。\n我这里共享文件夹是/home/apollo/SanyAutoDrive/\n可以访问该文件系统的客户机为*，表示允许任何网段IP的系统访问该NFS目录。\n括弧里面参数含义：\n\n\n\n参数参数\n说明\n\n\n\n\nro\n该共享目录的权限是只读（read-only）\n\n\nrw\n该共享目录的权限是可读写（read-write）\n\n\nhide\n隐藏文件系统。\n\n\nnoaccess\n阻止访问这个目录及其子目录\n\n\nwdelay\n为合并多次更新而延迟写入磁盘\n\n\nno_wdelay\n尽可能快地把数据写入磁盘\n\n\nsync\n将数据同步写入内存缓冲区与磁盘中（同步模式）\n\n\nasync\n将数据线暂存在内存缓冲区中，而非直接写入磁盘（非同步模式）\n\n\nsubtree_check\n验证每个被请求的文件都在导出的目录树中\n\n\nno_subtree_check\n只验证涉及被导出的文件系统的文件请求\n\n\nall_squash\n将所有本地和远程账户映射到匿名用户\n\n\nroot_squash\n将根用户及所属组都映射为匿名用户或用户组（nfsnobody），为默认设置\n\n\nno_root_squash\n将远程根用户当成本地根用户，即不压制root\n\n\nanonuid\n为匿名用户账户指定组ID\n\n\nanongid\n为匿名用户账户指定用户ID\n\n\n\n注：服务端应给予共享文件系统相对应的权限，否则客户端无法进行写操作\nsudo chmod -R 777 /home/apollo/SanyAutoDrive/planning_group/这步骤不要随意操作，吃过大亏。如果权限不够，在客户端执行指令时加sudo。\n 服务器(端)查看NFS连接情况\nsudo exportfs查看共享文件系统是哪个\nshowmount [-ae] [hostname | IP]\n\n NFS服务的启动和停止\nsystemctl start nfs\nsystem stop nfs\nsudo /etc/init.d/nfs-kernel-server start或者sudo /etc/init.d/nfs-kernel-server restart\n在 NFS 服务已经启动的情况下，如果修改了 “/etc/exports” 文件，需要重启 NFS 服务，以刷新 NFS 的共享目录。\n NFS客户端配置\n在客户端下，即在计算机平台上。\nsudo mount -t nfs 192.168.188.101:/home/apollo/SanyAutoDrive /mnt -o nolock或者sudo mount.nfs 192.168.188.101:/home/apollo/SanyAutoDrive /mnt -o nolock\n192.168.188.101是服务器(端)地址，/mnt是挂载在客户端的位置，如果指令运行没有出错，则NFS挂载成功。\n nfsstat指令\nnfsstat命令用于列出NFS客户端和服务器的工作状态。\n-s：仅列出NFS服务器端状态；-c：仅列出NFS客户端状态；-n：仅列出NFS状态，默认显示nfs客户端和服务器的状态；-2：仅列出NFS版本2的状态；-3：仅列出NFS版本3的状态；-4：仅列出NFS版本4的状态；-m：打印以加载的nfs文件系统状态；-r：仅打印rpc状态。\n","categories":["Linux软件开发"]},{"title":"fast-cdr 和 fast-dds 关系","url":"/2025/07/19/fast-cdr%20%E5%92%8C%20fast-dds%20%E5%85%B3%E7%B3%BB/","content":"fast-cdr 和 fast-dds 是 两个不同但密切相关的库，它们都是由 eProsima 公司 开发的，用于实现 DDS（Data Distribution Service）通信中间件协议的一部分，常用于 机器人系统（如 ROS 2）、自动驾驶中间件（如 Apollo CyberRT） 等场景。\n\n\nFast-CDR源码地址\nFast-DDS/Fast-rtps源码地址\n\n 总体区别简述\n\n\n\n库名\n全称 / 功能简介\n主要作用\n\n\n\n\nfast-cdr\nFast CDR: 高效的序列化库（CDR 格式）\n负责 序列化与反序列化\n\n\nfast-dds\nFast DDS: 完整 DDS 实现（基于 RTPS）\n实现完整的 DDS 通信协议（Pub/Sub）\n\n\n\n Fast CDR\n ✅ 功能：\n\n仅处理数据的序列化（serialization）与反序列化（deserialization）；\n支持 CDR 格式（Common Data Representation）—— 这是 DDS 协议指定的数据编码方式；\n它是一个 轻量级库，可独立使用，不依赖 DDS。\n\n 🔧 常用用途：\n\n用于将结构化数据（结构体、数组等）编码成字节流（如网络发送前）；\n在 DDS Pub/Sub 中用作底层编码组件；\n也可以在非 DDS 系统中独立使用，比如自定义 TCP/UDP 通信协议。\n\n 📂 示例头文件：\n#include &lt;fastcdr/FastBuffer.h&gt;#include &lt;fastcdr/Cdr.h&gt;\n fast-dds（旧名 FastRTPS）\n ✅ 功能：\n\n实现 DDS 协议的完整功能（包含 RTPS、QoS、Pub/Sub、Discovery）；\n使用 fast-cdr 进行消息内容的编解码；\n提供 参与者（Participant）、发布者（Publisher）、订阅者（Subscriber） 等高层抽象；\n支持 ROS 2 默认中间件、CyberRT DDS 支持等。\n\n 🎯 主要组成：\n\n基于 RTPS（Real-Time Publish-Subscribe）协议实现 DDS；\n使用 fast-cdr 作为编码模块；\n提供 XML 配置、QoS、DDS 安全、动态类型支持等功能。\n\n 它们的关系（总结）\n\nfast-dds 是“上层通信框架”；\nfast-cdr 是“底层序列化工具”；\nfast-dds 依赖 fast-cdr，但 fast-cdr 不依赖 fast-dds。\n\n应用程序   ↓[fast-dds]  &lt;- DDS 中间件（通信）   ↓[fast-cdr]  &lt;- 编解码（序列化 / 反序列化）\n 示例应用场景\n\n\n\n场景\n使用 fast-cdr？\n使用 fast-dds？\n\n\n\n\nCyberRT / ROS2 中 DDS 通信\n✅\n✅\n\n\n自己实现 UDP 通信协议，需要高效编码\n✅\n❌\n\n\n完整 DDS Pub/Sub 通信框架\n✅（内部使用）\n✅\n\n\n只处理结构体到字节流的转换\n✅\n❌\n\n\n\n 安装方式（源码编译或包）\n\n\nfast-cdr：可以单独 clone 和 build：\n  git clone https://github.com/eProsima/Fast-CDR.gitmkdir build &amp;&amp; cd buildcmake .. &amp;&amp; make &amp;&amp; sudo make install\n\n\nfast-dds（旧称 Fast-RTPS）：\n git clone https://github.com/eProsima/Fast-DDS.git\n\n\n","categories":["Linux软件开发"]},{"title":"gcc编译-O1 -Og -O2 -O3优化等级","url":"/2025/07/30/gcc%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7/","content":" 🔍 常见优化等级比较：\n\n\n\n选项\n优化级别\n编译速度\n调试友好性\n说明\n\n\n\n\n-O0\n不优化\n最快\n最佳\n完全保留源码结构，变量布局和行号最准确\n\n\n-Og\n调试优化\n较快\n非常好\n一些简单优化但保留调试能力，推荐调试用\n\n\n-O1\n基本优化\n较快\n一般\n有些变量可能被优化掉，调试难度提升\n\n\n-O2\n较高优化\n慢\n差\n更激进优化，性能好但调试不可靠\n\n\n-O3\n最高性能优化\n慢\n差\n极端优化，不适合调试\n\n\n-Os\n为体积优化\n慢\n差\n类似 -O2，但倾向于减小可执行文件大小\n\n\n-Ofast\n激进优化（可能不符标准）\n慢\n很差\n取消标准一致性检查（如 IEEE 浮点）\n\n\n\n\n -Og的含义\n-Og 是 GCC 和 Clang 提供的一个编译优化选项，全称是 “Optimize for debugging”（为调试优化）。\n它是介于 -O0 和 -O1 之间的一个折中选项，旨在：\n\n保留调试信息（变量、栈帧等），让 GDB 或 LLDB 能正确查看变量；\n同时启用一些 不会破坏调试体验的优化（比 -O0 更快）；\n保持较好的 调试可用性 + 稍好的运行性能。\n\n ⚠ 注意事项\n\n\n通常 -Og 是为 Debug 模式准备的；\n\n\nRelease 模式一般默认是 -O3 或 -O2；\n\n\n所以这种配置相当于是“调试友好的 Release”，适合有调试需求的优化构建，比如：\n  set(CMAKE_BUILD_TYPE ReleaseWithDebugInfo)set(CMAKE_CXX_FLAGS_RELEASE &quot;-Og -g&quot;)\n\n\n ✅ 推荐用法\n\n\n\n模式\n推荐设置\n\n\n\n\nDebug\n-Og -g\n\n\nRelease\n-O2 或 -O3\n\n\n开发阶段定位 Release Bug\n-Og -g\n\n\n追踪生产中崩溃问题\n-O2 -g 或 -Og -g（结合符号）\n\n\n\n 不同的级别的简单介绍\n O0\n不做任何优化，这是默认的编译选项。\n O1\n优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。\n-O和-O1： 对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。\n打开的优化选项：\n\n\n-fdefer-pop：延迟栈的弹出时间。当完成一个函数调用，参数并不马上从栈中弹出，而是在多个函数被调用后，一次性弹出。\n\n\n-fmerge-constants：尝试横跨编译单元合并同样的常量(string constants and floating point constants)\n\n\n-fthread-jumps：如果某个跳转分支的目的地存在另一个条件比较,而且该条件比较包含在前一个比较语句之内,那么执行本项优化.根据条件是true或者false,前面那条分支重定向到第二条分支的目的地或者紧跟在第二条分支后面.\n\n\n-floop-optimize：执行循环优化,将常量表达式从循环中移除，简化判断循环的条件，并且optionally do strength-reduction，或者将循环打开等。在大型复杂的循环中，这种优化比较显著。\n\n\n-fif-conversion：尝试将条件跳转转换为等价的无分支型式。优化实现方式包括条件移动，min，max，设置标志，以及abs指令，以及一些算术技巧等。\n\n\n-fif-conversion2：基本意义相同，没有找到更多的解释。\n\n\n-fdelayed-branch：这种技术试图根据指令周期时间重新安排指令。 它还试图把尽可能多的指令移动到条件分支前, 以便最充分的利用处理器的治理缓存。\n\n\n-fguess-branch-probability：当没有可用的profiling feedback或__builtin_expect时，编译器采用随机模式猜测分支被执行的可能性，并移动对应汇编代码的位置，这有可能导致不同的编译器会编译出迥然不同的目标代码。\n\n\n-fcprop-registers：因为在函数中把寄存器分配给变量, 所以编译器执行第二次检查以便减少调度依赖性(两个段要求使用相同的寄存器)并且删除不必要的寄存器复制操作。\n\n\n O2\n会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。\nGcc将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环打开（）loop unrolling以及函数内联。与O1比较而言，O2优化增加了编译时间的基础上，提高了生成代码的执行效率。\nO2打开所有的O1选项，并打开以下选项：\n\n\n-fforce-mem：在做算术操作前，强制将内存数据copy到寄存器中以后再执行。这会使所有的内存引用潜在的共同表达式，进而产出更高效的代码，当没有共同的子表达式时，指令合并将排出个别的寄存器载入。这种优化对于只涉及单一指令的变量, 这样也许不会有很大的优化效果. 但是对于再很多指令(必须数学操作)中都涉及到的变量来说, 这会时很显著的优化, 因为和访问内存中的值相比 ,处理器访问寄存器中的值要快的多。\n\n\n-foptimize-sibling-calls：优化相关的以及末尾递归的调用。通常, 递归的函数调用可以被展开为一系列一般的指令， 而不是使用分支。 这样处理器的指令缓存能够加载展开的指令并且处理他们, 和指令保持为需要分支操作的单独函数调用相比, 这样更快。\n\n\n-fstrength-reduce：这种优化技术对循环执行优化并且删除迭代变量。 迭代变量是捆绑到循环计数器的变量, 比如使用变量, 然后使用循环计数器变量执行数学操作的for-next循环。\n\n\n-fcse-follow-jumps：在公用子表达式消元时，当目标跳转不会被其他路径可达，则扫描整个的跳转表达式。例如，当公用子表达式消元时遇到if…else…语句时，当条为false时，那么公用子表达式消元会跟随着跳转。\n\n\n-fcse-skip-blocks：与-fcse-follow-jumps类似，不同的是，根据特定条件，跟随着cse跳转的会是整个的blocks\n\n\n-frerun-cse-after-loop：在循环优化完成后，重新进行公用子表达式消元操作。\n\n\n-frerun-loop-opt：两次运行循环优化 l -fgcse：执行全局公用子表达式消除pass。这个pass还执行全局常量和copy propagation。这些优化操作试图分析生成的汇编语言代码并且结合通用片段， 消除冗余的代码段。如果代码使用计算性的goto, gcc指令推荐使用-fno-gcse选项。\n\n\n-fgcse-lm：全局公用子表达式消除将试图移动那些仅仅被自身存储kill的装载操作的位置。这将允许将循环内的load/store操作序列中的load转移到循环的外面（只需要装载一次），而在循环内改变成copy/store序列。在选中-fgcse后，默认打开。\n\n\n-fgcse-sm：当一个存储操作pass在一个全局公用子表达式消除的后面，这个pass将试图将store操作转移到循环外面去。如果与-fgcse-lm配合使用，那么load/store操作将会转变为在循环前load，在循环后store，从而提高运行效率，减少不必要的操作。\n\n\n-fgcse-las：全局公用子表达式消除pass将消除在store后面的不必要的load操作，这些load与store通常是同一块存储单元（全部或局部）\n\n\n-fdelete-null-pointer-checks：通过对全局数据流的分析，识别并排出无用的对空指针的检查。编译器假设间接引用空指针将停止程序。 如果在间接引用之后检查指针，它就不可能为空。\n\n\n-fexpensive-optimizations：进行一些从编译的角度来说代价高昂的优化（这种优化据说对于程序执行未必有很大的好处，甚至有可能降低执行效率，具体不是很清楚）\n\n\n-fregmove：编译器试图重新分配move指令或者其他类似操作数等简单指令的寄存器数目，以便最大化的捆绑寄存器的数目。这种优化尤其对双操作数指令的机器帮助较大。\n\n\n-fschedule-insns：编译器尝试重新排列指令，用以消除由于等待未准备好的数据而产生的延迟。这种优化将对慢浮点运算的机器以及需要load memory的指令的执行有所帮助，因为此时允许其他指令执行，直到load memory的指令完成，或浮点运算的指令再次需要cpu。 l\n\n\n-fschedule-insns2：与-fschedule-insns相似。但是当寄存器分配完成后，会请求一个附加的指令计划pass。这种优化对寄存器较小，并且load memory操作时间大于一个时钟周期的机器有非常好的效果。\n\n\n-fsched-interblock：这种技术使编译器能够跨越指令块调度指令。 这可以非常灵活地移动指令以便等待期间完成的工作最大化。\n\n\n-fsched-spec-load：允许一些load指令进行一些投机性的动作。（具体不详）相同功能的还有-fsched-spec-load-dangerous，允许更多的load指令进行投机性操作。这两个选项在选中-fschedule-insns时默认打开。\n\n\n-fcaller-saves：通过存储和恢复call调用周围寄存器的方式，使被call调用的value可以被分配给寄存器，这种只会在看上去能产生更好的代码的时候才被使用。（如果调用多个函数, 这样能够节省时间, 因为只进行一次寄存器的保存和恢复操作, 而不是在每个函数调用中都进行。）\n\n\n-fpeephole2：允许计算机进行特定的观察孔优化(这个不晓得是什么意思)，-fpeephole与-fpeephole2的差别在于不同的编译器采用不同的方式，由的采用-fpeephole，有的采用-fpeephole2，也有两种都采用的。\n\n\n-freorder-blocks：在编译函数的时候重新安排基本的块，目的在于减少分支的个数，提高代码的局部性。\n\n\n-freorder-functions：在编译函数的时候重新安排基本的块，目的在于减少分支的个数，提高代码的局部性。这种优化的实施依赖特定的已存在的信息：.text.hot用于告知访问频率较高的函数，.text.unlikely用于告知基本不被执行的函数。\n\n\n-fstrict-aliasing：这种技术强制实行高级语言的严格变量规则。 对于c和c++程序来说, 它确保不在数据类型之间共享变量. 例如, 整数变量不和单精度浮点变量使用相同的内存位置。\n\n\n-funit-at-a-time：在代码生成前，先分析整个的汇编语言代码。这将使一些额外的优化得以执行，但是在编译器间需要消耗大量的内存。（有资料介绍说：这使编译器可以重新安排不消耗大量时间的代码以便优化指令缓存。）\n\n\n-falign-functions：这个选项用于使函数对准内存中特定边界的开始位置。 大多数处理器按照页面读取内存，并且确保全部函数代码位于单一内存页面内, 就不需要叫化代码所需的页面。\n\n\n-falign-jumps：对齐分支代码到2的n次方边界。在这种情况下，无需执行傀儡指令（dummy operations）\n\n\n-falign-loops：对齐循环到2的n次幂边界。期望可以对循环执行多次，用以补偿运行dummy operations所花费的时间。\n\n\n-falign-labels：对齐分支到2的n次幂边界。这种选项容易使代码速度变慢，原因是需要插入一些dummy operations当分支抵达usual flow of the code.\n\n\n-fcrossjumping：这是对跨越跳转的转换代码处理， 以便组合分散在程序各处的相同代码。 这样可以减少代码的长度， 但是也许不会对程序性能有直接影响。\n\n\n O3\n-O3： 在O2的基础上进行更多的优化\n例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。在包含了O2所有的优化的基础上，又打开了以下优化选项：\n\n\n-finline-functions：内联简单的函数到被调用函数中。\n\n\n-fweb：构建用于保存变量的伪寄存器网络。 伪寄存器包含数据, 就像他们是寄存器一样, 但是可以使用各种其他优化技术进行优化, 比如cse和loop优化技术。这种优化会使得调试变得更加的不可能，因为变量不再存放于原本的寄存器中。\n\n\n-frename-registers：在寄存器分配后，通过使用registers left over来避免预定代码中的虚假依赖。这会使调试变得非常困难，因为变量不再存放于原本的寄存器中了。\n\n\n-funswitch-loops：将无变化的条件分支移出循环，取而代之的将结果副本放入循环中。\n\n\n Os\n相当于-O2.5。是使用了所有-O2的优化选项，但又不缩减代码尺寸的方法。\n 参考文献\nOptions That Control Optimization\ngcc编译优化-O0 -O1 -O2 -O3 -OS解析\n","categories":["Linux软件开发"]},{"title":"Ip地址详解","url":"/2023/07/19/ip%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3/","content":"IP地址是32位的二进制数值，用于在TCP/IP通讯协议中标记每台计算机的地址。通常我们使用点式十进制来表示，如192.168.1.6等。也就是说IP地址有两种表示形式：二进制和点式十进制，一个32位IP地址的二进制是由4个8位域组成。即11000000 10101000 00000001 00000110，也就是192.168.1.6。\nIP地址形式：X.X.X.X\nX的范围：0-255\n\n 子网掩码：subnet mask = SM\n局域网通信规则：在同一个局域网中，所有的IP必须在同一网段中才可以互相通信！\nIP地址构成：网络位+主机位 （网络位相同的IP地址，为同一网段）\n子网掩码： 用来确定IP地址的网络位\n子网掩码如何确认网络位：与255对应的数字为网络位，与0对应的数字为主机位\n\n255.0.0.0\n255.255.0.0\n255.255.255.0\n\n例如：\n\n\n10.1.1.1 255.0.0.0\n获知：10.1.1.1属于10网段，名字叫1.1.1\n\n\n10.1.1.1 255.255.0.0\n获知：10.1.1.1属于10.1网段，名字叫1.1\n\n\n10.1.1.1 255.255.255.0\n获知：10.1.1.1属于10.1.1网段，名字叫1\n\n\n【注意】：1个IP地址，必须配套一个子网掩码\n IP地址详解\n国际标准组织ISO定义地址分类：五大类 （是以IP地址的第一位进行区分的）\n\n\nA类： 1-126默认子网掩码：255.0.0.0\n由1字节的网络地址和3字节主机地址组成\n可用的A类网络有126个，每个网络能容纳1亿多个主机。\n\n\nB类： 128-191默认子网掩码：255.255.0.0\n由2个字节的网络地址和2个字节的主机地址组成\n可用的B类网络有16382个，每个网络能容纳6万多个主机。\n\n\nC类： 192-223默认子网掩码：255.255.255.0\n由3字节的网络地址和1字节的主机地址组成\nC类网络可达209万余个，每个网络能容纳254个主机。\n\n\nD类： 224-239组播地址\n\n\nE类： 240-254科研使用\n\n\n如：\n10.1.1.1属于A类\n192.168.1.1属于C类\n注：\n\n目前我们可以使用的只有A、B、C，3类\nA、B、C，3类的子网掩码可以修改！\n255开头得当作子网掩码来使用了\n127开头当作回环地址：如127.0.0.1，代表自己\n0.0.0.0代表本机\n主机位全0代表网段，主机位全1代表该网段的广播地址\n\n\n一个完整的IP地址信息应该包括IP地址、子网掩码、默认网关和DNS4部分内容，只有当它们各司其职、协同工作时，我们才可以访问Internet，并被Internet中的计算机所访问。\n","categories":["Linux软件开发"]},{"title":"sysroot目录的作用","url":"/2025/04/14/sysroot%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"在软件开发和交叉编译中，sysroot（System Root）是一个关键概念，它定义了目标系统根目录的路径，帮助开发工具链（如编译器、链接器）在构建过程中正确找到目标平台的头文件、库和其他依赖资源。以下是其核心作用的详细说明：\n\n 1. sysroot 的核心作用\n\n隔离开发环境：\n在交叉编译（例如在 x86 主机上编译 ARM 程序）时，sysroot 会指定目标设备的根文件系统路径，确保编译工具链不会误用宿主机的头文件和库。\n路径重定向：\n当工具链访问标准路径（如 /usr/include、/lib）时，实际会从 sysroot 指定的目录下查找文件（即 sysroot/usr/include、sysroot/lib）。\n\n 2. 典型使用场景\n (1) 交叉编译（Cross-Compilation）\n假设你在 x86_64 主机上编译一个运行在 ARM 嵌入式设备的程序：\n\n目标设备的根文件系统可能存放在主机的 /opt/arm-sysroot 目录下。\n通过指定 --sysroot=/opt/arm-sysroot，编译器会从该目录下查找 ARM 架构的头文件和库，而非宿主机的 x86 资源。\n\n示例命令：\narm-linux-gnueabihf-gcc --sysroot=/opt/arm-sysroot -o myapp myapp.c\n (2) 嵌入式开发\n嵌入式设备的文件系统通常通过工具（如 Buildroot、Yocto）生成，并导出为 sysroot，供开发工具链使用。\n (3) 容器化构建\n在 Docker 容器中构建应用时，sysroot 可指向容器内的根文件系统，避免依赖宿主机环境。\n 3. sysroot 的目录结构\n一个典型的 sysroot 目录结构如下：\n/opt/arm-sysroot├── lib         # 目标系统的库文件（如 libc.so）├── usr│   ├── include # 目标系统的头文件（如 stdio.h）│   └── lib     # 目标系统的其他库└── ...\n 4. 如何配置 sysroot\n (1) 编译器参数\n在编译时通过 --sysroot 指定路径：\ngcc --sysroot=/path/to/sysroot -o output input.c\n (2) 工具链配置\n交叉编译工具链（如 arm-linux-gnueabihf-gcc）通常预置了默认的 sysroot。可通过 -print-sysroot 查看：\narm-linux-gnueabihf-gcc -print-sysroot\n (3) 构建系统配置\n在 CMake 中设置 CMAKE_SYSROOT：\nset(CMAKE_SYSROOT &quot;/opt/arm-sysroot&quot;)\n在 Autotools 中通过 --with-sysroot：\n./configure --with-sysroot=/opt/arm-sysroot\n 5. 常见问题与解决\n (1) 错误：头文件或库找不到\n\n原因：sysroot 路径未正确配置，或目标文件系统中缺失依赖。\n解决：\n\n检查 sysroot 路径是否存在且包含目标系统的 include 和 lib 目录。\n使用 find 命令验证文件是否存在：find /opt/arm-sysroot -name &quot;stdio.h&quot;\n\n\n\n\n (2) 错误：链接到宿主机库\n\n原因：未正确隔离环境，工具链仍使用宿主机默认路径。\n解决：\n\n确保编译命令包含 --sysroot。\n使用 -nostdinc 和 -nostdlib 强制禁用宿主机默认路径。\n\n\n\n 6. 对比 sysroot 与 chroot\n\nsysroot：仅影响编译工具链的路径查找，用于构建阶段。\nchroot：改变进程的根目录视图，用于运行时环境隔离。\n\n 总结\n\nsysroot 是目标系统根目录的镜像，确保编译工具链使用正确的资源。\n在交叉编译、嵌入式开发和容器化构建中必不可少，避免环境污染和兼容性问题。\n配置时需确保目标系统的头文件、库和工具链架构（如 ARM、x86）一致。\n\n","categories":["CyberRT中间件","Linux软件开发"]},{"title":"个人博客网站搭建","url":"/2025/07/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/","content":"Ubuntu18.04 + GitHub + Hexo免费配置个人博客\n\n 必要环境安装\n git\nsudo apt install git\n一般问题不大\n npm\n\nnpm (Node Package Manager)是一个用于JavaScript和Node.js的包管理器。它不仅是Node.js的默认包管理器，还提供了发布和共享代码、管理依赖、版本控制等功能。npm允许开发者从全球的代码库中获取并安装Node.js模块，这些模块可以用于构建应用程序、工具和包等。\n简单来说，npm就像一个巨大的软件仓库，里面存放了各种JavaScript和Node.js的模块（也叫包）。\n\nsudo apt-get install npm\n\nChatGPT建议使用nvm安装Node.js + npm（更干净灵活）。\n Node.js\n不想让系统包干扰，可以用nvm（Node Version Manager）来安装Node.js + npm：\n# 安装 nvmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash# 激活 nvm（或者重启终端）export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;# 安装 Node.js 最新 LTS 版本（或指定版本）nvm install --lts# 检查版本node -vnpm -v\n如果报以下错误：\n\n说明当前系统的GLIBC版本太低，而你安装的Node.js二进制文件依赖于更高版本的GLIBC（2.28）。\n\n🧠 原因分析\nUbuntu 18.04 的默认 glibc 是 2.27。\nNode.js 官方预构建二进制从某个版本开始依赖 glibc &gt;= 2.28（通常从 Node.js 18 或更高版本开始）。\n所以如果在 Ubuntu 18.04 或老系统上安装了较新的 Node.js，就会出这个错。\n\n\n\n彻底删除旧版本Node.js，以防系统中残留了之前的node安装路径或链接。\n执行以下命令清理旧的node/npm：\n sudo apt purge -y nodejs npmsudo rm -rf /usr/local/bin/node /usr/local/bin/npmsudo rm -rf /usr/bin/node /usr/bin/npmsudo rm -rf ~/.npm ~/.nvm ~/.node*hash -r\n\n\n安装 nvm（Node Version Manager）\n # 下载并安装 nvmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash# 加载 nvm（也可以重启终端）export NVM_DIR=&quot;$HOME/.nvm&quot;source &quot;$NVM_DIR/nvm.sh&quot;\n\n\n使用nvm安装Node.js 16\n nvm install 16nvm use 16nvm alias default 16\n\n\n验证：\n node -v      # 应输出 v16.x.xnpm -v       # 应输出 8.x.x\n\n\n\n 🚀 总结\n使用 nvm 方式安装Node.js是：\n\n✅ 最兼容的\n✅ 不依赖系统 glibc\n✅ 不需要 root 权限\n✅ 可随时切换 Node.js 版本\n\n nvm使用\n\n\n查看已安装的Node.js版本\n  nvm ls\n\n\n\n版本切换\n  # 切换使用 Node.js 14nvm use 14# 切回 Node.js 16nvm use 16\n\n\n设置默认版本（打开终端自动使用）\n  # 以后打开终端就会自动使用 Node.js 16。nvm alias default 16\n\n\n如果没有安装目标版本\n  # 先安装再切换：nvm install 14nvm use 14\n\n\n 基于Hexo框架搭建\n\nHexo项目中，源代码（markdown、主题等） 和生成后的网页是分开的\n\n一个仓库存放Hexo源码（如hexo-iNog-blog）（可选）\n一个仓库存放部署页面（如i-nog.github.io）\n\n\n\n\n下载 Hexo\n  npm install hexo-cli -g\n\n安装hexo插件  # 按需选择安装npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --save # 本人只安装这个npm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save\n\n\n\n\n创建框架\n  (base) lxp@lxp-os:~/projects$ mkdir hexo-iNog-blog(base) lxp@lxp-os:~/projects$ cd hexo-iNog-blog/(base) lxp@lxp-os:~/projects/hexo-iNog-blog$ hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesINFO  Start blogging with Hexo!(base) lxp@lxp-os:~/projects/hexo-iNog-blog$ ls_config.landscape.yml  _config.yml  node_modules  package.json  package-lock.json  scaffolds  source  themes\nhexo的文件结构：\n\npublic最终所见网页的所有内容\nnode_modules插件以及hexo所需node.js模块\n_config.yml站点配置文件，设定一些公开信息等\npackage.json应用程序信息，配置hexo运行所需js包\nscaffolds模板文件夹，新建文章，会默认包含对应模板内容\nthemes存放主题文件，hexo根据主题生成静态网页（速度贼快）\nsource用于存放用户资源（除posts文件夹，其余命名方式为 “ + 文件名”的文件被忽略）\n\n注意：hexo-iNog-blog/文件夹无需配置git仓库，除非个人想进行版本管理，方便长期开发。\n\n\n下载自己喜欢的主题\n在Themes查找自己喜欢的主题，比如Keep主题\n  # 在 hexo-iNog-blog/ 下，Keep主题git clone https://github.com/XPoet/hexo-theme-keep themes/keep# 或Fengye主题git clone https://github.com/chen-yingfa/hexo-theme-fengye.git themes/fengye# 或Fluid主题git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid\n\n\n配置主题\n在Hexo配置文件_config.yml中将theme设置为keep。\n\n\n\n自定义主题内容\n需要修改themes/keep/_config.yml文件\n\n\n\n本地预览\n  hexo clean //执行此命令后继续下一条hexo g // 生成博客目录，hexo generate 的缩写hexo s // 本地预览，hexo server 的缩写\n\n\n\n 创建及配置Gitbub Pages\n\n\n创建同用户名仓库，且是公共(Public)仓库\n\nGitHub Pages只支持公共仓库免费部署。如果仓库是私有的：\n\n地址不会生成；\n或者会提示升级为付费账户。\n\n\n\n设置仓库Pages信息\n\n\n\n本地关联github，需配置_config.yml文件中将deploy\n注意，是用户名.github.io那个仓库 。\n\n同时还需要配置git参数，如下：\n git config --global user.name &quot;用户名&quot;git config --global user.email &quot;******@gmail.com&quot;\n注意：是要配置全局的name和email。\n\n\n上传\n # 在自己的博客目录下，比如 hexo-iNog-blog/ 目录下# 清除缓存hexo clean# 生成hexo目录hexo generate# 可以先本地预览hexo server# 部署到远程仓库hexo deploy # 缩写 hexo d，如果失败，需要先安装 npm install hexo-deployer-git --save\ndeploy过程会生成.deploy_git/文件夹（内容同public/目录），自动关联到用户名.github.io仓库，将文件夹的内容推送到该仓库。\n\n\n❌ 不推荐直接把Hexo项目源码上传到.github.io仓库\n因为GitHub Pages无法直接解析source/里的.md文件，它只支持静态HTML页面。\n\n\n 资源压缩\n\n\n在 Hexo 项目根目录下安装 hexo-all-minifier\n cd your-hexonpm install hexo-all-minifier\n\n\n在 Hexo 配置文件 _config.yml 文件中，添加以下配置项\n all_minifier: true\n\n\n注意：Node.js需要升级到 18 或更高版本。\n 图片压缩工具\n网上搜索一大堆推荐，个人使用uTools工具里面的插件TinyJpg，不是通过API，插件自带压缩算法，压缩速度很快，感觉蛮好用，大家觉得好用的话，记得好评给作者一点动力（鞭策下作者这头牛马，继续优化，提高下压缩效率）。\n\n 图片生成\n\n本地部署\nMac本地安装部署Stable diffusion最全教程，AI绘画无痛入门指南\n在线生成\n\nBing Image Creator\n即梦AI\n\n\n\n Latex渲染\n 介绍\nLaTeX公式渲染引擎：\n\nMathJax\nKaTex\n\nmarkdown渲染器：\n\nhexo-renderer-pandoc\nhexo-renderer-markdown-it\nhexo-renderer-markdown-it-plus\n\n 使用\n因为Katex能使用\\\\换行，之前文档块公式都是采用\\\\换行，所以采用katex；\n本人采用markdown_it_plus（自带katex）。\n\n\n安装markdown-it-plus\n  npm i hexo-renderer-markdown-it-plus --save# --save 是 npm 的一个命令参数，用来表示：# 安装这个依赖，并将它写入 package.json 的 dependencies 字段中。# 但注意：从 npm v5（Node 8+）开始，默认就会自动写入 dependenciesnpm install hexo-renderer-markdown-it-plus# 效果是一样的，--save 可写可不写，它只是 早期版本需要显式加上。# 基于 package.json，使用 npm install 可以直接安装全部依赖\nmarkdown_it_plus默认启用的插件：\n\nmarkdown-it-emoji # 支持表情符号\nmarkdown-it-sub # 支持下标\nmarkdown-it-sup # 支持上标\nmarkdown-it-deflist # 支持定义列表\nmarkdown-it-abbr # 支持缩略词\nmarkdown-it-footnote # 支持脚注\nmarkdown-it-ins # 支持插入文本\nmarkdown-it-mark # 支持高亮文本\n@iktakahiro/markdown-it-katex # 公式渲染引擎\nmarkdown-it-toc-and-anchor # 目录\n\n\n\n安装额外插件\n  npm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n\nmarkdown-it-checkbox # 支持复选框\nmarkdown-it-imsize # 自定义图片宽高\nmarkdown-it-expandable # 折叠/展开内容\n\n\n\n# hexo项目的_config.yml文件markdown_it_plus:    highlight: true  # 是否启用代码高亮（内置 Prism.js）    html: true       # 允许原始 HTML 标签（&lt;font&gt;...&lt;/font&gt;）    xhtmlOut: true   # 输出 XHTML 格式标签（如 &lt;br/&gt; 而不是 &lt;br&gt;）    breaks: true     # 自动将换行符转换为 &lt;br&gt;    langPrefix:      # 代码块的语言 class 前缀，例如 language-python    linkify: true    # 自动识别链接并转为 &lt;a&gt;    typographer:     # 使用智能标点（如自动替换 -- 为 —）    quotes: “”‘’     # 引号样式（中英文分别）    plugins:        - plugin:            name: markdown-it-mark            enable: false # 关闭        - plugin:            name: markdown-it-checkbox            enable: true # 开启\n 双重渲染问题\n\n在使用 hexo-renderer-markdown-it-plus 时，它通常会生成如下结构：\n&lt;span class=&quot;katex&quot;&gt;  &lt;span class=&quot;katex-mathml&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;...&lt;/span&gt; &lt;!-- 这个是你要隐藏的 --&gt;&lt;/span&gt;\n\n其中：\n\nkatex-mathml 是给屏幕阅读器（辅助功能）用的。\nkatex-html 是用来实际显示公式的。\n有时 Keep 主题或 MathJax 会再渲染一次，导致重复。\n\n解决方式：\n使用 可注入的 CSS 样式 来隐藏 katex-html 元素，避免公式重复显示。\n\n\nkeep主题配置\n  # _config.keep.ymlinject:  enable: true  # Option values: true | false  css:\t- /css/custom-1.css\t# e.g.\t# - /css/custom-1.css\t# - /css/custom-2.css\t# - ...  js:\t-\t# e.g.\t# - /js/custom-1.js\t# - /js/custom-2.js\t# - ...\n\n\n增加source/css/custom-1.css文件\n  .katex-html &#123;\tdisplay: none !important;&#125;\n\n\n 评论系统搭建\n\ngiscus\n\n目前 Keep 主题支持该插件，所以本人直接使用该插件，按照说明配置就行；主要就是创建一个 public 的仓库，然后安装 giscus app，在打开 Discussions 功能；\nKeep 主题暴露了 Giscus 评论插件五个配置项：repo、repo_id、category、category_id、reactions_enabled，根据生成的配置项填写就行\n\n\n\nutterances\n\n与上者类似，目前 Keep 主题不支持，所以没深入研究。\n\n\n\n两者都会生成&lt;script src=...&lt;/script&gt;，在哪个位置添加该标签，评论就出现在哪个位置。\n 与JopLin笔记本配合（无很好适配）\nJoplin Publisher插件教程\n\n配置仓库的读写权限\n\n\n\n结果：\n\n\n 参考文献\nKeep 主题使用手册\nUbuntu20.04 +GitHub+Hexo 0基础0成本免费配置个人博客\n快速搭建个人博客 —— 保姆级教程\n","categories":["博客搭建"]},{"title":"共享库（.so文件）的版本管理","url":"/2025/04/14/%E5%85%B1%E4%BA%AB%E5%BA%93%EF%BC%88.so%E6%96%87%E4%BB%B6%EF%BC%89%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","content":"在 Linux 系统中，共享库（.so 文件）的版本管理通常通过软链接（符号链接）实现层级式的版本指向机制。你提到的 .so、.so.5 和 .so.5.58 之间的软链接关系，实际是一种标准化的版本控制策略，并非真正的“相互链接”，而是通过层级指向最终的具体版本文件。以下是其作用和原理的详细解释：\n\n 1. 共享库版本命名的规则\nLinux 共享库的版本通常遵循以下格式：\n\nlibname.so（无版本号）：称为 “linker name”，是编译时程序默认链接的通用名称。\nlibname.so.x（主版本号，如 .so.5）：表示 主版本，主版本变化意味着接口不兼容。\nlibname.so.x.y.z（完整版本号，如 .so.5.58.0）：包含主版本、次版本和修订号，次版本和修订号的更新通常保持兼容性。\n\n 2. 软链接的作用\n通过软链接建立层级关系，例如：\nlibfoo.so      → libfoo.so.5         # linker name → 主版本libfoo.so.5    → libfoo.so.5.58.0    # 主版本 → 具体实现版本\n\nlibfoo.so：编译时程序直接链接的名称（如 -lfoo），指向当前主版本。\nlibfoo.so.5：标识主版本，保证接口兼容性，指向最新的次版本（如 5.58.0）。\nlibfoo.so.5.58.0：实际包含代码的库文件。\n\n 3. 为什么需要这种设计？\n (1) 编译与运行的解耦\n\n编译时：开发者只需指定 -lfoo，链接器会自动查找 libfoo.so。\n运行时：动态加载器通过 libfoo.so.5 找到具体版本，确保兼容性。\n\n (2) 版本升级的平滑过渡\n\n主版本不变：当库从 5.58.0 升级到 5.59.0 时，只需将 libfoo.so.5 的软链接指向新版本，无需重新编译程序。\n主版本升级：若接口不兼容（如升级到 6.0.0），则创建新的 libfoo.so.6，旧程序仍依赖 libfoo.so.5。\n\n (3) 多版本共存\n系统可以同时安装多个主版本的库（如 libfoo.so.5 和 libfoo.so.6），程序按需选择依赖。\n 4. 实际示例\n假设库的版本为 5.58.0，文件结构如下：\n# 实际库文件（包含代码）/usr/lib/libfoo.so.5.58.0# 主版本软链接/usr/lib/libfoo.so.5 → libfoo.so.5.58.0# 编译时链接名称/usr/lib/libfoo.so → libfoo.so.5\n\n编译命令：gcc -o myapp myapp.c -lfoo  # 链接 libfoo.so\n\n运行时加载：\n程序会根据 libfoo.so.5 加载 libfoo.so.5.58.0。\n\n 5. 特殊情况：循环链接？\n如果出现类似 libfoo.so → libfoo.so.5 且 libfoo.so.5 → libfoo.so 的循环链接，这会导致链接器报错（如 too many levels of symbolic links）。这种情况是配置错误，需修正为层级指向。\n 6. 如何管理这些链接？\n\n包管理器自动处理：通过 apt、yum 等安装库时，自动创建正确的软链接。\n手动维护：\n更新库版本时，需调整软链接指向：# 更新主版本链接ln -sf libfoo.so.5.59.0 libfoo.so.5# 更新编译时链接（可选）ln -sf libfoo.so.5 libfoo.so\n\n\n 总结\n\n.so、.so.5、.so.5.58 的软链接是层级关系，不是相互循环链接。\n目的是为了兼容性管理和版本控制，确保程序编译和运行时能无缝适配不同版本的库。\n若出现异常循环链接，需检查并修正为层级结构。\n\n","categories":["Linux软件开发"]},{"title":"（二）分段加加速度算法（PiecewiseJerk）之 路径规划代码实现","url":"/2021/09/14/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"基于Apollo r5.5.0 版本代码，其实后续版本算法代码基本没有差变。\n\n 代码实现\n/* * @brief: * This class solve an optimization problem: * x * | * |                       P(s1, x1)  P(s2, x2) * |            P(s0, x0)                       ... P(s(k-1), x(k-1)) * |P(start) * | * |________________________________________________________ s * * we suppose s(k+1) - s(k) == s(k) - s(k-1) * * Given the x, x&#x27;, x&#x27;&#x27; at P(start),  The goal is to find x0, x1, ... x(k-1) * which makes the line P(start), P0, P(1) ... P(k-1) &quot;smooth&quot;. */\n Class PiecewiseJerkProblem\n先定义一个父类\n// piecewise_jerk_problem.hclass PiecewiseJerkProblem &#123;  ... protected:  // naming convention follows osqp solver.  // 纯虚函数，必须由子类实现  virtual void CalculateKernel(std::vector&lt;c_float&gt;* P_data,                               std::vector&lt;c_int&gt;* P_indices,                               std::vector&lt;c_int&gt;* P_indptr) = 0;  // 纯虚函数，必须由子类实现  virtual void CalculateOffset(std::vector&lt;c_float&gt;* q) = 0;  // 虚函数，子类可改写  virtual void CalculateAffineConstraint(std::vector&lt;c_float&gt;* A_data,                                         std::vector&lt;c_int&gt;* A_indices,                                         std::vector&lt;c_int&gt;* A_indptr,                                         std::vector&lt;c_float&gt;* lower_bounds,                                         std::vector&lt;c_float&gt;* upper_bounds);  // 虚函数，子类可改写  virtual OSQPSettings* SolverDefaultSettings();  ...&#125;// piecewise_jerk_problem.ccPiecewiseJerkProblem::PiecewiseJerkProblem(    const size_t num_of_knots, const double delta_s,    const std::array&lt;double, 3&gt;&amp; x_init) &#123;  CHECK_GE(num_of_knots, 2);  // 设定优化点的个数  num_of_knots_ = num_of_knots;  // 初始值设定  x_init_ = x_init;  // 设定ds  delta_s_ = delta_s;  // 初始化x边界  x_bounds_.resize(num_of_knots_,                   std::make_pair(-kMaxVariableRange, kMaxVariableRange));  // 初始化dx边界  dx_bounds_.resize(num_of_knots_,                    std::make_pair(-kMaxVariableRange, kMaxVariableRange));  // 初始化ddx边界  ddx_bounds_.resize(num_of_knots_,                     std::make_pair(-kMaxVariableRange, kMaxVariableRange));&#125;\n PiecewiseJerkProblem::FormulateProblem()\n构造用OSQP解决器解决的问题，需要知道优化变量总数n、约束条件数量m、矩阵P、q、A以及边界条件l和u。\nOSQPData* PiecewiseJerkProblem::FormulateProblem() &#123;  // calculate kernel  std::vector&lt;c_float&gt; P_data;  std::vector&lt;c_int&gt; P_indices;  std::vector&lt;c_int&gt; P_indptr;  CalculateKernel(&amp;P_data, &amp;P_indices, &amp;P_indptr);  // calculate affine constraints  std::vector&lt;c_float&gt; A_data;  std::vector&lt;c_int&gt; A_indices;  std::vector&lt;c_int&gt; A_indptr;  std::vector&lt;c_float&gt; lower_bounds;  std::vector&lt;c_float&gt; upper_bounds;  CalculateAffineConstraint(&amp;A_data, &amp;A_indices, &amp;A_indptr, &amp;lower_bounds,                            &amp;upper_bounds);  // calculate offset  std::vector&lt;c_float&gt; q;  CalculateOffset(&amp;q);  OSQPData* data = reinterpret_cast&lt;OSQPData*&gt;(c_malloc(sizeof(OSQPData)));  CHECK_EQ(lower_bounds.size(), upper_bounds.size());    size_t kernel_dim = 3 * num_of_knots_;  size_t num_affine_constraint = lower_bounds.size();  // 设定优化变量的个数 3n  data-&gt;n = kernel_dim;  // 设定限制条件的维度  data-&gt;m = num_affine_constraint;  // 矩阵P kernel_dim行，kernel_dim列  data-&gt;P = csc_matrix(kernel_dim, kernel_dim, P_data.size(), CopyData(P_data),                       CopyData(P_indices), CopyData(P_indptr));  data-&gt;q = CopyData(q);  // 矩阵A num_affine_constraint行，kernel_dim列  data-&gt;A =      csc_matrix(num_affine_constraint, kernel_dim, A_data.size(),                 CopyData(A_data), CopyData(A_indices), CopyData(A_indptr));  data-&gt;l = CopyData(lower_bounds);  data-&gt;u = CopyData(upper_bounds);  return data;&#125;\n PiecewiseJerkProblem::Optimize()\nbool PiecewiseJerkProblem::Optimize(const int max_iter) &#123;  // 构建问题  OSQPData* data = FormulateProblem();  // 配置OSQP解决器参数  OSQPSettings* settings = SolverDefaultSettings();  settings-&gt;max_iter = max_iter;  // 构建osqp解决器  OSQPWorkspace* osqp_work = osqp_setup(data, settings);  // 使用解决器处理问题  osqp_solve(osqp_work);  // 解的状态及返回值  auto status = osqp_work-&gt;info-&gt;status_val;  if (status &lt; 0 || (status != 1 &amp;&amp; status != 2)) &#123;    AERROR &lt;&lt; &quot;failed optimization status:\\t&quot; &lt;&lt; osqp_work-&gt;info-&gt;status;    osqp_cleanup(osqp_work);    FreeData(data);    c_free(settings);    return false;  &#125; else if (osqp_work-&gt;solution == nullptr) &#123;    AERROR &lt;&lt; &quot;The solution from OSQP is nullptr&quot;;    osqp_cleanup(osqp_work);    FreeData(data);    c_free(settings);    return false;  &#125;  // extract primal results  x_.resize(num_of_knots_);  dx_.resize(num_of_knots_);  ddx_.resize(num_of_knots_);  // 输出结果，以及还原比例缩放  for (size_t i = 0; i &lt; num_of_knots_; ++i) &#123;    x_.at(i) = osqp_work-&gt;solution-&gt;x[i] / scale_factor_[0];    dx_.at(i) = osqp_work-&gt;solution-&gt;x[i + num_of_knots_] / scale_factor_[1];    ddx_.at(i) =        osqp_work-&gt;solution-&gt;x[i + 2 * num_of_knots_] / scale_factor_[2];  &#125;  // Cleanup  osqp_cleanup(osqp_work);  FreeData(data);  c_free(settings);  return true;&#125;\n OSQP解决器其解的状态及返回值\n\n\n\n状态\n常量\n返回值\n\n\n\n\n求解成功solved\nOSQP_SOLVED\n1\n\n\n求解错误solved inaccurate\nOSQP_SOLVED_INACCURATE\n2\n\n\n达到最大迭代次数maximum iterations reached\nOSQP_MAX_ITER_REACHED\n-2\n\n\n原始不可行primal infeasible\nOSQP_PRIMAL_INFEASIBLE\n-3\n\n\n原始不可行错误primal infeasible inaccurate\nOSQP_PRIMAL_INFEASIBLE_INACCURATE\n3\n\n\n双重不可行dual infeasible\nOSQP_DUAL_INFEASIBLE\n-4\n\n\n双重不可行错误dual infeasible inaccurate\nOSQP_DUAL_INFEASIBLE_INACCURATE\n4\n\n\n被用户打断interrupted by user\nOSQP_SIGINT\n-5\n\n\n运行时间超时run time limit reached\nOSQP_TIME_LIMIT_REACHED\n-6\n\n\n未解决unsolved\nOSQP_UNSOLVED\n-10\n\n\n问题非凸problem non convex\nOSQP_NON_CVX\n-7\n\n\n\n注意：OSQP求解的是二次型cost凸优化问题，如果当一个或多个特征值“明显”为负，即问题不是半正定，此时OSQP能检查出错误（问题非凸），但是当特征值负的“不明显”时，可能检测不出来非凸性，需要用户执行判断。\n PiecewiseJerkProblem::SolverDefaultSettings()\nOSQPSettings* PiecewiseJerkProblem::SolverDefaultSettings() &#123;  // Define Solver default settings  OSQPSettings* settings =      reinterpret_cast&lt;OSQPSettings*&gt;(c_malloc(sizeof(OSQPSettings)));  osqp_set_default_settings(settings);  settings-&gt;polish = true;  settings-&gt;verbose = FLAGS_enable_osqp_debug;  settings-&gt;scaled_termination = true;  return settings;&#125;\n PiecewiseJerkProblem::CalculateAffineConstraint()\n在父类已经构造了计算矩阵A\\textbf{A}A函数。\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\n其中\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×nA5=(10⋯0)1×n\\begin{aligned}\n\\textbf{A}_1 &amp; = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n} \\\\\n\\textbf{A}_2 &amp; = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n} \\\\\n\\textbf{A}_3 &amp; = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 &amp; = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n} \\\\\n\\textbf{A}_5 &amp; =\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\n\\end{aligned}\nA1​A2​A3​A4​A5​​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​=−ds⋅In−1×n​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​=(1​0​⋯​0​)1×n​​\nvoid PiecewiseJerkProblem::CalculateAffineConstraint(    std::vector&lt;c_float&gt;* A_data, std::vector&lt;c_int&gt;* A_indices,    std::vector&lt;c_int&gt;* A_indptr, std::vector&lt;c_float&gt;* lower_bounds,    std::vector&lt;c_float&gt;* upper_bounds) &#123;  // 3N params bounds on x, x&#x27;, x&#x27;&#x27;  // 3(N-1) constraints on x, x&#x27;, x&#x27;&#x27;  // 3 constraints on x_init_  // n表示优化的点数  const int n = static_cast&lt;int&gt;(num_of_knots_);  // 优化变量数量为3n  const int num_of_variables = 3 * n;  // 由理论推导，限制条件数量为6n  const int num_of_constraints = num_of_variables + 3 * (n - 1) + 3;  lower_bounds-&gt;resize(num_of_constraints);  upper_bounds-&gt;resize(num_of_constraints);  // 设定为3n列，variables对应矩阵A  std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; variables(      num_of_variables);  int constraint_index = 0;  // set x, x&#x27;, x&#x27;&#x27; bounds  for (int i = 0; i &lt; num_of_variables; ++i) &#123;    if (i &lt; n) &#123;      // 设定矩阵A关于x的系数，以及对应的边界      variables[i].emplace_back(constraint_index, 1.0);      lower_bounds-&gt;at(constraint_index) =          x_bounds_[i].first * scale_factor_[0];      upper_bounds-&gt;at(constraint_index) =          x_bounds_[i].second * scale_factor_[0];    &#125; else if (i &lt; 2 * n) &#123;      // 设定矩阵A关于x&#x27;的系数，以及对应的边界      variables[i].emplace_back(constraint_index, 1.0);      lower_bounds-&gt;at(constraint_index) =          dx_bounds_[i - n].first * scale_factor_[1];      upper_bounds-&gt;at(constraint_index) =          dx_bounds_[i - n].second * scale_factor_[1];    &#125; else &#123;      // 设定矩阵A关于x&#x27;&#x27;的系数，以及对应的边界      variables[i].emplace_back(constraint_index, 1.0);      lower_bounds-&gt;at(constraint_index) =          ddx_bounds_[i - 2 * n].first * scale_factor_[2];      upper_bounds-&gt;at(constraint_index) =          ddx_bounds_[i - 2 * n].second * scale_factor_[2];    &#125;    ++constraint_index;  &#125;  // 数量检查  CHECK_EQ(constraint_index, num_of_variables);  // x(i-&gt;i+1)&#x27;&#x27;&#x27; = (x(i+1)&#x27;&#x27; - x(i)&#x27;&#x27;) / delta_s  // 设定矩阵A关于加加速度的限制条件，转化为关于加速度的限制条件，及其对应边界，也就是A1  // n-1行  for (int i = 0; i + 1 &lt; n; ++i) &#123;    variables[2 * n + i].emplace_back(constraint_index, -1.0);    variables[2 * n + i + 1].emplace_back(constraint_index, 1.0);    lower_bounds-&gt;at(constraint_index) =        dddx_bound_.first * delta_s_ * scale_factor_[2];    upper_bounds-&gt;at(constraint_index) =        dddx_bound_.second * delta_s_ * scale_factor_[2];    ++constraint_index;  &#125;  // x(i+1)&#x27; - x(i)&#x27; - 0.5 * delta_s * x(i)&#x27;&#x27; - 0.5 * delta_s * x(i+1)&#x27;&#x27; = 0  // 设定矩阵A关于速度的连续性，即速度等式约束，A1 A2，注意交叉乘对应的缩放比例  // n-1行  for (int i = 0; i + 1 &lt; n; ++i) &#123;    variables[n + i].emplace_back(constraint_index, -1.0 * scale_factor_[2]);    variables[n + i + 1].emplace_back(constraint_index, 1.0 * scale_factor_[2]);    variables[2 * n + i].emplace_back(constraint_index,                                      -0.5 * delta_s_ * scale_factor_[1]);    variables[2 * n + i + 1].emplace_back(constraint_index,                                          -0.5 * delta_s_ * scale_factor_[1]);    lower_bounds-&gt;at(constraint_index) = 0.0;    upper_bounds-&gt;at(constraint_index) = 0.0;    ++constraint_index;  &#125;  // x(i+1) - x(i) - delta_s * x(i)&#x27;  // - 1/3 * delta_s^2 * x(i)&#x27;&#x27; - 1/6 * delta_s^2 * x(i+1)&#x27;&#x27;  // 设定矩阵A关于距离的连续性，即距离等式约束，A1 A3 A4，注意交叉乘对应的缩放比例  // n-1行  auto delta_s_sq_ = delta_s_ * delta_s_;  for (int i = 0; i + 1 &lt; n; ++i) &#123;    variables[i].emplace_back(constraint_index,                              -1.0 * scale_factor_[1] * scale_factor_[2]);    variables[i + 1].emplace_back(constraint_index,                                  1.0 * scale_factor_[1] * scale_factor_[2]);    variables[n + i].emplace_back(        constraint_index, -delta_s_ * scale_factor_[0] * scale_factor_[2]);    variables[2 * n + i].emplace_back(        constraint_index,        -delta_s_sq_ / 3.0 * scale_factor_[0] * scale_factor_[1]);    variables[2 * n + i + 1].emplace_back(        constraint_index,        -delta_s_sq_ / 6.0 * scale_factor_[0] * scale_factor_[1]);    lower_bounds-&gt;at(constraint_index) = 0.0;    upper_bounds-&gt;at(constraint_index) = 0.0;    ++constraint_index;  &#125;  // constrain on x_init  // 矩阵A5  // 第1列  variables[0].emplace_back(constraint_index, 1.0);  lower_bounds-&gt;at(constraint_index) = x_init_[0] * scale_factor_[0];  upper_bounds-&gt;at(constraint_index) = x_init_[0] * scale_factor_[0];  ++constraint_index;  // 第n+1列  variables[n].emplace_back(constraint_index, 1.0);  lower_bounds-&gt;at(constraint_index) = x_init_[1] * scale_factor_[1];  upper_bounds-&gt;at(constraint_index) = x_init_[1] * scale_factor_[1];  ++constraint_index;  // 第2n+1列  variables[2 * n].emplace_back(constraint_index, 1.0);  lower_bounds-&gt;at(constraint_index) = x_init_[2] * scale_factor_[2];  upper_bounds-&gt;at(constraint_index) = x_init_[2] * scale_factor_[2];  ++constraint_index;  CHECK_EQ(constraint_index, num_of_constraints);  // 提取数据及其下标  int ind_p = 0;  // 总共有 num_of_variables=3n 列  for (int i = 0; i &lt; num_of_variables; ++i) &#123;    // A_indptr储存每一列开始第一个数据的下标位置    A_indptr-&gt;push_back(ind_p);    for (const auto&amp; variable_nz : variables[i]) &#123;      // coefficient      // 存放数据，即系数      A_data-&gt;push_back(variable_nz.second);      // constraint index      // 存放数据所在列的第几行，即第几个限制条件      A_indices-&gt;push_back(variable_nz.first);      ++ind_p;    &#125;  &#125;  // We indeed need this line because of  // https://github.com/oxfordcontrol/osqp/blob/master/src/cs.c#L255  A_indptr-&gt;push_back(ind_p);&#125;\n\n 路径规划代码实现\n Class PiecewiseJerkPathProblem\n/* * @brief: * FEM stands for finite element method. * This class solve an optimization problem: * x * | * |                       P(s1, x1)  P(s2, x2) * |            P(s0, x0)                       ... P(s(k-1), x(k-1)) * |P(start) * | * |________________________________________________________ s * * we suppose s(k+1) - s(k) == s(k) - s(k-1) * * Given the x, x&#x27;, x&#x27;&#x27; at P(start),  The goal is to find x0, x1, ... x(k-1) * which makes the line P(start), P0, P(1) ... P(k-1) &quot;smooth&quot;. */class PiecewiseJerkPathProblem : public PiecewiseJerkProblem &#123;  ... protected:  // 实现两个纯虚函数  void CalculateKernel(std::vector&lt;c_float&gt;* P_data,                       std::vector&lt;c_int&gt;* P_indices,                       std::vector&lt;c_int&gt;* P_indptr) override;  void CalculateOffset(std::vector&lt;c_float&gt;* q) override;&#125;;\n PiecewiseJerkPathProblem::CalculateKernel()\nP=(P1P2P3)3n×3nP1=((wx+wx_ref)In−1×n−10n−1×101×n−1wx+wx_ref+wx_end)n×nP2=(wx′In−1×n−10n−1×101×n−1wx′+wx′_end)n×nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2+wx′′_end)n×n\\begin{aligned}\n\\textbf{P}=\\begin{pmatrix} \n\\textbf{P}_1 &amp; &amp; \\\\ \n&amp; \\textbf{P}_2 &amp; \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n} \\\\\n\n\\textbf{P}_1 = \\begin{pmatrix} \n(w_{x} + w_{x\\_ref})\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x} + w_{x\\_ref} + w_{x\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_2 = \\begin{pmatrix} \nw_{x&#x27;}\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x&#x27;} + w_{x&#x27;\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}+ w_{x&#x27;&#x27;\\_end}\\\\\n\\end{pmatrix}_{n\\times n}\n\\end{aligned}\nP=⎝⎛​P1​​P2​​P3​​⎠⎞​3n×3n​P1​=((wx​+wx_ref​)In−1×n−1​01×n−1​​0n−1×1​wx​+wx_ref​+wx_end​​)n×n​P2​=(wx′​In−1×n−1​01×n−1​​0n−1×1​wx′​+wx′_end​​)n×n​P3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​+wx′′_end​​⎠⎞​n×n​​\nvoid PiecewiseJerkPathProblem::CalculateKernel(std::vector&lt;c_float&gt;* P_data,                                               std::vector&lt;c_int&gt;* P_indices,                                               std::vector&lt;c_int&gt;* P_indptr) &#123;  const int n = static_cast&lt;int&gt;(num_of_knots_);  const int num_of_variables = 3 * n;  // 矩阵P有效数据的个数  const int num_of_nonzeros = num_of_variables + (n - 1);  // 表示矩阵P，有num_of_variables列  std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; columns(num_of_variables);  int value_index = 0;  // x(i)^2 * (w_x + w_x_ref)  // 对应P1矩阵，注意增加了位置比重  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[i].emplace_back(        i, (weight_x_ + weight_x_ref_) / (scale_factor_[0] * scale_factor_[0]));    ++value_index;  &#125;  // x(n-1)^2 * (w_x + w_x_ref + w_end_x)  columns[n - 1].emplace_back(      n - 1, (weight_x_ + weight_x_ref_ + weight_end_state_[0]) /                 (scale_factor_[0] * scale_factor_[0]));  ++value_index;  // x(i)&#x27;^2 * w_dx  // 对应P2矩阵  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[n + i].emplace_back(        n + i, weight_dx_ / (scale_factor_[1] * scale_factor_[1]));    ++value_index;  &#125;  // x(n-1)&#x27;^2 * (w_dx + w_end_dx)  columns[2 * n - 1].emplace_back(2 * n - 1,                                  (weight_dx_ + weight_end_state_[1]) /                                      (scale_factor_[1] * scale_factor_[1]));  ++value_index;  auto delta_s_square = delta_s_ * delta_s_;  // x(i)&#x27;&#x27;^2 * (w_ddx + 2 * w_dddx / delta_s^2)  // 对应P3矩阵，右边项  columns[2 * n].emplace_back(2 * n,                              (weight_ddx_ + weight_dddx_ / delta_s_square) /                                  (scale_factor_[2] * scale_factor_[2]));  ++value_index;  for (int i = 1; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(        2 * n + i, (weight_ddx_ + 2.0 * weight_dddx_ / delta_s_square) /                       (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  columns[3 * n - 1].emplace_back(      3 * n - 1,      (weight_ddx_ + weight_dddx_ / delta_s_square + weight_end_state_[2]) /          (scale_factor_[2] * scale_factor_[2]));  ++value_index;  // -2 * w_dddx / delta_s^2 * x(i)&#x27;&#x27; * x(i + 1)&#x27;&#x27;  // 对应P3矩阵，左边项  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(2 * n + i + 1,                                    (-2.0 * weight_dddx_ / delta_s_square) /                                        (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  CHECK_EQ(value_index, num_of_nonzeros);  int ind_p = 0;  for (int i = 0; i &lt; num_of_variables; ++i) &#123;    P_indptr-&gt;push_back(ind_p);    for (const auto&amp; row_data_pair : columns[i]) &#123;      P_data-&gt;push_back(row_data_pair.second * 2.0);      P_indices-&gt;push_back(row_data_pair.first);      ++ind_p;    &#125;  &#125;  P_indptr-&gt;push_back(ind_p);&#125;\n PiecewiseJerkPathProblem::CalculateOffset()\nq=(q1q2q3)3n×1q1=(−2wx_refxref⋮−2wx_refxref−2wx_endxend−2wx_refxref)n×1，q2=(0⋮0)n×1，q3=(0⋮0−2wx′′_endxend′′)n×1\\begin{aligned}\n\\textbf{q} = \\begin{pmatrix} \n\\textbf{q}_1 \\\\ \n\\textbf{q}_2 \\\\ \n\\textbf{q}_3 \\\\ \n\\end{pmatrix}_{3n \\times 1} \\\\\n\n\\textbf{q}_1 = \\begin{pmatrix}\n-2w_{x\\_ref}x_{ref} \\\\\n\\vdots \\\\\n-2w_{x\\_ref}x_{ref} \\\\\n-2w_{x\\_end}x_{end} - 2w_{x\\_ref}x_{ref}\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_2 = \\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_3 = \\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;\\_end}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{aligned}\nq=⎝⎛​q1​q2​q3​​⎠⎞​3n×1​q1​=⎝⎜⎜⎜⎜⎛​−2wx_ref​xref​⋮−2wx_ref​xref​−2wx_end​xend​−2wx_ref​xref​​⎠⎟⎟⎟⎟⎞​n×1​，q2​=⎝⎜⎜⎛​0⋮0​⎠⎟⎟⎞​n×1​，q3​=⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′_end​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​\nvoid PiecewiseJerkPathProblem::CalculateOffset(std::vector&lt;c_float&gt;* q) &#123;  CHECK_NOTNULL(q);  const int n = static_cast&lt;int&gt;(num_of_knots_);  const int kNumParam = 3 * n;  q-&gt;resize(kNumParam, 0.0);  if (has_x_ref_) &#123;    for (int i = 0; i &lt; n; ++i) &#123;      q-&gt;at(i) += -2.0 * weight_x_ref_ * x_ref_[i] / scale_factor_[0];    &#125;  &#125;  if (has_end_state_ref_) &#123;    q-&gt;at(n - 1) +=        -2.0 * weight_end_state_[0] * end_state_ref_[0] / scale_factor_[0];    q-&gt;at(2 * n - 1) +=        -2.0 * weight_end_state_[1] * end_state_ref_[1] / scale_factor_[1];    q-&gt;at(3 * n - 1) +=        -2.0 * weight_end_state_[2] * end_state_ref_[2] / scale_factor_[2];  &#125;&#125;\n 工程使用\n 路径规划Task–PiecewiseJerkPathOptimizer\n PiecewiseJerkPathOptimizer::Process()\ncommon::Status PiecewiseJerkPathOptimizer::Process(    const SpeedData&amp; speed_data, const ReferenceLine&amp; reference_line,    const common::TrajectoryPoint&amp; init_point, const bool path_reusable,    PathData* const final_path_data) &#123;  // skip piecewise_jerk_path_optimizer if reused path  if (FLAGS_enable_skip_path_tasks &amp;&amp; path_reusable) &#123;    return Status::OK();  &#125;  ADEBUG &lt;&lt; &quot;Plan at the starting point: x = &quot; &lt;&lt; init_point.path_point().x()         &lt;&lt; &quot;, y = &quot; &lt;&lt; init_point.path_point().y()         &lt;&lt; &quot;, and angle = &quot; &lt;&lt; init_point.path_point().theta();  common::TrajectoryPoint planning_start_point = init_point;  if (FLAGS_use_front_axe_center_in_path_planning) &#123;    // 根据设定平移规划起点    planning_start_point =        InferFrontAxeCenterFromRearAxeCenter(planning_start_point);  &#125;  // 将规划起点转化到基于参考线的SL坐标系下  const auto init_frenet_state =      reference_line.ToFrenetFrame(planning_start_point);  // Choose lane_change_path_config for lane-change cases  // Otherwise, choose default_path_config for normal path planning  // 根据情景选择对应的配置文件  const auto&amp; piecewise_jerk_path_config =      reference_line_info_-&gt;IsChangeLanePath()          ? config_.piecewise_jerk_path_config().lane_change_path_config()          : config_.piecewise_jerk_path_config().default_path_config();  // 根据配置参数，设定l, l&#x27;, l&#x27;&#x27;, l&#x27;&#x27;&#x27;的比重  // 注意l&#x27;的比重和初始速度相关  std::array&lt;double, 5&gt; w = &#123;      piecewise_jerk_path_config.l_weight(),      piecewise_jerk_path_config.dl_weight() *          std::fmax(init_frenet_state.first[1] * init_frenet_state.first[1],                    5.0),      piecewise_jerk_path_config.ddl_weight(),      piecewise_jerk_path_config.dddl_weight(), 0.0&#125;;  // 提取出前面Task得到的边界条件，基于SL坐标系  const auto&amp; path_boundaries =      reference_line_info_-&gt;GetCandidatePathBoundaries();  ADEBUG &lt;&lt; &quot;There are &quot; &lt;&lt; path_boundaries.size() &lt;&lt; &quot; path boundaries.&quot;;  std::vector&lt;PathData&gt; candidate_path_data;  for (const auto&amp; path_boundary : path_boundaries) &#123;    // if the path_boundary is normal, it is possible to have less than 2 points    // skip path boundary of this kind    if (path_boundary.label().find(&quot;regular&quot;) != std::string::npos &amp;&amp;        path_boundary.boundary().size() &lt; 2) &#123;      continue;    &#125;    int max_iter = 4000;    // lower max_iter for regular/self/    if (path_boundary.label().find(&quot;self&quot;) != std::string::npos) &#123;      max_iter = 4000;    &#125;    CHECK_GT(path_boundary.boundary().size(), 1);    std::vector&lt;double&gt; opt_l;    std::vector&lt;double&gt; opt_dl;    std::vector&lt;double&gt; opt_ddl;\t// 设定终点边界条件    std::array&lt;double, 3&gt; end_state = &#123;0.0, 0.0, 0.0&#125;;    if (!FLAGS_enable_force_pull_over_open_space_parking_test) &#123;      // 如果是pull over场景，调整终点边界条件      // pull over scenario      // set end lateral to be at the desired pull over destination      const auto&amp; pull_over_status =          PlanningContext::Instance()-&gt;planning_status().pull_over();      if (pull_over_status.has_position() &amp;&amp;          pull_over_status.position().has_x() &amp;&amp;          pull_over_status.position().has_y() &amp;&amp;          path_boundary.label().find(&quot;pullover&quot;) != std::string::npos) &#123;        common::SLPoint pull_over_sl;        reference_line.XYToSL(pull_over_status.position(), &amp;pull_over_sl);        end_state[0] = pull_over_sl.l();      &#125;    &#125;    // 根据车辆最大曲率，以及车道曲率，求出l&#x27;&#x27;的边界条件    const auto&amp; veh_param =        common::VehicleConfigHelper::GetConfig().vehicle_param();    const double lat_acc_bound =        std::tan(veh_param.max_steer_angle() / veh_param.steer_ratio()) /        veh_param.wheel_base();    std::vector&lt;std::pair&lt;double, double&gt;&gt; ddl_bounds;    for (size_t i = 0; i &lt; path_boundary.boundary().size(); ++i) &#123;      double s = static_cast&lt;double&gt;(i) * path_boundary.delta_s() +                 path_boundary.start_s();      double kappa = reference_line.GetNearestReferencePoint(s).kappa();      ddl_bounds.emplace_back(-lat_acc_bound - kappa, lat_acc_bound - kappa);    &#125;    // 关键步骤，得出结果    bool res_opt =        OptimizePath(init_frenet_state.second, end_state,                     path_boundary.delta_s(), path_boundary.boundary(),                     ddl_bounds, w, &amp;opt_l, &amp;opt_dl, &amp;opt_ddl, max_iter);    if (res_opt) &#123;      // ADEBUG输出，用于数据分析      for (size_t i = 0; i &lt; path_boundary.boundary().size(); i += 4) &#123;        ADEBUG &lt;&lt; &quot;for s[&quot; &lt;&lt; static_cast&lt;double&gt;(i) * path_boundary.delta_s()               &lt;&lt; &quot;], l = &quot; &lt;&lt; opt_l[i] &lt;&lt; &quot;, dl = &quot; &lt;&lt; opt_dl[i];      &#125;      // 将计算结果转化为SL坐标系下的规划路径      auto frenet_frame_path =          ToPiecewiseJerkPath(opt_l, opt_dl, opt_ddl, path_boundary.delta_s(),                              path_boundary.start_s());      // TODO(all): double-check this;      // final_path_data might carry info from upper stream      PathData path_data = *final_path_data;      path_data.SetReferenceLine(&amp;reference_line);      path_data.SetFrenetPath(std::move(frenet_frame_path));      if (FLAGS_use_front_axe_center_in_path_planning) &#123;        // 规划点平移        auto discretized_path = DiscretizedPath(            ConvertPathPointRefFromFrontAxeToRearAxe(path_data));        path_data = *final_path_data;        path_data.SetReferenceLine(&amp;reference_line);        path_data.SetDiscretizedPath(discretized_path);      &#125;      // 计算结果输出，存放在candidate_path_data      path_data.set_path_label(path_boundary.label());      path_data.set_blocking_obstacle_id(path_boundary.blocking_obstacle_id());      candidate_path_data.push_back(std::move(path_data));    &#125;  &#125;  if (candidate_path_data.empty()) &#123;    return Status(ErrorCode::PLANNING_ERROR,                  &quot;Path Optimizer failed to generate path&quot;);  &#125;  // 输出总的计算结果  reference_line_info_-&gt;SetCandidatePathData(std::move(candidate_path_data));  return Status::OK();&#125;\n PiecewiseJerkPathOptimizer::OptimizePath()\nbool PiecewiseJerkPathOptimizer::OptimizePath(    const std::array&lt;double, 3&gt;&amp; init_state,    const std::array&lt;double, 3&gt;&amp; end_state, const double delta_s,    const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; lat_boundaries,    const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; ddl_bounds,    const std::array&lt;double, 5&gt;&amp; w, std::vector&lt;double&gt;* x,    std::vector&lt;double&gt;* dx, std::vector&lt;double&gt;* ddx, const int max_iter) &#123;  // 构造用于OSQP解决器的问题，输入规划的点数，间隔，初始条件  PiecewiseJerkPathProblem piecewise_jerk_problem(lat_boundaries.size(),                                                  delta_s, init_state);  // TODO(Hongyi): update end_state settings  // 设定终点值以及比重  piecewise_jerk_problem.set_end_state_ref(&#123;1000.0, 0.0, 0.0&#125;, end_state);  if (end_state[0] != 0) &#123;    // 根据实际情况设定l的参考值，以及对应比重    // l参考值为终点位置的横向偏差    std::vector&lt;double&gt; x_ref(lat_boundaries.size(), end_state[0]);    const auto&amp; pull_over_type = PlanningContext::Instance()                                     -&gt;planning_status()                                     .pull_over()                                     .pull_over_type();    const double weight_x_ref =        pull_over_type == PullOverStatus::EMERGENCY_PULL_OVER ? 200.0 : 10.0;    piecewise_jerk_problem.set_x_ref(weight_x_ref, x_ref);  &#125;  // 设定l, l&#x27;, l&#x27;&#x27;, l&#x27;&#x27;&#x27;的比重  piecewise_jerk_problem.set_weight_x(w[0]);  piecewise_jerk_problem.set_weight_dx(w[1]);  piecewise_jerk_problem.set_weight_ddx(w[2]);  piecewise_jerk_problem.set_weight_dddx(w[3]);  // 设定比例因子  piecewise_jerk_problem.set_scale_factor(&#123;1.0, 10.0, 100.0&#125;);  // 解决问题开始时间  auto start_time = std::chrono::system_clock::now();  // 设定l, l&#x27;, l&#x27;&#x27;, l&#x27;&#x27;&#x27;的边界条件  piecewise_jerk_problem.set_x_bounds(lat_boundaries);  piecewise_jerk_problem.set_dx_bounds(-FLAGS_lateral_derivative_bound_default,                                       FLAGS_lateral_derivative_bound_default);  piecewise_jerk_problem.set_ddx_bounds(ddl_bounds);  piecewise_jerk_problem.set_dddx_bound(FLAGS_lateral_jerk_bound);  // Estimate lat_acc and jerk boundary from vehicle_params  // 根据车辆参数，设定l&#x27;&#x27;&#x27;，即横向加加速度边界  const auto&amp; veh_param =      common::VehicleConfigHelper::GetConfig().vehicle_param();  const double axis_distance = veh_param.wheel_base();  const double max_yaw_rate =      veh_param.max_steer_angle_rate() / veh_param.steer_ratio() / 2.0;  const double jerk_bound = EstimateJerkBoundary(std::fmax(init_state[1], 1.0),                                                 axis_distance, max_yaw_rate);  piecewise_jerk_problem.set_dddx_bound(jerk_bound);  // 关键步骤，求解问题  bool success = piecewise_jerk_problem.Optimize(max_iter);  // 解决问题结束时间  auto end_time = std::chrono::system_clock::now();  std::chrono::duration&lt;double&gt; diff = end_time - start_time;  ADEBUG &lt;&lt; &quot;Path Optimizer used time: &quot; &lt;&lt; diff.count() * 1000 &lt;&lt; &quot; ms.&quot;;  if (!success) &#123;    AERROR &lt;&lt; &quot;piecewise jerk path optimizer failed&quot;;    return false;  &#125;  // 结果输出  *x = piecewise_jerk_problem.opt_x();  *dx = piecewise_jerk_problem.opt_dx();  *ddx = piecewise_jerk_problem.opt_ddx();  return true;&#125;\n OSQP配置\n使用0.5.0版本。\n-----------------------------------------------------------------           OSQP v0.5.0  -  Operator Splitting QP Solver              (c) Bartolomeo Stellato,  Goran Banjac        University of Oxford  -  Stanford University 2018-----------------------------------------------------------------\n solver settings\n\n\n\nArgument\nDescription\nAllowed values\nDefault value\n\n\n\n\nrho *\nADMM rho step\n0 &lt; rho\n0.1\n\n\nsigma\nADMM sigma step\n0 &lt; sigma\n1e-06\n\n\nmax_iter *\nMaximum number of iterations\n0 &lt; max_iter (integer)\n4000\n\n\neps_abs *\nAbsolute tolerance\n0 &lt;= eps_abs\n1e-03\n\n\neps_rel *\nRelative tolerance\n0 &lt;= eps_rel\n1e-03\n\n\neps_prim_inf *\nPrimal infeasibility tolerance\n0 &lt;= eps_prim_inf\n1e-04\n\n\neps_dual_inf *\nDual infeasibility tolerance\n0 &lt;= eps_dual_inf\n1e-04\n\n\nalpha *\nADMM overrelaxation parameter\n0 &lt; alpha &lt; 2\n1.6\n\n\nlinsys_solver\nLinear systems solver type\nSee Linear Systems Solvers\nqdldl\n\n\ndelta *\nPolishing regularization parameter\n0 &lt; delta\n1e-06\n\n\npolish *\nPerform polishing\nTrue/False\nFalse\n\n\npolish_refine_iter *\nRefinement iterations in polish\n0 &lt; polish_refine_iter (integer)\n3\n\n\nverbose *\nPrint output\nTrue/False\nTrue\n\n\nscaled_termination *\nScaled termination conditions\nTrue/False\nFalse\n\n\ncheck_termination *\nCheck termination interval\n0 (disabled) or 0 &lt; check_termination (integer)\n25\n\n\nwarm_start *\nPerform warm starting\nTrue/False\nTrue\n\n\nscaling\nNumber of scaling iterations\n0 (disabled) or 0 &lt; scaling (integer)\n10\n\n\nadaptive_rho\nAdaptive rho\nTrue/False\nTrue\n\n\nadaptive_rho_interval\nAdaptive rho interval\n0 (automatic) or 0 &lt; adaptive_rho_interval (integer)\n0\n\n\nadaptive_rho_tolerance\nTolerance for adapting rho\n1 &lt;= adaptive_rho_tolerance\n5\n\n\nadaptive_rho_fraction\nAdaptive rho interval as fraction of setup time (auto mode)\n0 &lt; adaptive_rho_fraction\n0.4\n\n\ntime_limit *\nRun time limit in seconds\n0 (disabled) or 0 &lt;= time_limit\n0\n\n\n\n linear systems solvers\n\n\n\nSolver\nString option\nC Constant\nInteger value\n\n\n\n\nQDLDL\n“qdldl”\nQDLDL_SOLVER\n0\n\n\nMKL Pardiso\n“mkl pardiso”\nMKL_PARDISO_SOLVER\n1\n\n\n\n slover errors\n\n\n\nErrors\nConstant\nValue\n\n\n\n\nData validation\nOSQP_DATA_VALIDATION_ERROR\n1\n\n\nSettings validation\nOSQP_SETTINGS_VALIDATION_ERROR\n2\n\n\nLinear system solver loading\nOSQP_LINSYS_SOLVER_LOAD_ERROR\n3\n\n\nLinear system solver initialization\nOSQP_LINSYS_SOLVER_INIT_ERROR\n4\n\n\nNon convex problem\nOSQP_NONCVX_ERROR\n5\n\n\nMemory allocation\nOSQP_MEM_ALLOC_ERROR\n6\n\n\nWorkspace not initialized\nOSQP_WORKSPACE_NOT_INIT\n7\n\n\n\n result\nThe problem can be solved by\nresults = m.solve()\nThe results object contains the primal solution x, the dual solution y, certificate of primal infeasibility prim_inf_cert, certificate of dual infeasibility dual_inf_cert and the info object containing the solver statistics defined in the following table\n\n\n\nMember\nDescription\n\n\n\n\niter\nNumber of iterations\n\n\nstatus\nSolver status\n\n\nstatus_val\nSolver status value as in Status values and errors\n\n\nstatus_polish\nPolishing status\n\n\nobj_val\nObjective value\n\n\npri_res\nPrimal residual\n\n\ndua_res\nDual residual\n\n\nsetup_time\nSetup time\n\n\nsolve_time\nSolve time\n\n\nupdate_time\nUpdate time\n\n\npolish_time\nPolish time\n\n\nrun_time\nTotal run time: setup/update + solve + polish\n\n\nrho_estimate\nOptimal rho estimate\n\n\nrho_updates\nNumber of rho updates\n\n\n\nNote that if multiple solves are executed from single setup, then after the first one run_time includes update_time + solve_time + polish_time.\n","categories":["算法","Apollo源码解读"]},{"title":"（一）分段加加速度算法（PiecewiseJerk）之 路径规划理论推演","url":"/2021/09/14/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E6%8E%A8%E6%BC%94/","content":"这篇文章系统推导了分段加加速度（Piecewise Jerk）算法在路径规划中的数学模型，通过构建包含横向位置、一阶导、二阶导与三阶导的优化目标函数及约束条件，将其转化为标准的二次规划问题（QP），便于使用 OSQP 求解器实现轨迹优化。文中详细推导了每一项对 Kernel Matrix 和 Offset Vector 的贡献，并分析了初值约束、速度约束、距离约束等关键因素，为实际路径平滑提供了坚实的理论基础。\n\n 矩阵基本运算\nx=(x1x2x3x4)4×1x = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1}\nx=⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​\n则：\nxT⋅wxI4×4⋅x=(x1x2x3x4)1×4⋅wx(1000010000100001)4×4⋅(x1x2x3x4)4×1=wxx12+wxx22+wxx32+wxx42=wx∑i=14xi2\\begin{aligned}\nx^T\\cdot w_{x}\\textbf{I}_{4\\times4} \\cdot x &amp; =\\begin{pmatrix} x_1 &amp; x_2 &amp; x_3 &amp; x_4 \\end{pmatrix}_{1\\times4} \n\\cdot w_{x}\n\\begin{pmatrix} \n1 &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; 1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\end{pmatrix}_{4\\times4}\n\\cdot\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1} \\\\\n&amp; = w_{x}x_1^2+w_{x}x_2^2+w_{x}x_3^2+w_{x}x_4^2 \\\\\n&amp; = w_{x} \\sum_{i=1}^{4}x_i^2\n\\end{aligned}\nxT⋅wx​I4×4​⋅x​=(x1​​x2​​x3​​x4​​)1×4​⋅wx​⎝⎜⎜⎜⎛​1000​0100​0010​0001​⎠⎟⎟⎟⎞​4×4​⋅⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​=wx​x12​+wx​x22​+wx​x32​+wx​x42​=wx​i=1∑4​xi2​​\n 理论推演\n优化目标函数，以路径规划(基于SL坐标系)为例：\nf=(wl+wl_ref)∑i=0n−1(li−lref_i)2+wl′∑i=0n−1li′2+wl′′∑i=0n−1li′′2+wl′′′∑i=0n−2li→i+1′′′2f = (w_l +w_{l\\_ref})\\sum_{i=0}^{n-1}(l_i-l_{ref\\_i})^2 + \n   w_{l&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;2} + \n   w_{l&#x27;&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;&#x27;2} + \n   w_{l&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}l_{i \\rightarrow i+1}^{&#x27;&#x27;&#x27;2}\nf=(wl​+wl_ref​)i=0∑n−1​(li​−lref_i​)2+wl′​i=0∑n−1​li′2​+wl′′​i=0∑n−1​li′′2​+wl′′′​i=0∑n−2​li→i+1′′′2​\nsubjectto:(l0l0′l0′′)=(linitlinit′linit′′)l(k)′′′=l′′(k+1)−l′′(k)dsl′(k+1)−l′(k)=l′′(k+1)+l′′(k)2dsl(k+1)=l(k)+l′(k)ds+l′′(k)2ds2+l′′′(k)6ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative\\begin{aligned}\nsubject \\quad to:\\quad \n\\begin{pmatrix} l_0 \\\\ l&#x27;_0 \\\\ l&#x27;&#x27;_0\\end{pmatrix} = \\begin{pmatrix} l_{init} \\\\ l&#x27;_{init} \\\\ l&#x27;&#x27;_ {init} \\end{pmatrix} \\\\\nl(k)&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1)-l&#x27;&#x27;(k)}{ds} \\\\\nl&#x27;(k+1)-l&#x27;(k)=\\frac{l&#x27;&#x27;(k+1)+l&#x27;&#x27;(k)}{2}ds \\\\\nl(k+1)=l(k)+l&#x27;(k)ds+\\frac{l&#x27;&#x27;(k)}{2}ds^2+\\frac{l&#x27;&#x27;&#x27;(k)}{6}ds^3 \\\\\nl\\_bounds\\_.first\\leq l \\leq l\\_bounds\\_.second \\\\\ndl\\_bounds\\_.first\\leq l&#x27; \\leq dl\\_bounds\\_.second \\\\\nddl\\_bounds\\_.first\\leq l&#x27;&#x27; \\leq ddl\\_bounds\\_.second \\\\\n-max\\_l\\_third\\_order\\_derivative \\leq l&#x27;&#x27;&#x27; \\leq max\\_l\\_third\\_order\\_derivative\n\\end{aligned}\nsubjectto:⎝⎛​l0​l0′​l0′′​​⎠⎞​=⎝⎛​linit​linit′​linit′′​​⎠⎞​l(k)′′′=dsl′′(k+1)−l′′(k)​l′(k+1)−l′(k)=2l′′(k+1)+l′′(k)​dsl(k+1)=l(k)+l′(k)ds+2l′′(k)​ds2+6l′′′(k)​ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative​\n为了使用OSQP解决器，需要将问题转化为以下形式，即，OSQP（Operator Splitting Quadratic Program）二次规划求解器用于求解如下非线性优化问题：\nminimize12xTPx+qTxsubjectto:l≤Ax≤u\\begin{aligned}\nminimize \\quad \\frac{1}{2}x^T\\textbf{P}x+\\textbf{q}^Tx \\\\\nsubject \\quad to: \\quad \\textbf{l}\\leq \\textbf{A}x\\leq \\textbf{u}\n\\end{aligned}\nminimize21​xTPx+qTxsubjectto:l≤Ax≤u​\n其中：xxx是优化变量，P∈S+n\\textbf{P}\\in\\textbf{S}_+^nP∈S+n​是半正定Hessian矩阵，称为Kernel matrix；q∈Rn\\textbf{q}\\in\\textbf{R}^nq∈Rn是梯度向量，称为Offset matrix；线性约束矩阵A∈Rm×n\\textbf{A}\\in\\textbf{R}^{m \\times n}A∈Rm×n，称为Affine constraint matrix。\n比重系数有：wx、wx′、wx′′、wx′′′以及wx_ref、wx′_ref和Penalityx′w_x、w_{x&#x27;}、w_{x&#x27;&#x27;}、w_{x&#x27;&#x27;&#x27;}以及w_{x\\_ref}、w_{x&#x27;\\_ref}和Penality_{x&#x27;}wx​、wx′​、wx′′​、wx′′′​以及wx_ref​、wx′_ref​和Penalityx′​ \n 路径规划目标函数转化\nf=(wl+wl_ref)∑i=0n−1(li−lref_i)2+wl′∑i=0n−1li′2+wl′′∑i=0n−1li′′2+wl′′′∑i=0n−2li→i+1′′′2(1)f = (w_l +w_{l\\_ref})\\sum_{i=0}^{n-1}(l_i-l_{ref\\_i})^2 + \n    w_{l&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;2} + \n    w_{l&#x27;&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;&#x27;2} + \n    w_{l&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}l_{i \\rightarrow i+1}^{&#x27;&#x27;&#x27;2}  \\tag 1\nf=(wl​+wl_ref​)i=0∑n−1​(li​−lref_i​)2+wl′​i=0∑n−1​li′2​+wl′′​i=0∑n−1​li′′2​+wl′′′​i=0∑n−2​li→i+1′′′2​(1)\nf=wl∑i=0n−1li2+wl′∑i=0n−1li′2+wl′′∑i=0n−1li′′2+wl′′′∑i=0n−2li→i+1′′′2+wobs∑i=0n−1(li−limin+limax2)2(2)f = w_l\\sum_{i=0}^{n-1}l_i^2 + \n    w_{l&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;2} + \n    w_{l&#x27;&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;&#x27;2} + \n    w_{l&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}l_{i \\rightarrow i+1}^{&#x27;&#x27;&#x27;2} + \n    w_{obs}\\sum_{i=0}^{n-1}(l_i - \\frac{l_i^{min} + l_i^{max}}{2})^2  \\tag 2\nf=wl​i=0∑n−1​li2​+wl′​i=0∑n−1​li′2​+wl′′​i=0∑n−1​li′′2​+wl′′′​i=0∑n−2​li→i+1′′′2​+wobs​i=0∑n−1​(li​−2limin​+limax​​)2(2)\n方程(1)与方程(2)其实是一致的，可以认为lref_i为limin+limax2l_{ref\\_i}为\\frac{l_i^{min}+l_i^{max}}{2}lref_i​为2limin​+limax​​。\n以下推导以方程(1)为例：\nsubjectto:(l0l0′l0′′)=(linitlinit′linit′′)l(k)′′′=l′′(k+1)−l′′(k)dsl′(k+1)−l′(k)=l′′(k+1)+l′′(k)2dsl(k+1)=l(k)+l′(k)ds+l′′(k)2ds2+l′′′(k)6ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative\\begin{aligned}\nsubject \\quad to:\\quad \n\\begin{pmatrix} l_0 \\\\ l&#x27;_0 \\\\ l&#x27;&#x27;_0\\end{pmatrix} = \\begin{pmatrix} l_{init} \\\\ l&#x27;_{init} \\\\ l&#x27;&#x27;_ {init} \\end{pmatrix} \\\\\nl(k)&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1)-l&#x27;&#x27;(k)}{ds} \\\\\nl&#x27;(k+1)-l&#x27;(k)=\\frac{l&#x27;&#x27;(k+1)+l&#x27;&#x27;(k)}{2}ds \\\\\nl(k+1)=l(k)+l&#x27;(k)ds+\\frac{l&#x27;&#x27;(k)}{2}ds^2+\\frac{l&#x27;&#x27;&#x27;(k)}{6}ds^3 \\\\\nl\\_bounds\\_.first\\leq l \\leq l\\_bounds\\_.second \\\\\ndl\\_bounds\\_.first\\leq l&#x27; \\leq dl\\_bounds\\_.second \\\\\nddl\\_bounds\\_.first\\leq l&#x27;&#x27; \\leq ddl\\_bounds\\_.second \\\\\n-max\\_l\\_third\\_order\\_derivative \\leq l&#x27;&#x27;&#x27; \\leq max\\_l\\_third\\_order\\_derivative\n\\end{aligned}\nsubjectto:⎝⎛​l0​l0′​l0′′​​⎠⎞​=⎝⎛​linit​linit′​linit′′​​⎠⎞​l(k)′′′=dsl′′(k+1)−l′′(k)​l′(k+1)−l′(k)=2l′′(k+1)+l′′(k)​dsl(k+1)=l(k)+l′(k)ds+2l′′(k)​ds2+6l′′′(k)​ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative​\n优化变量\nx=((x)n×1(x′)n×1(x′′)n×1)3n×1\\textbf{x} = \\begin{pmatrix} (x)_{n\\times1} \\\\ (x&#x27;)_{n\\times1} \\\\(x&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\nx=⎝⎛​(x)n×1​(x′)n×1​(x′′)n×1​​⎠⎞​3n×1​\n分别表示l,dl,ddll,dl,ddll,dl,ddl，也就是l,l′,l′′l,l&#x27;,l&#x27;&#x27;l,l′,l′′​\nl=((l)n×1(l′)n×1(l′′)n×1)3n×1\\textbf{l} =\\begin{pmatrix} (l)_{n\\times1} \\\\ (l&#x27;)_{n\\times1} \\\\(l&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\nl=⎝⎛​(l)n×1​(l′)n×1​(l′′)n×1​​⎠⎞​3n×1​\n有3n个优化变量，n-1个优化点，加上初始位置，总共有n个点。\n 优化变量-横向位置\n(l)n×1(l)_{n\\times1}(l)n×1​​\n平滑lll距离lrefl_{ref}lref​越近越好，目标函数：\nminimize(wl+wl_ref)(l−lref)2=(wl+wl_ref)(l2−2llref+lref2)minimize \\quad (w_l + w_{l\\_ref})(l - l_{ref})^2 = (w_l + w_{l\\_ref})(l^2-2ll_{ref} + l_{ref}^2)\nminimize(wl​+wl_ref​)(l−lref​)2=(wl​+wl_ref​)(l2−2llref​+lref2​)\n其中lref2l_{ref}^2lref2​为常数，可以省略，因此化简得到：\nminimize(wl+wl_ref)(l2−2llref)minimize \\quad (w_l + w_{l\\_ref})(l^2-2ll_{ref})\nminimize(wl​+wl_ref​)(l2−2llref​)\n前一项(wl+wl_ref)l2(w_l+ w_{l\\_ref})l^2(wl​+wl_ref​)l2​​​​中的系数(wl+wl_ref)(w_l + w_{l\\_ref})(wl​+wl_ref​)​​​​放入矩阵P\\textbf{P}P​​​​的第一块\nP=((wl+wl_ref)In×n)3n×3n\\textbf{P}=\\begin{pmatrix} (w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\  \\\\ \\end{pmatrix}_{3n \\times 3n}\nP=((wl​+wl_ref​)In×n​​)3n×3n​\n后一项−2(wl+wl_ref)lrefl-2(w_l+w_{l\\_ref})l_{ref}l−2(wl​+wl_ref​)lref​l中的系数−2(wl+wl_ref)lref-2(w_l+w_{l\\_ref})l_{ref}−2(wl​+wl_ref​)lref​放入矩阵q\\textbf{q}q的第一块\nq=((−2(wl+wl_ref)lref)n×1)3n×1\\textbf{q} = \\begin{pmatrix} (-2(w_l+w_{l\\_ref})l_{ref})_{n\\times 1} \\\\  \\\\ \\end{pmatrix}_{3n \\times 1}\nq=((−2(wl​+wl_ref​)lref​)n×1​​)3n×1​\n其中lref=(lmin+lmax)/2l_{ref}=(l_{min} + l_{max})/2lref​=(lmin​+lmax​)/2​​​，由边界决定；或者由决策路径决定。\n 不等约束\nlmin≤l≤lmaxl_{min}\\leq l\\leq l_{max}lmin​≤l≤lmax​​得到\nA=(In×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\  \n\\quad\n\\end{pmatrix}\nA=(In×n​​)\nl=((lmin)n×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=((lmin​)n×1​​)\nu=((lmax)n×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=((lmax​)n×1​​)\n 优化变量-横向一阶导\n(l′)n×1(l&#x27;)_{n\\times1}\n(l′)n×1​\n越小越好，目标函数：\nminimizewl′l′2minimize \\quad w_{l&#x27;}l&#x27;^2\nminimizewl′​l′2\n系数wl′w_{l&#x27;}wl′​放入矩阵P\\textbf{P}P的第二块\nP=((wl+wl_ref)In×nwl′In×n)3n×3n\\textbf{P} =\n\\begin{pmatrix} \n(w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; w_{l&#x27;}\\textbf{I}_{n\\times n} &amp;  \\\\ \n\\end{pmatrix}_{3n \\times 3n}\nP=((wl​+wl_ref​)In×n​​wl′​In×n​​​)3n×3n​\n没有一次项，则矩阵q\\textbf{q}q的第二块\nq=((−2(wl+wl_ref)lref)n×1(0)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2(w_l+w_{l\\_ref})l_{ref})_{n\\times 1} \\\\ \n(0)_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎛​(−2(wl​+wl_ref​)lref​)n×1​(0)n×1​​⎠⎞​3n×1​\n 不等约束\nlmin′≤l′≤lmax′l&#x27;_{min}\\leq l&#x27; \\leq l&#x27;_{max}lmin′​≤l′≤lmax′​​得到\nA=(In×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n\\quad\n\\end{pmatrix}\nA=⎝⎛​In×n​​In×n​​​⎠⎞​\nl=((lmin)n×1(lmin′)n×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎛​(lmin​)n×1​(lmin′​)n×1​​⎠⎞​\nu=((lmax)n×1(lmax′)n×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎛​(lmax​)n×1​(lmax′​)n×1​​⎠⎞​\n 优化变量-横向二阶导\n(l′′)n×1(l&#x27;&#x27;)_{n\\times 1}\n(l′′)n×1​\n越小越好，目标函数：\nminimizewl′′l′′2minimize \\quad w_{l&#x27;&#x27;}l&#x27;&#x27;^2\nminimizewl′′​l′′2\n前一项wl′′l′′2w_{l&#x27;&#x27;}l&#x27;&#x27;^2wl′′​l′′2​​​中的系数wl′′w_{l&#x27;&#x27;}wl′′​​​​放入矩阵P\\textbf{P}P​​​的第三块\nP=((wl+wl_ref)In×nwl′In×nwl′′In×n)3n×3n\\textbf{P}=\\begin{pmatrix} \n(w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; w_{l&#x27;}\\textbf{I}_{n\\times n} &amp;  \\\\  \n&amp; &amp; w_{l&#x27;&#x27;}\\textbf{I}_{n\\times n}\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​(wl​+wl_ref​)In×n​​wl′​In×n​​wl′′​In×n​​⎠⎞​3n×3n​\n这里矩阵q\\textbf{q}q的第三块只在最后一行，即，终点加速度有一个约束−2wx′′xend′′-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}−2wx′′​xend′′​，因此有：\nq=((−2(wl+wl_ref)lref)n×1(0)n×1(0⋮0−2wl′′lend′′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2(w_l+w_{l\\_ref})l_{ref})_{n\\times 1} \\\\ \n(0)_{n\\times 1} \\\\\n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{l&#x27;&#x27;}l&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​(−2(wl​+wl_ref​)lref​)n×1​(0)n×1​⎝⎜⎜⎜⎜⎛​0⋮0−2wl′′​lend′′​​⎠⎟⎟⎟⎟⎞​n×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​3n×1​\n由此得到Offset matrix。\n 不等约束\nlmin′′≤l′′≤lmax′′l&#x27;&#x27;_{min}\\leq l&#x27;&#x27; \\leq l&#x27;&#x27;_{max}lmin′′​≤l′′≤lmax′′​​得到\nA=(In×nIn×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n\\quad\n\\end{pmatrix}\nA=⎝⎜⎜⎜⎛​In×n​​In×n​​In×n​​⎠⎟⎟⎟⎞​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​​⎠⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​​⎠⎟⎟⎟⎞​\n 优化变量-加加速度\n(l′′′)n×1(l&#x27;&#x27;&#x27;)_{n \\times 1}\n(l′′′)n×1​\n加加速度越小越好，目标函数：\nminimizewl′′′l′′′2=wl′′′(l′′(k+1)−l′′(k)ds)2=wl′′′ds2(l′′(k+1)2−2l′′(k+1)l′′(k)+l′′(k)2)\\begin{aligned}\nminimize \\quad w_{l&#x27;&#x27;&#x27;}l&#x27;&#x27;&#x27;^2 = w_{l&#x27;&#x27;&#x27;}(\\frac{l&#x27;&#x27;(k+1) - l&#x27;&#x27;(k)}{ds})^2\\\\\n= \\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(k+1)^2 - 2l&#x27;&#x27;(k+1)l&#x27;&#x27;(k) + l&#x27;&#x27;(k)^2)\n\\end{aligned}\nminimizewl′′′​l′′′2=wl′′′​(dsl′′(k+1)−l′′(k)​)2=ds2wl′′′​​(l′′(k+1)2−2l′′(k+1)l′′(k)+l′′(k)2)​\n这样变换以后相当于目标函数降低了一阶，记矩阵P\\textbf{P}P的第三块子矩阵为P3\\textbf{P}_3P3​，则目前\nP3=wl′′In×n\\textbf{P}_3=w_{l&#x27;&#x27;}\\textbf{I}_{n\\times n}\nP3​=wl′′​In×n​\n要将上述的目标函数转换成矩阵形式并添加到矩阵P3\\textbf{P}_3P3​中去，以n=5为例进行推演。\nwl′′′ds2(l′′(2)2−2l′′(2)l′′(1)+l′′(1)2)+wl′′′ds2(l′′(3)2−2l′′(3)l′′(2)+l′′(2)2)+wl′′′ds2(l′′(4)2−2l′′(4)l′′(3)+l′′(3)2)+wl′′′ds2(l′′(5)2−2l′′(5)l′′(4)+l′′(4)2)=l′′(1)(wl′′′ds2l′′(1)−2wl′′′ds2l′′(2))+l′′(2)(2wl′′′ds2l′′(2)−2wl′′′ds2l′′(3))+l′′(3)(2wl′′′ds2l′′(3)−2wl′′′ds2l′′(4))+l′′(4)(2wl′′′ds2l′′(4)−2wl′′′ds2l′′(5))+l′′(5)wl′′′ds2l′′(5)=(wl′′′ds2l′′(1)−2wl′′′ds2l′′(2)2wl′′′ds2l′′(2)−2wl′′′ds2l′′(3)2wl′′′ds2l′′(3)−2wl′′′ds2l′′(4)2wl′′′ds2l′′(4)−2wl′′′ds2l′′(5)wl′′′ds2l′′(5))T(l′′(1)l′′(2)l′′(3)l′′(4)l′′(5))=(l′′(1)l′′(2)l′′(3)l′′(4)l′′(5))T(wl′′′ds20000−2wl′′′ds22wl′′′ds20000−2wl′′′ds22wl′′′ds20000−2wl′′′ds22wl′′′ds20000−2wl′′′ds2wl′′′ds2)(l′′(1)l′′(2)l′′(3)l′′(4)l′′(5))\\begin{aligned}\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(2)^2 - 2l&#x27;&#x27;(2)l&#x27;&#x27;(1) + l&#x27;&#x27;(1)^2) + \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(3)^2 - 2l&#x27;&#x27;(3)l&#x27;&#x27;(2) + l&#x27;&#x27;(2)^2) \\\\ +\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(4)^2 - 2l&#x27;&#x27;(4)l&#x27;&#x27;(3) + l&#x27;&#x27;(3)^2) +\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(5)^2 - 2l&#x27;&#x27;(5)l&#x27;&#x27;(4) + l&#x27;&#x27;(4)^2) \\\\\n= \nl&#x27;&#x27;(1)(\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(1) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2)) + \nl&#x27;&#x27;(2)(2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2)- 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3)) \\\\ +\nl&#x27;&#x27;(3)(2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3)- 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4)) + \nl&#x27;&#x27;(4)(2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4)- 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5)) + \nl&#x27;&#x27;(5)\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5) \\\\ \n= \\begin{pmatrix} \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(1) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2) \\\\ \n2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3) \\\\ \n2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4) \\\\\n2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5) \\\\\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \nl&#x27;&#x27;(1) \\\\ \nl&#x27;&#x27;(2) \\\\ \nl&#x27;&#x27;(3) \\\\\nl&#x27;&#x27;(4) \\\\\nl&#x27;&#x27;(5) \\\\\n\\end{pmatrix} \\\\\n= \\begin{pmatrix} \nl&#x27;&#x27;(1) \\\\ \nl&#x27;&#x27;(2) \\\\ \nl&#x27;&#x27;(3) \\\\\nl&#x27;&#x27;(4) \\\\\nl&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \n-2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; -2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; -2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; -2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; \\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}\n\\begin{pmatrix} \nl&#x27;&#x27;(1) \\\\ \nl&#x27;&#x27;(2) \\\\ \nl&#x27;&#x27;(3) \\\\\nl&#x27;&#x27;(4) \\\\\nl&#x27;&#x27;(5) \\\\\n\\end{pmatrix}\n\\end{aligned}\nds2wl′′′​​(l′′(2)2−2l′′(2)l′′(1)+l′′(1)2)+ds2wl′′′​​(l′′(3)2−2l′′(3)l′′(2)+l′′(2)2)+ds2wl′′′​​(l′′(4)2−2l′′(4)l′′(3)+l′′(3)2)+ds2wl′′′​​(l′′(5)2−2l′′(5)l′′(4)+l′′(4)2)=l′′(1)(ds2wl′′′​​l′′(1)−2ds2wl′′′​​l′′(2))+l′′(2)(2ds2wl′′′​​l′′(2)−2ds2wl′′′​​l′′(3))+l′′(3)(2ds2wl′′′​​l′′(3)−2ds2wl′′′​​l′′(4))+l′′(4)(2ds2wl′′′​​l′′(4)−2ds2wl′′′​​l′′(5))+l′′(5)ds2wl′′′​​l′′(5)=⎝⎜⎜⎜⎜⎜⎛​ds2wl′′′​​l′′(1)−2ds2wl′′′​​l′′(2)2ds2wl′′′​​l′′(2)−2ds2wl′′′​​l′′(3)2ds2wl′′′​​l′′(3)−2ds2wl′′′​​l′′(4)2ds2wl′′′​​l′′(4)−2ds2wl′′′​​l′′(5)ds2wl′′′​​l′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​l′′(1)l′′(2)l′′(3)l′′(4)l′′(5)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​l′′(1)l′′(2)l′′(3)l′′(4)l′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​ds2wl′′′​​−2ds2wl′′′​​000​02ds2wl′′′​​−2ds2wl′′′​​00​002ds2wl′′′​​−2ds2wl′′′​​0​0002ds2wl′′′​​−2ds2wl′′′​​​0000ds2wl′′′​​​⎠⎟⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎜⎛​l′′(1)l′′(2)l′′(3)l′′(4)l′′(5)​⎠⎟⎟⎟⎟⎟⎞​​\n因此，P3\\textbf{P}_3P3​中需要附加上以下矩阵\n(01×n−10(−2wl′′′ds2)In−1×n−10n−1×1)n×n+(wl′′′ds201×n−200n−2×1(2wl′′′ds2)In−2×n−20n−2×1001×n−2wl′′′ds2)n×n\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; \\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\n(01×n−1​(−2ds2wl′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​ds2wl′′′​​0n−2×1​0​01×n−2​(2ds2wl′′′​​)In−2×n−2​01×n−2​​00n−2×1​ds2wl′′′​​​⎠⎞​n×n​\n加上该矩阵后，矩阵P3\\textbf{P}_3P3​变换为\nP3=(01×n−10(−2wl′′′ds2)In−1×n−10n−1×1)n×n+(wl′′+wl′′′ds201×n−200n−2×1(wl′′+2wl′′′ds2)In−2×n−20n−2×1001×n−2wl′′+wl′′′ds2)n×n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{l&#x27;&#x27;}+\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{l&#x27;&#x27;}+2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{l&#x27;&#x27;}+\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\nP3​=(01×n−1​(−2ds2wl′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wl′′​+ds2wl′′′​​0n−2×1​0​01×n−2​(wl′′​+2ds2wl′′′​​)In−2×n−2​01×n−2​​00n−2×1​wl′′​+ds2wl′′′​​​⎠⎞​n×n​\n由此得到Kernel matrix\nP=((wl+wl_ref)In×nwl′In×nP3)3n×3n\\textbf{P}=\\begin{pmatrix} \n(w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; w_{l&#x27;}\\textbf{I}_{n\\times n} &amp;  \\\\  \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​(wl​+wl_ref​)In×n​​wl′​In×n​​P3​​⎠⎞​3n×3n​\n 不等约束\nlmin′′′≤l′′′≤lmax′′′l&#x27;&#x27;&#x27;_{min} \\leq l&#x27;&#x27;&#x27; \\leq l&#x27;&#x27;&#x27;_{max}lmin′′′​≤l′′′≤lmax′′′​​\n因为\nl′′′=l′′(k+1)−l′′(k)dsl&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1) - l&#x27;&#x27;(k)}{ds}\nl′′′=dsl′′(k+1)−l′′(k)​\n所以加加速度约束转化为加速度约束\nlmin′′′⋅ds≤−l′′(k)+l′′(k+1)≤lmax′′′⋅dsl&#x27;&#x27;&#x27;_{min}\\cdot ds \\leq -l&#x27;&#x27;(k) + l&#x27;&#x27;(k+1) \\leq l&#x27;&#x27;&#x27;_{max}\\cdot ds\nlmin′′′​⋅ds≤−l′′(k)+l′′(k+1)≤lmax′′′​⋅ds\n因此得到\nA=(In×nIn×nIn×nA1)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎛​In×n​​In×n​​In×n​A1​​⎠⎟⎟⎟⎟⎟⎞​×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\n其中\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×n\\textbf{A}_1 = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA1​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 等式约束\n最终我们将会得到这样一个Affine constraint matrix\n 速度等式约束\nl′l&#x27;l′​在前后两个点之间的变化要满足等式约束：\ndl′ds=l′′,存在ξ∈(k,k+1)，使得l′(k+1)−l′(k)=l′′(ξ)⋅ds\\frac{dl&#x27;}{ds}=l&#x27;&#x27;,存在\\xi \\in(k,k+1)，使得l&#x27;(k+1) - l&#x27;(k) = l&#x27;&#x27;(\\xi)\\cdot ds\ndsdl′​=l′′,存在ξ∈(k,k+1)，使得l′(k+1)−l′(k)=l′′(ξ)⋅ds\n假设l′′(ξ)=l′′(k+1)+l′′(k)2l&#x27;&#x27;(\\xi)=\\frac{l&#x27;&#x27;(k+1) + l&#x27;&#x27;(k)}{2}l′′(ξ)=2l′′(k+1)+l′′(k)​​​​，则\nl′(k+1)−l′(k)=l′′(k+1)+l′′(k)2⋅ds  ⟺  [−l′(k)+l′(k+1)]−ds2[l′′(k)+l′′(k+1)]=0l&#x27;(k+1) - l&#x27;(k) = \\frac{l&#x27;&#x27;(k+1) + l&#x27;&#x27;(k)}{2}\\cdot ds \\\\\n\\iff \n[ - l&#x27;(k) + l&#x27;(k+1) ] - \\frac{ds}{2}[l&#x27;&#x27;(k) + l&#x27;&#x27;(k+1)]=0\nl′(k+1)−l′(k)=2l′′(k+1)+l′′(k)​⋅ds⟺[−l′(k)+l′(k+1)]−2ds​[l′′(k)+l′′(k+1)]=0\n得到\nA=(In×nIn×nIn×nA1A1A2)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1&amp; \\textbf{A}_2 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎛​In×n​​In×n​A1​​In×n​A1​A2​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×n\\textbf{A}_2 = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA2​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 距离等式约束\nlll在前后两个点之间的变化要满足等式约束：\nl(k+1)=l(k)+l′(k)⋅ds+l′′(k)2⋅ds2+l′′′(k)6⋅ds3l′′′=l′′(k+1)−l′′(k)ds  ⟺  l(k+1)=l(k)+l′(k)⋅ds+l′′(k)3⋅ds2+l′′(k+1)6⋅ds2\\begin{aligned}\nl(k+1) = l(k) + l&#x27;(k)\\cdot ds + \\frac{l&#x27;&#x27;(k)}{2}\\cdot ds^2 + \\frac{l&#x27;&#x27;&#x27;(k)}{6}\\cdot ds^3 \\\\\nl&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1) - l&#x27;&#x27;(k)}{ds} \\\\\n\\iff \\\\\nl(k+1) = l(k) + l&#x27;(k)\\cdot ds + \\frac{l&#x27;&#x27;(k)}{3}\\cdot ds^2 + \\frac{l&#x27;&#x27;(k+1)}{6}\\cdot ds^2\n\\end{aligned}\nl(k+1)=l(k)+l′(k)⋅ds+2l′′(k)​⋅ds2+6l′′′(k)​⋅ds3l′′′=dsl′′(k+1)−l′′(k)​⟺l(k+1)=l(k)+l′(k)⋅ds+3l′′(k)​⋅ds2+6l′′(k+1)​⋅ds2​\n即\n[−l(k)+l(k+1)]−ds⋅l′(k)−ds23(l′′(k)+l′′(k+1)2)=0[-l(k) + l(k+1)] - ds\\cdot l&#x27;(k) - \\frac{ds^2}{3}(l&#x27;&#x27;(k) + \\frac{l&#x27;&#x27;(k+1)}{2})=0\n[−l(k)+l(k+1)]−ds⋅l′(k)−3ds2​(l′′(k)+2l′′(k+1)​)=0\n得到\nA=(In×nIn×nIn×nA1A1A2A1A3A4)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​​In×n​A1​A3​​In×n​A1​A2​A4​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×10n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×10n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×n\\textbf{A}_3 = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA3​=−ds⋅In−1×n​A4​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 初值等式约束\n速度规划的第一个点的初始值：l,l′,l′′l,l&#x27;,l&#x27;&#x27;l,l′,l′′​取值为linit=(l0l0′l0′′)l_{init} = \\begin{pmatrix} l_0 \\\\ l&#x27;_0 \\\\ l&#x27;&#x27;_0\\end{pmatrix}linit​=⎝⎛​l0​l0′​l0′′​​⎠⎞​​，因此\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×10n−1×10n−1×1linit)6n×1\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nl_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​linit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×10n−1×10n−1×1linit)6n×1\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nl_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​linit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\n其中\nA5=(10⋯0)1×n\\textbf{A}_5=\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\nA5​=(1​0​⋯​0​)1×n​\n由此得到Affine constraint matrix。\n 曲率约束\nκ=((l′′+(κr′l+κrl′)tanΔθ)cos2Δθ1−κr+κr)cosΔθ1−κrl\\kappa = \\frac{(\\frac{(l&#x27;&#x27;+(\\kappa_r&#x27;l+\\kappa_rl&#x27;)tan\\Delta\\theta)cos^2\\Delta\\theta}{1-\\kappa_r} + \\kappa_r)cos\\Delta\\theta}{1-\\kappa_rl}\nκ=1−κr​l(1−κr​(l′′+(κr′​l+κr​l′)tanΔθ)cos2Δθ​+κr​)cosΔθ​\n−κmax&lt;κ≈κr1−κrl&lt;κmax正常情况下：1−κrl&gt;0\\begin{aligned}\n-\\kappa_{max} &lt; \\kappa \\approx \\frac{\\kappa_r}{1-\\kappa_rl} &lt; \\kappa_{max} \\\\\n正常情况下：1-\\kappa_rl &gt; 0 \\\\\n\\end{aligned}\n−κmax​&lt;κ≈1−κr​lκr​​&lt;κmax​正常情况下：1−κr​l&gt;0​\nκr,κr′\\kappa_r, \\kappa_r&#x27;κr​,κr′​是驾驶引导线上的点曲率和曲率的变化率，Δθ\\Delta\\thetaΔθ​是车辆航向角和rrr切线方向的夹角。为了简化复杂关系，做出了两点假设：\n\n车辆几乎平行于驱动引导线，即假定车辆的航向角与相应点处的引导线的方向相同，因此Δθ=0\\Delta\\theta=0Δθ=0。\n侧向加速度l′′l&#x27;&#x27;l′′​数值上很小（一般阶数在0.01）所以可以近似为0\n\n考虑右边：κr1−κrl&lt;κmaxκr&lt;κmax⋅(1−κrl)κr&lt;κmax−κmaxκrlκmaxκrl&lt;κmax−κr当κr&lt;0时，即右转：l&gt;κmax−κrκmaxκr当κr&gt;0时，即左转：l&lt;κmax−κrκmaxκr：\\begin{aligned}\n考虑右边：\n\\frac{\\kappa_r}{1-\\kappa_rl} &lt; \\kappa_{max} \\\\\n\\kappa_r &lt; \\kappa_{max}\\cdot (1-\\kappa_rl) \\\\\n\\kappa_r &lt; \\kappa_{max} - \\kappa_{max}\\kappa_rl \\\\\n\\kappa_{max}\\kappa_rl &lt; \\kappa_{max} - \\kappa_r \\\\\n当\\kappa_r&lt;0时，即右转：l &gt; \\frac{\\kappa_{max} - \\kappa_r}{\\kappa_{max}\\kappa_r} \\\\\n当\\kappa_r&gt;0时，即左转： l &lt; \\frac{\\kappa_{max} - \\kappa_r}{\\kappa_{max}\\kappa_r}：\n\\end{aligned}\n考虑右边：1−κr​lκr​​&lt;κmax​κr​&lt;κmax​⋅(1−κr​l)κr​&lt;κmax​−κmax​κr​lκmax​κr​l&lt;κmax​−κr​当κr​&lt;0时，即右转：l&gt;κmax​κr​κmax​−κr​​当κr​&gt;0时，即左转：l&lt;κmax​κr​κmax​−κr​​：​\n考虑左边：κr1−κrl&gt;−κmaxκr&gt;−κmax⋅(1−κrl)κr&gt;−κmax+κmaxκrlκmaxκrl&lt;κmax+κr当κr&lt;0时，即右转：l&gt;κmax+κrκmaxκr当κr&gt;0时，即左转：l&lt;κmax+κrκmaxκr：\\begin{aligned}\n考虑左边：\n\\frac{\\kappa_r}{1-\\kappa_rl} &gt; -\\kappa_{max} \\\\\n\\kappa_r &gt; -\\kappa_{max}\\cdot (1-\\kappa_rl) \\\\\n\\kappa_r &gt; -\\kappa_{max} + \\kappa_{max}\\kappa_rl \\\\\n\\kappa_{max}\\kappa_rl &lt; \\kappa_{max} + \\kappa_r \\\\\n当\\kappa_r&lt;0时，即右转：l &gt; \\frac{\\kappa_{max} + \\kappa_r}{\\kappa_{max}\\kappa_r} \\\\\n当\\kappa_r&gt;0时，即左转： l &lt; \\frac{\\kappa_{max} + \\kappa_r}{\\kappa_{max}\\kappa_r}：\n\\end{aligned}\n考虑左边：1−κr​lκr​​&gt;−κmax​κr​&gt;−κmax​⋅(1−κr​l)κr​&gt;−κmax​+κmax​κr​lκmax​κr​l&lt;κmax​+κr​当κr​&lt;0时，即右转：l&gt;κmax​κr​κmax​+κr​​当κr​&gt;0时，即左转：l&lt;κmax​κr​κmax​+κr​​：​\n综上所诉：当κr&lt;0时，即右转：l&gt;κmax+κrκmaxκr当κr&gt;0时，即左转：l&lt;κmax−κrκmaxκr：\\begin{aligned}\n综上所诉：\\\\\n当\\kappa_r&lt;0时，即右转：l &gt; \\frac{\\kappa_{max} + \\kappa_r}{\\kappa_{max}\\kappa_r} \\\\\n当\\kappa_r&gt;0时，即左转： l &lt; \\frac{\\kappa_{max} - \\kappa_r}{\\kappa_{max}\\kappa_r}：\n\\end{aligned}\n综上所诉：当κr​&lt;0时，即右转：l&gt;κmax​κr​κmax​+κr​​当κr​&gt;0时，即左转：l&lt;κmax​κr​κmax​−κr​​：​\n","categories":["算法"]},{"title":"（四）分段加加速度算法（PiecewiseJerk）之 速度规划代码实现","url":"/2023/01/31/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E9%80%9F%E5%BA%A6%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"基于Apollo r5.5.0 版本代码，其实后续版本算法代码基本没有差变。\n\n 代码实现\n 速度规划代码实现\n Class PiecewiseJerkSpeedProblem\n// piecewise_jerk_speed_problem.h/* * @brief: * This class solve the path time optimization problem: * s * | * |                       P(t1, s1)  P(t2, s2) * |            P(t0, s0)                       ... P(t(k-1), s(k-1)) * |P(start) * | * |________________________________________________________ t * * we suppose t(k+1) - t(k) == t(k) - t(k-1) * * Given the s, s&#x27;, s&#x27;&#x27; at P(start),  The goal is to find t0, t1, ... t(k-1) * which makes the line P(start), P0, P(1) ... P(k-1) &quot;smooth&quot;. */class PiecewiseJerkSpeedProblem : public PiecewiseJerkProblem &#123;  ... protected:  // naming convention follows osqp solver.  // 速度规划重写了以下三个函数  void CalculateKernel(std::vector&lt;c_float&gt;* P_data,                       std::vector&lt;c_int&gt;* P_indices,                       std::vector&lt;c_int&gt;* P_indptr) override;  void CalculateOffset(std::vector&lt;c_float&gt;* q) override;  OSQPSettings* SolverDefaultSettings() override;  ...&#125;\n// piecewise_jerk_speed_problem.ccPiecewiseJerkSpeedProblem::PiecewiseJerkSpeedProblem(    const size_t num_of_knots, const double delta_s,    const std::array&lt;double, 3&gt;&amp; x_init)    : PiecewiseJerkProblem(num_of_knots, delta_s, x_init) &#123;  penalty_dx_.resize(num_of_knots_, 0.0);&#125;void PiecewiseJerkSpeedProblem::set_dx_ref(const double weight_dx_ref,                                           const double dx_ref) &#123;  weight_dx_ref_ = weight_dx_ref;  dx_ref_ = dx_ref;  has_dx_ref_ = true;&#125;void PiecewiseJerkSpeedProblem::set_penalty_dx(std::vector&lt;double&gt; penalty_dx) &#123;  CHECK_EQ(penalty_dx.size(), num_of_knots_);  penalty_dx_ = std::move(penalty_dx);&#125;\n速度规划比较特殊的地方，设定了x′x&#x27;x′的参考值xref′x&#x27;_{ref}xref′​，以及对速度的惩罚。\n PiecewiseJerkSpeedProblem::CalculateKernel()\nP=(P1P2P3)3n×3nP1=(wx_refIn−1×n−10n−1×101×n−1wx_ref+wx_end)n×nP2=((wx′_ref+Penaltyx′)In−1×n−10n−1×101×n−1wx′_ref+Penaltyx′+wx′_end)n×nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2+wx′′_end)n×n\\begin{aligned}\n\\textbf{P}=\\begin{pmatrix} \n\\textbf{P}_1 &amp; &amp; \\\\ \n&amp; \\textbf{P}_2 &amp;  \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n} \\\\\n\n\\textbf{P}_1 = \\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x\\_ref} + w_{x\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_2 = \\begin{pmatrix} \n(w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x&#x27;\\_ref}+Penalty_{x&#x27;} + w_{x&#x27;\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}+ w_{x&#x27;&#x27;\\_end}\\\\\n\\end{pmatrix}_{n\\times n}\n\\end{aligned}\nP=⎝⎛​P1​​P2​​P3​​⎠⎞​3n×3n​P1​=(wx_ref​In−1×n−1​01×n−1​​0n−1×1​wx_ref​+wx_end​​)n×n​P2​=((wx′_ref​+Penaltyx′​)In−1×n−1​01×n−1​​0n−1×1​wx′_ref​+Penaltyx′​+wx′_end​​)n×n​P3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​+wx′′_end​​⎠⎞​n×n​​\nvoid PiecewiseJerkSpeedProblem::CalculateKernel(std::vector&lt;c_float&gt;* P_data,                                                std::vector&lt;c_int&gt;* P_indices,                                                std::vector&lt;c_int&gt;* P_indptr) &#123;  // 优化的点数  const int n = static_cast&lt;int&gt;(num_of_knots_);  // 优化的变量数目  const int kNumParam = 3 * n;  // 表示矩阵P内有效数据数量个数，即需要进行4n-1次数据赋值  // 3n + n-1  const int kNumValue = 4 * n - 1;  // 对应矩阵P  std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; columns;  columns.resize(kNumParam);  int value_index = 0;  // x(i)^2 * w_x_ref  // 对应矩阵P第一块矩阵  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[i].emplace_back(        i, weight_x_ref_ / (scale_factor_[0] * scale_factor_[0]));    ++value_index;  &#125;  // x(n-1)^2 * (w_x_ref + w_end_x)  // 终点有额外的比重  columns[n - 1].emplace_back(n - 1, (weight_x_ref_ + weight_end_state_[0]) /                                         (scale_factor_[0] * scale_factor_[0]));  ++value_index;  // x(i)&#x27;^2 * (w_dx_ref + penalty_dx)  // 对应矩阵P第二块矩阵  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[n + i].emplace_back(n + i,                                (weight_dx_ref_ + penalty_dx_[i]) /                                    (scale_factor_[1] * scale_factor_[1]));    ++value_index;  &#125;  // x(n-1)&#x27;^2 * (w_dx_ref + penalty_dx + w_end_dx)  // 终点有额外的比重  columns[2 * n - 1].emplace_back(      2 * n - 1, (weight_dx_ref_ + penalty_dx_[n - 1] + weight_end_state_[1]) /                     (scale_factor_[1] * scale_factor_[1]));  ++value_index;  auto delta_s_square = delta_s_ * delta_s_;  // x(i)&#x27;&#x27;^2 * (w_ddx + 2 * w_dddx / delta_s^2)  // 对应P3矩阵，右边项矩阵的左上角一块  columns[2 * n].emplace_back(2 * n,                              (weight_ddx_ + weight_dddx_ / delta_s_square) /                                  (scale_factor_[2] * scale_factor_[2]));  ++value_index;  // 对应P3矩阵，右边项矩阵的中间一块  for (int i = 1; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(        2 * n + i, (weight_ddx_ + 2.0 * weight_dddx_ / delta_s_square) /                       (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  // 对应P3矩阵，右边项矩阵的右下角一块，终点还有额外的比重累加  columns[3 * n - 1].emplace_back(      3 * n - 1,      (weight_ddx_ + weight_dddx_ / delta_s_square + weight_end_state_[2]) /          (scale_factor_[2] * scale_factor_[2]));  ++value_index;  // -2 * w_dddx / delta_s^2 * x(i)&#x27;&#x27; * x(i + 1)&#x27;&#x27;  // 对应P3矩阵，左边项矩阵的左下角一块  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(2 * n + i + 1,                                    -2.0 * weight_dddx_ / delta_s_square /                                        (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  CHECK_EQ(value_index, kNumValue);  // 抽取数据，同之前解读  int ind_p = 0;  for (int i = 0; i &lt; kNumParam; ++i) &#123;    P_indptr-&gt;push_back(ind_p);    for (const auto&amp; row_data_pair : columns[i]) &#123;      // 注意，数据这里会乘两倍      P_data-&gt;push_back(row_data_pair.second * 2.0);      P_indices-&gt;push_back(row_data_pair.first);      ++ind_p;    &#125;  &#125;  P_indptr-&gt;push_back(ind_p);&#125;\n PiecewiseJerkSpeedProblem::CalculateOffset()\nq=(q1q2q3)3n×1q1=(−2wx_refxref⋮−2wx_refxref−2wx_endxend−2wx_refxref)n×1，q2=(−2wx′_refxref′⋮−2wx′_refxref′−2wx′_endxend′−2wx′_refxref′)n×1，q3=(0⋮0−2wx′′_endxend′′)n×1\\begin{aligned}\n\\textbf{q} = \\begin{pmatrix} \n\\textbf{q}_1 \\\\ \n\\textbf{q}_2 \\\\ \n\\textbf{q}_3 \\\\ \n\\end{pmatrix}_{3n \\times 1} \\\\\n\n\\textbf{q}_1 = \\begin{pmatrix}\n-2w_{x\\_ref}x_{ref} \\\\\n\\vdots \\\\\n-2w_{x\\_ref}x_{ref} \\\\\n-2w_{x\\_end}x_{end} - 2w_{x\\_ref}x_{ref}\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_2 = \\begin{pmatrix}\n-2w_{x&#x27;\\_ref}x&#x27;_{ref} \\\\\n\\vdots \\\\\n-2w_{x&#x27;\\_ref}x&#x27;_{ref} \\\\\n-2w_{x&#x27;\\_end}x&#x27;_{end} - 2w_{x&#x27;\\_ref}x&#x27;_{ref}\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_3 = \\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;\\_end}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{aligned}\nq=⎝⎛​q1​q2​q3​​⎠⎞​3n×1​q1​=⎝⎜⎜⎜⎜⎛​−2wx_ref​xref​⋮−2wx_ref​xref​−2wx_end​xend​−2wx_ref​xref​​⎠⎟⎟⎟⎟⎞​n×1​，q2​=⎝⎜⎜⎜⎜⎛​−2wx′_ref​xref′​⋮−2wx′_ref​xref′​−2wx′_end​xend′​−2wx′_ref​xref′​​⎠⎟⎟⎟⎟⎞​n×1​，q3​=⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′_end​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​\nvoid PiecewiseJerkSpeedProblem::CalculateOffset(std::vector&lt;c_float&gt;* q) &#123;  CHECK_NOTNULL(q);  // 优化点的数量  const int n = static_cast&lt;int&gt;(num_of_knots_);  // 优化变量的数量，也就是矩阵q的行数  const int kNumParam = 3 * n;  q-&gt;resize(kNumParam);  for (int i = 0; i &lt; n; ++i) &#123;    if (has_x_ref_) &#123;      // 有x参考值情况下      q-&gt;at(i) += -2.0 * weight_x_ref_ * x_ref_[i] / scale_factor_[0];    &#125;    if (has_dx_ref_) &#123;      // 有x&#x27;参考值情况下      q-&gt;at(n + i) += -2.0 * weight_dx_ref_ * dx_ref_ / scale_factor_[1];    &#125;  &#125;  if (has_end_state_ref_) &#123;    // 有终点状态情况下    q-&gt;at(n - 1) +=        -2.0 * weight_end_state_[0] * end_state_ref_[0] / scale_factor_[0];    q-&gt;at(2 * n - 1) +=        -2.0 * weight_end_state_[1] * end_state_ref_[1] / scale_factor_[1];    q-&gt;at(3 * n - 1) +=        -2.0 * weight_end_state_[2] * end_state_ref_[2] / scale_factor_[2];  &#125;&#125;\n CalculateAffineConstraint()\n在父类PiecewiseJerkProblem以及定义好函数。\n PiecewiseJerkSpeedProblem::SolverDefaultSettings()\n// r5.0.0OSQPSettings* PiecewiseJerkSpeedProblem::SolverDefaultSettings() &#123;  // Define Solver default settings  OSQPSettings* settings =      reinterpret_cast&lt;OSQPSettings*&gt;(c_malloc(sizeof(OSQPSettings)));  osqp_set_default_settings(settings);  settings-&gt;alpha = 1.6;  // settings-&gt;sigma = 1e-2;  settings-&gt;rho = 0.1;  settings-&gt;eps_abs = 1e-3;  settings-&gt;eps_rel = 1e-3;  settings-&gt;eps_prim_inf = 1e-4;  settings-&gt;eps_dual_inf = 1e-4;  settings-&gt;polish = true;  settings-&gt;verbose = FLAGS_enable_osqp_debug;  settings-&gt;scaled_termination = true;  return settings;&#125;\n// v8.0.0OSQPSettings* PiecewiseJerkSpeedProblem::SolverDefaultSettings() &#123;  // Define Solver default settings  OSQPSettings* settings =      reinterpret_cast&lt;OSQPSettings*&gt;(c_malloc(sizeof(OSQPSettings)));  osqp_set_default_settings(settings);  settings-&gt;eps_abs = 1e-4;  settings-&gt;eps_rel = 1e-4;  settings-&gt;eps_prim_inf = 1e-5;  settings-&gt;eps_dual_inf = 1e-5;  settings-&gt;polish = true;  settings-&gt;verbose = FLAGS_enable_osqp_debug;  settings-&gt;scaled_termination = true;  return settings;&#125;\n 工程使用\n 速度规划Task–PiecewiseJerkSpeedOptimizer\n PiecewiseJerkSpeedOptimizer::Process()\nv5.5.0版本\nStatus PiecewiseJerkSpeedOptimizer::Process(const PathData&amp; path_data,                                            const TrajectoryPoint&amp; init_point,                                            SpeedData* const speed_data) &#123;  // path_data主要用于获取曲率  // init_point初始位置  if (reference_line_info_-&gt;ReachedDestination()) &#123;    // 如果到达终点就无需进一步计算    return Status::OK();  &#125;  CHECK(speed_data != nullptr);  SpeedData reference_speed_data = *speed_data;  if (path_data.discretized_path().empty()) &#123;    // 没有规划路径就直接退出    std::string msg(&quot;Empty path data&quot;);    AERROR &lt;&lt; msg;    return Status(ErrorCode::PLANNING_ERROR, msg);  &#125;  // 获取前面Task计算得到在ST图下的曲线,初始解  StGraphData&amp; st_graph_data = *reference_line_info_-&gt;mutable_st_graph_data();  const auto&amp; veh_param =      common::VehicleConfigHelper::GetConfig().vehicle_param();  // 设定初始边界条件  std::array&lt;double, 3&gt; init_s = &#123;0.0, st_graph_data.init_point().v(),                                  st_graph_data.init_point().a()&#125;;  double delta_t = 0.1;  double total_length = st_graph_data.path_length();  double total_time = st_graph_data.total_time_by_conf();  int num_of_knots = static_cast&lt;int&gt;(total_time / delta_t) + 1;  // 构造用于OSQP解决器的问题  PiecewiseJerkSpeedProblem piecewise_jerk_problem(num_of_knots, delta_t,                                                   init_s);  // 设定s&#x27;&#x27;, s&#x27;&#x27;&#x27;比重  const auto&amp; piecewise_jerk_speed_config =      config_.piecewise_jerk_speed_config();  piecewise_jerk_problem.set_weight_ddx(      piecewise_jerk_speed_config.acc_weight());  piecewise_jerk_problem.set_weight_dddx(      piecewise_jerk_speed_config.jerk_weight());  // 设定s, s&#x27;, s&#x27;&#x27;, s&#x27;&#x27;&#x27;边界  piecewise_jerk_problem.set_x_bounds(0.0, total_length);  piecewise_jerk_problem.set_dx_bounds(      0.0, std::fmax(FLAGS_planning_upper_speed_limit,                     st_graph_data.init_point().v()));  piecewise_jerk_problem.set_ddx_bounds(veh_param.max_deceleration(),                                        veh_param.max_acceleration());  piecewise_jerk_problem.set_dddx_bound(FLAGS_longitudinal_jerk_lower_bound,                                        FLAGS_longitudinal_jerk_upper_bound);  // 设定s&#x27;，即速度的参考值以及对应的比重  piecewise_jerk_problem.set_dx_ref(piecewise_jerk_speed_config.ref_v_weight(),                                    reference_line_info_-&gt;GetCruiseSpeed());  // Update STBoundary  std::vector&lt;std::pair&lt;double, double&gt;&gt; s_bounds;  for (int i = 0; i &lt; num_of_knots; ++i) &#123;    double curr_t = i * delta_t;    double s_lower_bound = 0.0;    double s_upper_bound = total_length;    for (const STBoundary* boundary : st_graph_data.st_boundaries()) &#123;      double s_lower = 0.0;      double s_upper = 0.0;      if (!boundary-&gt;GetUnblockSRange(curr_t, &amp;s_upper, &amp;s_lower)) &#123;        continue;      &#125;      switch (boundary-&gt;boundary_type()) &#123;        case STBoundary::BoundaryType::STOP:        case STBoundary::BoundaryType::YIELD:          s_upper_bound = std::fmin(s_upper_bound, s_upper);          break;        case STBoundary::BoundaryType::FOLLOW:          // TODO(Hongyi): unify follow buffer on decision side          s_upper_bound = std::fmin(s_upper_bound, s_upper - 8.0);          break;        case STBoundary::BoundaryType::OVERTAKE:          s_lower_bound = std::fmax(s_lower_bound, s_lower);          break;        default:          break;      &#125;    &#125;    if (s_lower_bound &gt; s_upper_bound) &#123;      std::string msg(&quot;s_lower_bound larger than s_upper_bound on STGraph!&quot;);      AERROR &lt;&lt; msg;      speed_data-&gt;clear();      return Status(ErrorCode::PLANNING_ERROR, msg);    &#125;    // 根据边界类型，重新设定s的边界条件    s_bounds.emplace_back(s_lower_bound, s_upper_bound);  &#125;  // 更新s边界  piecewise_jerk_problem.set_x_bounds(std::move(s_bounds));  // Update SpeedBoundary and ref_s  std::vector&lt;double&gt; x_ref;  std::vector&lt;double&gt; penalty_dx;  std::vector&lt;std::pair&lt;double, double&gt;&gt; s_dot_bounds;  const SpeedLimit&amp; speed_limit = st_graph_data.speed_limit();  for (int i = 0; i &lt; num_of_knots; ++i) &#123;    double curr_t = i * delta_t;    // get path_s    SpeedPoint sp;    reference_speed_data.EvaluateByTime(curr_t, &amp;sp);    const double path_s = sp.s();    x_ref.emplace_back(path_s);    // get curvature    PathPoint path_point = path_data.GetPathPointWithPathS(path_s);    // 设定与曲率相关的s&#x27;即速度惩罚系数    penalty_dx.push_back(std::fabs(path_point.kappa()) *                         piecewise_jerk_speed_config.kappa_penalty_weight());    // get v_upper_bound    const double v_lower_bound = 0.0;    double v_upper_bound = FLAGS_planning_upper_speed_limit;    v_upper_bound = speed_limit.GetSpeedLimitByS(path_s);    s_dot_bounds.emplace_back(v_lower_bound, std::fmax(v_upper_bound, 0.0));  &#125;  // 设定s的参考值，以及对应的比重  piecewise_jerk_problem.set_x_ref(piecewise_jerk_speed_config.ref_s_weight(),                                   x_ref);  // 设定惩罚比重  piecewise_jerk_problem.set_penalty_dx(penalty_dx);  // 设定s&#x27;，即速度的边界条件  piecewise_jerk_problem.set_dx_bounds(std::move(s_dot_bounds));  // Solve the problem  // 关键步骤，求解问题  if (!piecewise_jerk_problem.Optimize()) &#123;    std::string msg(&quot;Piecewise jerk speed optimizer failed!&quot;);    AERROR &lt;&lt; msg;    speed_data-&gt;clear();    return Status(ErrorCode::PLANNING_ERROR, msg);  &#125;  // Extract output  const std::vector&lt;double&gt;&amp; s = piecewise_jerk_problem.opt_x();  const std::vector&lt;double&gt;&amp; ds = piecewise_jerk_problem.opt_dx();  const std::vector&lt;double&gt;&amp; dds = piecewise_jerk_problem.opt_ddx();  for (int i = 0; i &lt; num_of_knots; ++i) &#123;    // 输出数据用于诊断分析    ADEBUG &lt;&lt; &quot;For t[&quot; &lt;&lt; i * delta_t &lt;&lt; &quot;], s = &quot; &lt;&lt; s[i] &lt;&lt; &quot;, v = &quot; &lt;&lt; ds[i]           &lt;&lt; &quot;, a = &quot; &lt;&lt; dds[i];  &#125;  speed_data-&gt;clear();  // 速度规划结果第一个点  speed_data-&gt;AppendSpeedPoint(s[0], 0.0, ds[0], dds[0], 0.0);  for (int i = 1; i &lt; num_of_knots; ++i) &#123;    // Avoid the very last points when already stopped    if (ds[i] &lt;= 0.0) &#123;      break;    &#125;    speed_data-&gt;AppendSpeedPoint(s[i], delta_t * i, ds[i], dds[i],                                 (dds[i] - dds[i - 1]) / delta_t);  &#125;  // 如果时间不够长，则补充后面的速度点(速度、加速度以及加加速度为0)直到时间够长  SpeedProfileGenerator::FillEnoughSpeedPoints(speed_data);  RecordDebugInfo(*speed_data, st_graph_data.mutable_st_graph_debug());  return Status::OK();&#125;\n SpeedProfileGenerator::FillEnoughSpeedPoints(）\nvoid SpeedProfileGenerator::FillEnoughSpeedPoints(SpeedData* const speed_data) &#123;  const SpeedPoint&amp; last_point = speed_data-&gt;back();  if (last_point.t() &gt;= FLAGS_fallback_total_time) &#123;    return;  &#125;  for (double t = last_point.t() + FLAGS_fallback_time_unit;       t &lt; FLAGS_fallback_total_time; t += FLAGS_fallback_time_unit) &#123;    speed_data-&gt;AppendSpeedPoint(last_point.s(), t, 0.0, 0.0, 0.0);  &#125;&#125;\n","categories":["算法","Apollo源码解读"]},{"title":"（三）分段加加速度算法（PiecewiseJerk）之 速度规划理论推演","url":"/2023/01/31/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E9%80%9F%E5%BA%A6%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E6%8E%A8%E6%BC%94/","content":"这篇文章系统推导了分段加加速度（Piecewise Jerk）算法在速度规划中的数学模型，通过构建包含横向位置、一阶导、二阶导与三阶导的优化目标函数及约束条件，将其转化为标准的二次规划问题（QP），便于使用 OSQP 求解器实现速度优化。\n\n 理论推演\n速度规划（基于ST图）代价函数：\nf=ws_ref∑i=0n−1(si−sref_i)2+(ws′_ref+Penalitys′)∑i=0n−1(si′−sref_i′)2+ws′′∑i=0n−1si′′2+ws′′′∑i=0n−2si→i+1′′′2f = w_{s\\_ref} \\sum_{i=0}^{n-1}(s_i-s_{ref\\_i})^2 + \n   (w_{s&#x27;\\_ref}+Penality_{s&#x27;})\\sum_{i=0}^{n-1}(s&#x27;_i-s&#x27;_{ref\\_i})^2 +\n   w_{s&#x27;&#x27;} \\sum_{i=0}^{n-1}s_i&#x27;&#x27;^{2} + \n   w_{s&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}s_{i \\rightarrow i+1}&#x27;&#x27;&#x27;^{2}\nf=ws_ref​i=0∑n−1​(si​−sref_i​)2+(ws′_ref​+Penalitys′​)i=0∑n−1​(si′​−sref_i′​)2+ws′′​i=0∑n−1​si′′2​+ws′′′​i=0∑n−2​si→i+1′′′2​\nsubjectto:(s0s0′s0′′)=(sinitsinit′sinit′′)s(k)′′′=s′′(k+1)−s′′(k)dts′(k+1)−s′(k)=s′′(k+1)+s′′(k)2dts(k+1)=s(k)+s′(k)dt+s′′(k)2dt2+s′′′(k)6dt3s_bounds_.first≤s≤s_bounds_.secondds_bounds_.first≤s′≤ds_bounds_.seconddds_bounds_.first≤s′′≤dds_bounds_.second−max_s_third_order_derivative≤s′′′≤max_s_third_order_derivative\\begin{aligned}\nsubject \\quad to:\\quad \n\\begin{pmatrix} s_0 \\\\ s&#x27;_0 \\\\ s&#x27;&#x27;_0\\end{pmatrix} = \\begin{pmatrix} s_{init} \\\\ s&#x27;_{init} \\\\ s&#x27;&#x27;_ {init} \\end{pmatrix} \\\\\ns(k)&#x27;&#x27;&#x27;=\\frac{s&#x27;&#x27;(k+1)-s&#x27;&#x27;(k)}{dt} \\\\\ns&#x27;(k+1)-s&#x27;(k)=\\frac{s&#x27;&#x27;(k+1)+s&#x27;&#x27;(k)}{2}dt \\\\\ns(k+1)=s(k)+s&#x27;(k)dt+\\frac{s&#x27;&#x27;(k)}{2}dt^2+\\frac{s&#x27;&#x27;&#x27;(k)}{6}dt^3 \\\\\ns\\_bounds\\_.first\\leq s \\leq s\\_bounds\\_.second \\\\\nds\\_bounds\\_.first\\leq s&#x27; \\leq ds\\_bounds\\_.second \\\\\ndds\\_bounds\\_.first\\leq s&#x27;&#x27; \\leq dds\\_bounds\\_.second \\\\\n-max\\_s\\_third\\_order\\_derivative \\leq s&#x27;&#x27;&#x27; \\leq max\\_s\\_third\\_order\\_derivative\n\\end{aligned}\nsubjectto:⎝⎛​s0​s0′​s0′′​​⎠⎞​=⎝⎛​sinit​sinit′​sinit′′​​⎠⎞​s(k)′′′=dts′′(k+1)−s′′(k)​s′(k+1)−s′(k)=2s′′(k+1)+s′′(k)​dts(k+1)=s(k)+s′(k)dt+2s′′(k)​dt2+6s′′′(k)​dt3s_bounds_.first≤s≤s_bounds_.secondds_bounds_.first≤s′≤ds_bounds_.seconddds_bounds_.first≤s′′≤dds_bounds_.second−max_s_third_order_derivative≤s′′′≤max_s_third_order_derivative​\n\n\n位置变量sis_isi​贴近对应的启发式规划位置sref_is_{ref\\_i}sref_i​\n\n\n惩罚加速度si′′s&#x27;&#x27;_isi′′​与加加速度si→i+1′′′s&#x27;&#x27;&#x27;_{i \\rightarrow i+1}si→i+1′′′​\n\n\n 速度规划目标函数转化QP形式\n优化变量\nx=((x)n×1(x′)n×1(x′′)n×1)3n×1\\textbf{x}=\\begin{pmatrix} (x)_{n\\times1} \\\\ (x&#x27;)_{n\\times1} \\\\(x&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\nx=⎝⎛​(x)n×1​(x′)n×1​(x′′)n×1​​⎠⎞​3n×1​\n分别表示距离、速度和加速度。在ST图上对应s\ns=((s)n×1(s′)n×1(s′′)n×1)3n×1\\textbf{s}=\\begin{pmatrix} (s)_{n\\times1} \\\\ (s&#x27;)_{n\\times1} \\\\(s&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\ns=⎝⎛​(s)n×1​(s′)n×1​(s′′)n×1​​⎠⎞​3n×1​\n有3n3n3n个优化变量。\n 优化变量-距离\n(x)n×1\\begin{pmatrix} x \\end{pmatrix}_{n\\times1}\n(x​)n×1​\n\n平滑sss距离建议的srefs_{ref}sref​值近越好，目标函数：\nminimizewx_ref(x−xref)2=wx_ref(x2−2xxref+xref2)minimize \\quad w_{x\\_ref}(x-x_{ref})^2 = w_{x\\_ref}(x^2-2xx_{ref}+x_{ref}^2)\nminimizewx_ref​(x−xref​)2=wx_ref​(x2−2xxref​+xref2​)\nxref2x_{ref}^2xref2​为常量，可以省去，因此化简得：\nminimizewx_ref(x2−2xxref)minimize \\quad w_{x\\_ref}(x^2-2xx_{ref})\nminimizewx_ref​(x2−2xxref​)\n前一项wx_refx2w_{x\\_ref}x^2wx_ref​x2中的系数wx_refw_{x\\_ref}wx_ref​放入矩阵P\\textbf{P}P的第一块\nP=(wx_refIn×n)3n×3n\\textbf{P}=\\begin{pmatrix} w_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\  \\\\ \\end{pmatrix}_{3n \\times 3n}\nP=(wx_ref​In×n​​)3n×3n​\n后一项−2wxrefxrefx-2w_{x_ref}x_{ref}x−2wxr​ef​xref​x中的系数−2wx_refxref-2w_{x\\_ref}x_{ref}−2wx_ref​xref​放入矩阵q\\textbf{q}q的第一块\nq=((−2wx_refxref)n×1)3n×1\\textbf{q} = \\begin{pmatrix} (-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\  \\\\ \\end{pmatrix}_{3n \\times 1}\nq=((−2wx_ref​xref​)n×1​​)3n×1​\n其中xref=(x_bounds_.first+x_bounds_second)/2x_{ref}=(x\\_bounds\\_.first+x\\_bounds\\_second)/2xref​=(x_bounds_.first+x_bounds_second)/2，由边界决定。\n 不等约束\nx_bounds_.first≤x≤x_bounds_.secondx\\_bounds\\_.first\\leq x\\leq x\\_bounds\\_.secondx_bounds_.first≤x≤x_bounds_.second得到\nA=(In×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\  \n\\quad\n\\end{pmatrix}\nA=(In×n​​)\nl=((x_bounds_.first)n×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=((x_bounds_.first)n×1​​)\nu=((x_bounds_.second)n×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=((x_bounds_.second)n×1​​)\n 优化变量-速度\n(x′)n×1(x&#x27;)_{n\\times1}\n(x′)n×1​\n速度x′x&#x27;x′建议的xref′x&#x27;_{ref}xref′​值近越好，目标函数：\nminimizewx′_ref(x′−xref′)2=wx′_ref(x′2−2x′xref′+xref′2)minimize \\quad w_{x&#x27;\\_ref}(x&#x27;-x&#x27;_{ref})^2 = w_{x&#x27;\\_ref}(x&#x27;^2-2x&#x27;x&#x27;_{ref}+x_{ref}&#x27;^2)\nminimizewx′_ref​(x′−xref′​)2=wx′_ref​(x′2−2x′xref′​+xref′2​)\nxref′2x_{ref}&#x27;^2xref′2​为常量，可以省去，因此化简得：\nminimizewx′_ref(x′2−2x′xref′)minimize \\quad w_{x&#x27;\\_ref}(x&#x27;^2-2x&#x27;x&#x27;_{ref})\nminimizewx′_ref​(x′2−2x′xref′​)\nApollo在速度x′2x&#x27;^2x′2前面加了一个惩罚系数Penaltyx′Penalty_{x&#x27;}Penaltyx′​，这个系数取值为曲率κ\\kappaκ和曲率惩罚系数的乘积，即\nPenaltyx′=κ⋅wκ_penaltyPenalty_{x&#x27;}=\\kappa \\cdot w_{\\kappa\\_penalty}\nPenaltyx′​=κ⋅wκ_penalty​\n当车辆沿直线行驶时，曲率为0，因此这是一个针对弯道限速的惩罚系数，添加惩罚系数后目标函数：\nminimize(wx′_ref+Penaltyx′)x′2−2wx′_refxref′x′minimize \\quad(w_{x&#x27;\\_ref}+Penalty_{x&#x27;})x&#x27;^2-2w_{x&#x27;\\_ref}x&#x27;_{ref}x&#x27;\nminimize(wx′_ref​+Penaltyx′​)x′2−2wx′_ref​xref′​x′\n前一项(wx′_ref+Penaltyx′)x′2(w_{x&#x27;\\_ref}+Penalty_{x&#x27;})x&#x27;^2(wx′_ref​+Penaltyx′​)x′2中的系数wx′_ref+Penaltyx′w_{x&#x27;\\_ref}+Penalty_{x&#x27;}wx′_ref​+Penaltyx′​放入矩阵P\\textbf{P}P的第二块\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×n)3n×3n\\textbf{P}=\\begin{pmatrix} w_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ &amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \\end{pmatrix}_{3n \\times 3n}\nP=(wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​​)3n×3n​\n后一项−2wx′_refxref′x′-2w_{x&#x27;\\_ref}x&#x27;_{ref}x&#x27;−2wx′_ref​xref′​x′中的系数−2wx′_refxref′-2w_{x&#x27;\\_ref}x&#x27;_{ref}−2wx′_ref​xref′​放入矩阵q\\textbf{q}q的第二块\nq=((−2wx_refxref)n×1(−2wx′_refxref′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\ \n(-2w_{x&#x27;\\_ref}x&#x27;_{ref})_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎛​(−2wx_ref​xref​)n×1​(−2wx′_ref​xref′​)n×1​​⎠⎞​3n×1​\n其中xref′=(dx_bounds_.first+dx_bounds_second)/2x&#x27;_{ref}=(dx\\_bounds\\_.first + dx\\_bounds\\_second)/2xref′​=(dx_bounds_.first+dx_bounds_second)/2，由边界决定。\n 不等约束\ndx_bounds_.first≤x′≤dx_bounds_.seconddx\\_bounds\\_.first\\leq x&#x27; \\leq dx\\_bounds\\_.seconddx_bounds_.first≤x′≤dx_bounds_.second得到\nA=(In×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n\\quad\n\\end{pmatrix}\nA=⎝⎛​In×n​​In×n​​​⎠⎞​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​​⎠⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​​⎠⎞​\n 优化变量-加速度\n(x′′)n×1(x&#x27;&#x27;)_{n\\times 1}\n(x′′)n×1​\n加速度越小越好，目标函数：\nminimizewx′′x′′2minimize \\quad w_{x&#x27;&#x27;}x&#x27;&#x27;^2\nminimizewx′′​x′′2\n前一项wx′′x′′2w{x&#x27;&#x27;}x&#x27;&#x27;^2wx′′x′′2中的系数wx′′w{x&#x27;&#x27;}wx′′放入矩阵P\\textbf{P}P的第三块\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×nwx′′In×n)3n×3n\\textbf{P}=\\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \n&amp; &amp; w_{x&#x27;&#x27;}\\textbf{I}_{n\\times n}\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​wx′′​In×n​​⎠⎞​3n×3n​\n这里矩阵q\\textbf{q}q的第三块只在最后一行，即，终点加速度有一个约束−2wx′′xend′′-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}−2wx′′​xend′′​，因此有：\nq=((−2wx_refxref)n×1(−2wx′_refxref′)n×1(0⋮0−2wx′′xend′′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\ \n(-2w_{x&#x27;\\_ref}x&#x27;_{ref})_{n\\times 1} \\\\ \n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​(−2wx_ref​xref​)n×1​(−2wx′_ref​xref′​)n×1​⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​3n×1​\n由此得到Offset matrix。\n 不等约束\nddx_bounds_.first≤x′′≤ddx_bounds_.secondddx\\_bounds\\_.first\\leq x&#x27;&#x27; \\leq ddx\\_bounds\\_.secondddx_bounds_.first≤x′′≤ddx_bounds_.second得到\nA=(In×nIn×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n\\quad\n\\end{pmatrix}\nA=⎝⎜⎜⎜⎛​In×n​​In×n​​In×n​​⎠⎟⎟⎟⎞​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​​⎠⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​​⎠⎟⎟⎟⎞​\n 优化变量-加加速度\n(x′′′)n×1(x&#x27;&#x27;&#x27;)_{n \\times 1}\n(x′′′)n×1​\n加加速度越小越好，目标函数：\nminimizewx′′′x′′′2=wx′′′(x′′(k+1)−x′′(k)ds)2=wx′′′ds2(x′′(k+1)2−2x′′(k+1)x′′(k)+x′′(k)2)\\begin{aligned}\nminimize \\quad w_{x&#x27;&#x27;&#x27;}x&#x27;&#x27;&#x27;^2 &amp; = w_{x&#x27;&#x27;&#x27;}(\\frac{x&#x27;&#x27;(k+1)-x&#x27;&#x27;(k)}{ds})^2\\\\\n&amp; = \\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(k+1)^2 - 2x&#x27;&#x27;(k+1)x&#x27;&#x27;(k) + x&#x27;&#x27;(k)^2)\n\\end{aligned}\nminimizewx′′′​x′′′2​=wx′′′​(dsx′′(k+1)−x′′(k)​)2=ds2wx′′′​​(x′′(k+1)2−2x′′(k+1)x′′(k)+x′′(k)2)​\n这样变换以后相当于目标函数降低了一阶，记矩阵P\\textbf{P}P的第三块子矩阵为P3\\textbf{P}_3P3​，则目前\nP3=wx′′In×n\\textbf{P}_3=w_{x&#x27;&#x27;}\\textbf{I}_{n\\times n}\nP3​=wx′′​In×n​\n要将上述的目标函数转换成矩阵形式并添加到矩阵P3\\textbf{P}_3P3​中去，以n=5为例进行推演。\nwx′′′ds2(x′′(2)2−2x′′(2)x′′(1)+x′′(1)2)+wx′′′ds2(x′′(3)2−2x′′(3)x′′(2)+x′′(2)2)+wx′′′ds2(x′′(4)2−2x′′(4)x′′(3)+x′′(3)2)+wx′′′ds2(x′′(5)2−2x′′(5)x′′(4)+x′′(4)2)=x′′(1)(wx′′′ds2x′′(1)−2wx′′′ds2x′′(2))+x′′(2)(2wx′′′ds2x′′(2)−2wx′′′ds2x′′(3))+x′′(3)(2wx′′′ds2x′′(3)−2wx′′′ds2x′′(4))+x′′(4)(2wx′′′ds2x′′(4)−2wx′′′ds2x′′(5))+x′′(5)wx′′′ds2x′′(5)=(wx′′′ds2x′′(1)−2wx′′′ds2x′′(2)2wx′′′ds2x′′(2)−2wx′′′ds2x′′(3)2wx′′′ds2x′′(3)−2wx′′′ds2x′′(4)2wx′′′ds2x′′(4)−2wx′′′ds2x′′(5)wx′′′ds2x′′(5))T(x′′(1)x′′(2)x′′(3)x′′(4)x′′(5))=(x′′(1)x′′(2)x′′(3)x′′(4)x′′(5))T(wx′′′ds20000−2wx′′′ds22wx′′′ds20000−2wx′′′ds22wx′′′ds20000−2wx′′′ds22wx′′′ds20000−2wx′′′ds2wx′′′ds2)(x′′(1)x′′(2)x′′(3)x′′(4)x′′(5))\\begin{aligned}\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(2)^2-2x&#x27;&#x27;(2)x&#x27;&#x27;(1)+x&#x27;&#x27;(1)^2) + \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(3)^2-2x&#x27;&#x27;(3)x&#x27;&#x27;(2)+x&#x27;&#x27;(2)^2) \\\\ +\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(4)^2-2x&#x27;&#x27;(4)x&#x27;&#x27;(3)+x&#x27;&#x27;(3)^2) +\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(5)^2-2x&#x27;&#x27;(5)x&#x27;&#x27;(4)+x&#x27;&#x27;(4)^2) \\\\\n= x&#x27;&#x27;(1)(\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(1)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2)) + \nx&#x27;&#x27;(2)(2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3)) \\\\ +\nx&#x27;&#x27;(3)(2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4)) + \nx&#x27;&#x27;(4)(2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5)) + x&#x27;&#x27;(5)\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5) \\\\ \n= \\begin{pmatrix} \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(1)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2) \\\\ \n2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3) \\\\ \n2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4) \\\\\n2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5) \\\\\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \nx&#x27;&#x27;(1) \\\\ \nx&#x27;&#x27;(2) \\\\ \nx&#x27;&#x27;(3) \\\\\nx&#x27;&#x27;(4) \\\\\nx&#x27;&#x27;(5) \\\\\n\\end{pmatrix} \\\\\n= \\begin{pmatrix} \nx&#x27;&#x27;(1) \\\\ \nx&#x27;&#x27;(2) \\\\ \nx&#x27;&#x27;(3) \\\\\nx&#x27;&#x27;(4) \\\\\nx&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \n-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; -2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; -2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; -2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}\n\\begin{pmatrix} \nx&#x27;&#x27;(1) \\\\ \nx&#x27;&#x27;(2) \\\\ \nx&#x27;&#x27;(3) \\\\\nx&#x27;&#x27;(4) \\\\\nx&#x27;&#x27;(5) \\\\\n\\end{pmatrix}\n\\end{aligned}\nds2wx′′′​​(x′′(2)2−2x′′(2)x′′(1)+x′′(1)2)+ds2wx′′′​​(x′′(3)2−2x′′(3)x′′(2)+x′′(2)2)+ds2wx′′′​​(x′′(4)2−2x′′(4)x′′(3)+x′′(3)2)+ds2wx′′′​​(x′′(5)2−2x′′(5)x′′(4)+x′′(4)2)=x′′(1)(ds2wx′′′​​x′′(1)−2ds2wx′′′​​x′′(2))+x′′(2)(2ds2wx′′′​​x′′(2)−2ds2wx′′′​​x′′(3))+x′′(3)(2ds2wx′′′​​x′′(3)−2ds2wx′′′​​x′′(4))+x′′(4)(2ds2wx′′′​​x′′(4)−2ds2wx′′′​​x′′(5))+x′′(5)ds2wx′′′​​x′′(5)=⎝⎜⎜⎜⎜⎜⎛​ds2wx′′′​​x′′(1)−2ds2wx′′′​​x′′(2)2ds2wx′′′​​x′′(2)−2ds2wx′′′​​x′′(3)2ds2wx′′′​​x′′(3)−2ds2wx′′′​​x′′(4)2ds2wx′′′​​x′′(4)−2ds2wx′′′​​x′′(5)ds2wx′′′​​x′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​x′′(1)x′′(2)x′′(3)x′′(4)x′′(5)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​x′′(1)x′′(2)x′′(3)x′′(4)x′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​ds2wx′′′​​−2ds2wx′′′​​000​02ds2wx′′′​​−2ds2wx′′′​​00​002ds2wx′′′​​−2ds2wx′′′​​0​0002ds2wx′′′​​−2ds2wx′′′​​​0000ds2wx′′′​​​⎠⎟⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎜⎛​x′′(1)x′′(2)x′′(3)x′′(4)x′′(5)​⎠⎟⎟⎟⎟⎟⎞​​\n因此，P3\\textbf{P}_3P3​中需要附加上以下矩阵\n(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′′ds201×n−200n−2×1(2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′′ds2)n×n\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; \\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\n(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​ds2wx′′′​​0n−2×1​0​01×n−2​(2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​ds2wx′′′​​​⎠⎞​n×n​\n加上该矩阵后，矩阵P3\\textbf{P}_3P3​变换为\nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2)n×n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\nP3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​​⎠⎞​n×n​\n由此得到Kernel matrix\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×nP3)3n×3n\\textbf{P}=\\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​P3​​⎠⎞​3n×3n​\n 不等约束\n−max_x_third_order_derivative≤x′′′≤max_x_third_order_derivative-max\\_x\\_third\\_order\\_derivative \\leq x&#x27;&#x27;&#x27; \\leq max\\_x\\_third\\_order\\_derivative−max_x_third_order_derivative≤x′′′≤max_x_third_order_derivative\n因为\nx′′′=x′′(k+1)−x′′(k)dsx&#x27;&#x27;&#x27;=\\frac{x&#x27;&#x27;(k+1)-x&#x27;&#x27;(k)}{ds}\nx′′′=dsx′′(k+1)−x′′(k)​\n所以加加速度约束转化为加速度约束\n−max_x_third_order_derivative⋅ds≤−x′′(k)+x′′(k+1)≤max_x_third_order_derivative⋅ds-max\\_x\\_third\\_order\\_derivative\\cdot ds \\leq -x&#x27;&#x27;(k)+x&#x27;&#x27;(k+1) \\leq max\\_x\\_third\\_order\\_derivative\\cdot ds\n−max_x_third_order_derivative⋅ds≤−x′′(k)+x′′(k+1)≤max_x_third_order_derivative⋅ds\n因此得到\nA=(In×nIn×nIn×nA1)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎛​In×n​​In×n​​In×n​A1​​⎠⎟⎟⎟⎟⎟⎞​×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\n其中\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×n\\textbf{A}_1 = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA1​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 等式约束\n最终我们将会得到这样一个Affine constraint matrix\n 速度等式约束\nx′x&#x27;x′在前后两个点之间的变化要满足等式约束：\ndx′ds=x′′,存在ξ∈(k,k+1)，使得x′(k+1)−x′(k)=x′′(ξ)⋅ds\\frac{dx&#x27;}{ds}=x&#x27;&#x27;,存在\\xi \\in(k,k+1)，使得x&#x27;(k+1)-x&#x27;(k)=x&#x27;&#x27;(\\xi)\\cdot ds\ndsdx′​=x′′,存在ξ∈(k,k+1)，使得x′(k+1)−x′(k)=x′′(ξ)⋅ds\n假设x′′(ξ)=x′′(k+1)+x′′(k)2x&#x27;&#x27;(\\xi)=\\frac{x&#x27;&#x27;(k+1)+x&#x27;&#x27;(k)}{2}x′′(ξ)=2x′′(k+1)+x′′(k)​，则\nx′(k+1)−x′(k)=x′′(k+1)+x′′(k)2⋅ds  ⟺  (−x′(k)+x′(k+1))−ds2(x′′(k)+x′′(k+1))=0x&#x27;(k+1)-x&#x27;(k)=\\frac{x&#x27;&#x27;(k+1)+x&#x27;&#x27;(k)}{2}\\cdot ds \\\\\n\\iff \\\\\n(-x&#x27;(k)+x&#x27;(k+1))-\\frac{ds}{2}(x&#x27;&#x27;(k)+x&#x27;&#x27;(k+1))=0\nx′(k+1)−x′(k)=2x′′(k+1)+x′′(k)​⋅ds⟺(−x′(k)+x′(k+1))−2ds​(x′′(k)+x′′(k+1))=0\n得到\nA=(In×nIn×nIn×nA1A1A2)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1&amp; \\textbf{A}_2 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎛​In×n​​In×n​A1​​In×n​A1​A2​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×n\\textbf{A}_2 = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA2​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 距离等式约束\nxxx在前后两个点之间的变化要满足等式约束：\nx(k+1)=x(k)+x′(k)⋅ds+x′′(k)2⋅ds2+x′′′(k)6⋅ds3x′′′=x′′(k+1)−x′′(k)ds  ⟺  x(k+1)=x(k)+x′(k)⋅ds+x′′(k)3⋅ds2+x′′(k+1)6⋅ds2\\begin{aligned}\nx(k+1)=x(k)+x&#x27;(k)\\cdot ds+\\frac{x&#x27;&#x27;(k)}{2}\\cdot ds^2 + \\frac{x&#x27;&#x27;&#x27;(k)}{6}\\cdot ds^3 \\\\\nx&#x27;&#x27;&#x27;=\\frac{x&#x27;&#x27;(k+1)-x&#x27;&#x27;(k)}{ds} \\\\\n\\iff \\\\\nx(k+1) = x(k)+x&#x27;(k)\\cdot ds+\\frac{x&#x27;&#x27;(k)}{3}\\cdot ds^2 + \\frac{x&#x27;&#x27;(k+1)}{6}\\cdot ds^2\n\\end{aligned}\nx(k+1)=x(k)+x′(k)⋅ds+2x′′(k)​⋅ds2+6x′′′(k)​⋅ds3x′′′=dsx′′(k+1)−x′′(k)​⟺x(k+1)=x(k)+x′(k)⋅ds+3x′′(k)​⋅ds2+6x′′(k+1)​⋅ds2​\n即\n(−x(k)+x(k+1))−ds⋅x′(k)−ds23(x′′(k)+x′′(k+1)2)=0(-x(k)+x(k+1)) - ds\\cdot x&#x27;(k) - \\frac{ds^2}{3}(x&#x27;&#x27;(k) + \\frac{x&#x27;&#x27;(k+1)}{2})=0\n(−x(k)+x(k+1))−ds⋅x′(k)−3ds2​(x′′(k)+2x′′(k+1)​)=0\n得到\nA=(In×nIn×nIn×nA1A1A2A1A3A4)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​​In×n​A1​A3​​In×n​A1​A2​A4​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×n\\textbf{A}_3 = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA3​=−ds⋅In−1×n​A4​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 初值等式约束\n速度规划的第一个点的初始值：x,x′,x′′x,x&#x27;,x&#x27;&#x27;x,x′,x′′取值为xinit=(x0x0′x0′′)x_{init} = \\begin{pmatrix} x_0 \\\\ x&#x27;_0 \\\\ x&#x27;&#x27;_0\\end{pmatrix}xinit​=⎝⎛​x0​x0′​x0′′​​⎠⎞​，因此\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\n其中\nA5=(10⋯0)1×n\\textbf{A}_5=\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\nA5​=(1​0​⋯​0​)1×n​\n由此得到Affine constraint matrix。\n 最终转化结果\nminimize12xTPx+qTxsubjectto:l≤Ax≤uminimize \\quad \\frac{1}{2}x^T\\textbf{P}x+\\textbf{q}^Tx \\\\\nsubject \\quad to: \\quad \\textbf{l}\\leq \\textbf{A}x\\leq \\textbf{u}\nminimize21​xTPx+qTxsubjectto:l≤Ax≤u\n其中：\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×nP3)3n×3n\\textbf{P}=\\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​P3​​⎠⎞​3n×3n​\nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2)n×n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\nP3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​​⎠⎞​n×n​\nq=((−2wx_refxref)n×1(−2wx′_refxref′)n×1(0⋮0−2wx′′xend′′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\ \n(-2w_{x&#x27;\\_ref}x&#x27;_{ref})_{n\\times 1} \\\\ \n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​(−2wx_ref​xref​)n×1​(−2wx′_ref​xref′​)n×1​⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​3n×1​\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×n\\textbf{A}_1 = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA1​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×n\\textbf{A}_2 = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA2​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×n\\textbf{A}_3 = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA3​=−ds⋅In−1×n​A4​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\nA5=(10⋯0)1×n\\textbf{A}_5=\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\nA5​=(1​0​⋯​0​)1×n​\n","categories":["算法"]},{"title":"分段加加速度路径规划OSQP仿真参数分析","url":"/2022/04/01/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92OSQP%E4%BB%BF%E7%9C%9F%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","content":" 分段加加速度路径规划OSQP仿真参数分析\n在自动驾驶横向路径规划中，分段加加速度模型（最小 jerk）常用于生成平滑轨迹，并以 OSQP 作为优化求解器。本文通过系统性仿真实验，分析路径规划中各种参数对轨迹形状与可行性的影响，并总结出一套实用的参数调试指南。\n\n\n\n参数名\n默认值\n建议范围\n说明\n\n\n\n\nl_weight\n1.0\n[10, 33]\n越大越贴中心线，过大不自然\n\n\ndl_weight\nmax(5.0, 初始dl²)\n[0, 10000]\n越大越直，对结果影响小\n\n\nddl_weight\n1000.0\n任意\n影响极小\n\n\ndddl_weight\n50000.0\n[50000, 500000]\n控制曲线“硬直”程度\n\n\nx_ref_weight\n10.0\n[10, 30]\n越大越接近目标线，但存在跳变\n\n\nend_state_weight_l\n1000.0\n[1000, 10000]\n控制终点位置贴合度\n\n\nend_state_weight_dl/ddl\n0.0\n任意\n基本无影响\n\n\n\n跳变提示：\n\n多个权重参数（如 l_weight、x_ref_weight）在某些区间会出现“跳变点”，即微小调整导致轨迹急剧变化，建议避开。\nx_ref_weight 在 [8.8, 9.0] 存在跳变，l_weight 在 [9, 10]、[33, 34]、[43, 44] 存在跳变。\n\n\n 默认参数\n采用单一变量原则：只改变其中一个值，其余不变。\n# state (l, dl, ddl) : tuplefirst_state = (3.0, 0., 0.)last_state = (3.5, 0., 0.)# weight (l, dl, ddl) : tupleend_state_weight = (1000.0, 0.0, 0.0)weight_x_ref = 10.0# weights &#123;l_weight, dl_weight, ddl_weight, dddl_weight, 0.0&#125;weights = np.array([1.0, max(5.0, first_state[1] * first_state[1]), 1000.0, 50000.0, 0.0])# scale_factors (l_scale_factor, dl_scale_factor, ddl_scale_factor) : tuplescale_factors = (1.0, 10.0, 100.0)default_lateral_derivative_bound = 2.0default_lateral_jerk_bound = 4.0\n 边界约束条件分析\n l_bounds根据障碍物道路构造边界\n就是障碍物边界，硬约束，需要注意的是起点一定要在约束条件以内，不然会导致计算失败(primal infeasible)；终点不一定，即终点可以在边界之外。\n# end_state (l, dl, ddl) : tuple\n\n0是个需要额外注意的情况，曲线是独特的。\n dl_bounds默认值为2.0，对曲线影响不大\n理解成横向速度。\n\n默认情况下，计算得到的dl在(−0.3,0.2)(-0.3,0.2)(−0.3,0.2)之间。\n设置default_lateral_derivative_bound太小就会导致计算失败(primal infeasible)。\n如下设置为0.19，发现会与边界相交。\n\n\n只要满足规划需求，对结果影响不大。\n ddl_bounds根据车辆性能与参考线曲率设定\n理解成车辆的转弯曲率边界，以自卸车为例，最大转弯曲率为0.1左右。体现为，计算结果的曲线能转弯的能力。\n\n值越小，拐弯能力越不行，绕障时就需要大幅度的摆动。\n\n\n dddl_bound对曲线影响不大，默认值为4.0\n\n\n对曲线影响不大。只要不为零，就不会导致计算失败(primal infeasible)。\n\ndl,ddl的上下限约束必须包括零点，即下限必须小于零，上限必须大于零，否则会造成primal infeasible求解失败。\n weights参数分析\nweights &#123;l_weight, dl_weight, ddl_weight, dddl_weight, 0.0&#125;\n无x_reference情况下：\n weight_l默认值1.0，建议区间[10,33][10,33][10,33]\n\nl_weight比重越大，越贴近中心线，整体感觉就是晚点绕障，提早回中心线，曲线越柔软；值在[0, 1.0]效果差不多；\n比重为1000已经使得曲线基本贴着边界，不可取；\n\n比重为[1,9][1,9][1,9]曲线差不多，也就是[0,9.0][0,9.0][0,9.0]，影响不大。在[9,10][9,10][9,10]存在一个跳变值，同end_state_weight_l。\n\n\n可见比重在50之后，变化不大，所以调试参数可定在[10,33][10,33][10,33]。\n\n\n比重在[33,34][33,34][33,34]之间存在跳变。\n\n比重在[34,43][34,43][34,43]之间对曲线影响不大。\n\n比重在[43,44][43,44][43,44]之间存在跳变。\n weight_dl默认值为5与初始dl平方最大值，对曲线其实影响不大\n\n\ndl_weight比重越大，整体拉得越直，[0,1000][0, 1000][0,1000]差别不大；比重为100000的曲线不平滑，不可取。\n\n[10000,100000][10000,100000][10000,100000]之间的比重，曲线过于柔软，贴近别解，不建议。\n\n比重在区间[1000,10000][1000,10000][1000,10000]，对曲线其实影响不大。车辆初始dl一般也不会超过100，也就是比重一般不会超过10000。\n weight_ddl对曲线影响不大，默认值1000.0\n\nddl_weight比重对曲线影响不大。\n weight_dddl影响结果拐弯性能，默认值50000.0，建议区间[50000.0,500000.0][50 000.0,500 000.0][50000.0,500000.0]，间隔100000.0100 000.0100000.0\n\n\n\ndddl_weight比重越小，越接近中心线，曲线越扭曲 (柔软) ，晚点绕障，提前回位；比重越大，整体曲线越平缓，感觉越 硬直 ，曲线拐弯性能越差。\n\n end_state_weight参数分析\n# weight (l, dl, ddl) : tuple\n end_state_weight_l默认值是1000，建议end_state=(0.,0.,0.)end\\_state= (0., 0., 0.)end_state=(0.,0.,0.)，对曲线影响不大\n 当end_state=(0.,0.,0.)end\\_state= (0., 0., 0.)end_state=(0.,0.,0.)\n\n该比重对曲线影响不大，比重为[0.0,10.0][0.0,10.0][0.0,10.0]，结果曲线基本一致。当比重为[100,1000000][100,1000000][100,1000000]时，末尾曲线比较靠近0.0，整体上基本一致。\n 当end_state=(0.1,0.,0.)end\\_state= (0.1, 0., 0.)end_state=(0.1,0.,0.)，建议区间[1000,10000][1000,10000][1000,10000]，特殊时候区间[100000,1000000][100000,1000000][100000,1000000]\n\n\n比重为[0,1000][0,1000][0,1000]时，结果曲线与边界相交，不建议；当然如果障碍物buffer考虑很大时，可以适当妥协。\n\n比重为[10000,100000][10000,100000][10000,100000]的结果曲线差别不大，当达到1000000时，曲线过于柔软，不建议。\n\n建议区间[1000,10000][1000,10000][1000,10000]，间隔1000，比重越大避障时，越早开始绕障，越早回位。\n\n比重也可以在[1000，2000][1000，2000][1000，2000]，间隔100，之间进行微调，比重越大避障时，越早开始绕障，越早回位。\n\n某些时候，可以采用该比重区间[100000,1000000][100000,1000000][100000,1000000]，让车在避障时远离障碍物。\n 当end_state=(3.5,0.,0.)end\\_state= (3.5, 0., 0.)end_state=(3.5,0.,0.)，建议区间[2000,10000][2000,10000][2000,10000]，特殊时候区间[10000,100000][10000,100000][10000,100000]\n\n\n比重为[0,1000][0,1000][0,1000]时，结果曲线与边界相交，不建议；当然如果障碍物buffer考虑很大时，可以适当妥协。\n\n比重为[100000,1000000][100000,1000000][100000,1000000]的结果曲线差别不大，过于柔软，不建议。\n\n存在跳变。\n\n依旧存在跳变。\n\n跳变存在在[1500,1600][1500,1600][1500,1600]之间。\n\n比重在[2000,3000][2000,3000][2000,3000]，间隔100，可以微调结果曲线。\n\n某些时候，可以采用该比重区间[10000,100000][10000,100000][10000,100000]，让车在避障时远离障碍物。\n end_state_weight_dl对曲线影响不大，默认值0.00.00.0\n\n比重越大，让曲线的末尾段斜率越接近设定值，对整体曲线的影响不大。\n end_state_weight_ddl对曲线影响不大，默认值0.00.00.0\n\n对生成路径整体影响不大。\n weight_x_ref参数分析，默认值101010，建议区间[10,30][10,30][10,30]\n\n比重越大，曲线越接近目标线。超过100，基本不满足非和谐系统的运动。取值可以考虑在[0,100][0,100][0,100]。\n\n进一步分析，可以发现在区间[0,20][0,20][0,20]曲线较为敏感，对曲影响较大。\n\n\n比重为5,6,7,85,6,7,85,6,7,8曲线较为一致，比重为9,109,109,10曲线较为一致，所以下一步分析区间[8,9][8,9][8,9]\n\n不存在过渡性，即存在跳变(跳变存在在区间[8.8,9.0][8.8,9.0][8.8,9.0])，不方便调试，所以考虑区间[10,30][10,30][10,30]。\n\n比重越大，曲线越接近目标线，越早回中心线。\n","categories":["算法"]},{"title":"（五）分段加加速度算法（PiecewiseJerk）之 路径规划刚体碰撞","url":"/2024/03/18/%E5%88%9A%E4%BD%93%E7%A2%B0%E6%92%9E%E8%BA%B2%E9%81%BF%E7%BA%A6%E6%9D%9F%E5%BB%BA%E6%A8%A1/","content":" 刚体碰撞躲避约束概述\n碰撞躲避约束条件是最优控制问题中最为复杂的部分。\n路径决策算法生成的粗略路径已在道路场景中决定了绕行障碍物的方式，而路径规划将遵循路径决策的结论。\n\n基于这个原则，可将道路场景进行隧道化改造，使得路径规划任务不再关系其他拓扑绕行方式。\n\n车身不是一个质点，当谈及车辆行驶至路径l(s)l(s)l(s)上的某一位置[s,l(s)][s,l(s)][s,l(s)]时，是指车身参考点（一般选为后轮轴中心点）位于[s,l(s)][s,l(s)][s,l(s)]，而车辆姿态角θ\\thetaθ满足tanθ=dl(s)dstan\\theta = \\frac{\\mathsf{d} l(s)}{ds}tanθ=dsdl(s)​条件。在假设车身在FrenetFrenetFrenet坐标系中仍为矩形的前提下，下图绘制了车辆在隧道化改造后的场景中的位置，需要针对这种一般情形构建避障约束。\n\n精细描述不规则摆放矩形与隧道边缘的不碰撞约束条件属于非凸非线性约束，不利于最优控制命题的实时数值求解。\n进行圆盘等效：可使用无穷多个圆盘覆盖车身，这些圆盘的圆心紧密地覆盖车体纵轴，其直径均为车宽。\n\n绘制一条经过圆盘圆心且垂直于sss轴的直线，将该直线与圆盘的两个交点记为A,BA,BA,B。如果每一个圆形的两端交点A,BA,BA,B均与隧道左右边界步相碰，则整个车身一定不会发生碰撞。需要强调的是，上述结论仅在圆盘个数为无穷大时成立，并且这样会在车头车尾处增加半圆形冗余区域。\n\n严格讲是以下关系：\nη⋅tanθ+l(s)+Lb2⋅cosθ≤ub(s+η)\\eta\\cdot tan\\theta+l(s) + \\frac{L_b}{2\\cdot cos\\theta} \\leq ub(s+\\eta)\nη⋅tanθ+l(s)+2⋅cosθLb​​≤ub(s+η)\nη⋅tanθ+l(s)−Lb2⋅cosθ≥lb(s+η)\\eta\\cdot tan\\theta+l(s) - \\frac{L_b}{2\\cdot cos \\theta} \\geq lb(s+\\eta) \\\\\nη⋅tanθ+l(s)−2⋅cosθLb​​≥lb(s+η)\n但实际操作过程中将cosθ≈1cos\\theta \\approx 1cosθ≈1，即，θ\\thetaθ比较接近000。\nη⋅tanθ+l(s)+Lb2≤ub(s+η)η⋅tanθ+l(s)−Lb2≥lb(s+η)∀η∈[−Lrcosθ,(Lw+Lf)cosθ]\\begin{aligned}\n\\eta\\cdot tan\\theta+l(s) + \\frac{L_b}{2} \\leq ub(s+\\eta) \\\\\n\\eta\\cdot tan\\theta+l(s) - \\frac{L_b}{2} \\geq lb(s+\\eta) \\\\\n\\forall \\eta \\in [-L_rcos\\theta, (L_w+L_f)cos\\theta]\n\\end{aligned}\nη⋅tanθ+l(s)+2Lb​​≤ub(s+η)η⋅tanθ+l(s)−2Lb​​≥lb(s+η)∀η∈[−Lr​cosθ,(Lw​+Lf​)cosθ]​\n其中：tanθ≡dl(s)ds=dl(s)tan\\theta\\equiv \\frac{\\mathsf\n{d}l(s)}{ds} = dl(s)tanθ≡dsdl(s)​=dl(s)，ub,lbub, lbub,lb为反映隧道左右边界的分段常值函数。\n上述约束作用于整段有效里程区间∀s∈[S0,S0+smax]\\forall s \\in [S_0, S_0+s_{max}]∀s∈[S0​,S0​+smax​]，则得到了完整的避障约束。\n也就是每个点都要额外考虑多个约束。约束会膨胀。\n 数值求解离散化\n数值求解需要将其中连续的自变量sss离散化，从而构造一个NLPNLPNLP问题。\n将连续的里程区间s∈[S0,S0+smax]s\\in[S_0, S_0+s_{max}]s∈[S0​,S0​+smax​]用(Nfe+1)(N_{fe}+1)(Nfe​+1)个均匀分布的采样点{si}\\{s_i\\}{si​}表示，它们将里程区分成NfeN_{fe}Nfe​部分，因此有：\nsi+1−si=smaxNfe,i=0,⋯ ,Nfe−1s_{i+1} - s_{i} = \\frac{s_{max}}{N_{fe}}, \\quad i=0, \\cdots, N_{fe} -1\nsi+1​−si​=Nfe​smax​​,i=0,⋯,Nfe​−1\n原本需要针对∀s\\forall s∀s施加约束，经过离散化后，只需要在有限个采样点{si}\\{s_i\\}{si​}上施加约束。具体在每个采样点sis_isi​上，原本要求对∀η\\forall \\eta∀η施加两条不等式约束，显然η\\etaη也需要进行离散化，毕竟NLPNLPNLP问题中绝不可能包含无穷数目约束条件。\n 长车型类情况\n\n可以在[−Lrcosθ,(Lw+Lf)cosθ][-L_r cos\\theta, (L_w+L_f)cos\\theta][−Lr​cosθ,(Lw​+Lf​)cosθ]上均匀采样(Nsample+1)(N_{sample} + 1)(Nsample​+1)个采样点{ηk}\\{\\eta_k\\}{ηk​}来表征连续变量η\\etaη，从而构成以下的离散化：\nηk⋅tanθ+l(si)+Lb2≤ub(si+ηk)ηk⋅tanθ+l(si)−Lb2≥lb(si+ηk)ηk=−Lrcosθ+(Lw+Lf+Lr)cosθNsample⋅k,k=0,1,⋯ ,Nsamplesi=S0+smaxNfe⋅i,i=0,⋯ ,Nfe\\begin{aligned}\n\\eta_k\\cdot tan\\theta+l(s_i) + \\frac{L_b}{2} \\leq ub(s_i + \\eta_k) \\\\\n\\eta_k\\cdot tan\\theta+l(s_i) - \\frac{L_b}{2} \\geq lb(s_i + \\eta_k) \\\\\n\\eta_k = - L_rcos\\theta + \\frac{(L_w+L_f+L_r)cos\\theta}{N_{sample}}\\cdot k, \\quad k=0,1,\\cdots,N_{sample} \\\\\ns_{i} =S_0 + \\frac{s_{max}}{N_{fe}}\\cdot i, \\quad i=0, \\cdots, N_{fe}\n\\end{aligned}\nηk​⋅tanθ+l(si​)+2Lb​​≤ub(si​+ηk​)ηk​⋅tanθ+l(si​)−2Lb​​≥lb(si​+ηk​)ηk​=−Lr​cosθ+Nsample​(Lw​+Lf​+Lr​)cosθ​⋅k,k=0,1,⋯,Nsample​si​=S0​+Nfe​smax​​⋅i,i=0,⋯,Nfe​​\n将tanθ=l′(s)tan\\theta = l&#x27;(s)tanθ=l′(s)代入；同时，为使采样点ηk\\eta_kηk​取值区间范围[−Lrcosθ,(Lw+Lf)cosθ][-L_r cos\\theta, (L_w+L_f)cos\\theta][−Lr​cosθ,(Lw​+Lf​)cosθ]与变量dldldl解耦，可以利用cosθ≤1cos\\theta \\leq 1cosθ≤1条件将其放宽至固定长度的区间[−Lr,(Lw+Lf)][-L_r, (L_w+L_f)][−Lr​,(Lw​+Lf​)]。放宽采样点ηk\\eta_kηk​取值区间会导致车辆行驶行为更加保守（原本处于车身外部的一定范围也被施加了避障约束），但考虑到结构化道路上的车辆姿态角一般不会显著偏离指引线且线，因此有cosθ≈1cos\\theta \\approx 1cosθ≈1，代入得：\nηk⋅l′(si)+l(si)+Lb2≤ub(si+ηk)ηk⋅l′(si)+l(si)−Lb2≥lb(si+ηk)ηk=−Lr+(Lw+Lf+Lr)Nsample⋅k,k=0,1,⋯ ,Nsamplesi=S0+smaxNfe⋅i,i=0,⋯ ,Nfe\\begin{aligned}\n\\eta_k\\cdot l&#x27;(s_i) + l(s_i) + \\frac{L_b}{2} \\leq ub(s_i + \\eta_k) \\\\\n\\eta_k\\cdot l&#x27;(s_i) + l(s_i) - \\frac{L_b}{2} \\geq lb(s_i + \\eta_k) \\\\\n\\eta_k = - L_r + \\frac{(L_w+L_f+L_r)}{N_{sample}}\\cdot k, \\quad k=0,1,\\cdots,N_{sample} \\\\\ns_{i} =S_0 + \\frac{s_{max}}{N_{fe}}\\cdot i, \\quad i=0, \\cdots, N_{fe}\n\\end{aligned}\nηk​⋅l′(si​)+l(si​)+2Lb​​≤ub(si​+ηk​)ηk​⋅l′(si​)+l(si​)−2Lb​​≥lb(si​+ηk​)ηk​=−Lr​+Nsample​(Lw​+Lf​+Lr​)​⋅k,k=0,1,⋯,Nsample​si​=S0​+Nfe​smax​​⋅i,i=0,⋯,Nfe​​\n 牵引车-半挂车类情况\n\n当考虑半挂车时，则需要把半挂车后轴中心ltl_tlt​，及其导数lt′l_t&#x27;lt′​考虑进去，结合几何关系可得：\nηk⋅lt′(si)+l(si)+Lb2≤ub(si+ηk)ηk⋅lt′(si)+l(si)−Lb2≥lb(si+ηk)ηk=−LTB+(LTB+LTF)Nsample⋅k,k=0,1,⋯ ,Nsamplesi=S0+smaxNfe⋅i,i=0,⋯ ,Nfe\\begin{aligned}\n\\eta_k\\cdot l_t&#x27;(s_i) + l(s_i) + \\frac{L_b}{2} \\leq ub(s_i + \\eta_k) \\\\\n\\eta_k\\cdot l_t&#x27;(s_i) + l(s_i) - \\frac{L_b}{2} \\geq lb(s_i + \\eta_k) \\\\\n\\eta_k = - LTB + \\frac{(LTB +LTF)}{N_{sample}}\\cdot k, \\quad k=0,1,\\cdots,N_{sample} \\\\\ns_{i} =S_0 + \\frac{s_{max}}{N_{fe}}\\cdot i, \\quad i=0, \\cdots, N_{fe}\n\\end{aligned}\nηk​⋅lt′​(si​)+l(si​)+2Lb​​≤ub(si​+ηk​)ηk​⋅lt′​(si​)+l(si​)−2Lb​​≥lb(si​+ηk​)ηk​=−LTB+Nsample​(LTB+LTF)​⋅k,k=0,1,⋯,Nsample​si​=S0​+Nfe​smax​​⋅i,i=0,⋯,Nfe​​\n需要额外考虑的约束：\n\n牵引车与半挂车几何关系\n\nl(si)=WBt⋅lt′(si)+lt(si)l(s_i) = WB_t\\cdot l_t&#x27;(s_i) + l_t(s_i)\nl(si​)=WBt​⋅lt′​(si​)+lt​(si​)\n\n半挂车运动学约束\n\nlt(si+1)−lt(si)=lt′(si+1)+lt′(si)2⋅dsl_t(s_{i+1}) - l_t(s_i) = \\frac{l_t&#x27;(s_{i+1}) + l_t&#x27;(s_i)}{2}\\cdot ds\nlt​(si+1​)−lt​(si​)=2lt′​(si+1​)+lt′​(si​)​⋅ds\n\n防折叠约束\n\n∣lt′(si)−l′(si)∣≤π2−buffer|l_t&#x27;(s_i) - l&#x27;(s_i)| \\leq \\frac{\\pi}{2} - buffer\n∣lt′​(si​)−l′(si​)∣≤2π​−buffer\n\n边界约束\n\nlt_min′≤lt′(si)≤lt_max′l&#x27;_{t\\_min} \\leq l_t&#x27;(s_i) \\leq l&#x27;_{t\\_max}\nlt_min′​≤lt′​(si​)≤lt_max′​\nlbt(si)≤lt(si)≤ubt(si)lb_t(s_i) \\leq l_t(s_i) \\leq ub_t(s_i)\nlbt​(si​)≤lt​(si​)≤ubt​(si​)\n其中buffer,lt_min′,lt_max′buffer, l&#x27;_{t\\_min}, l&#x27;_{t\\_max}buffer,lt_min′​,lt_max′​是设定常数，lbt(si),ubt(si)lb_t(s_i), ub_t(s_i)lbt​(si​),ubt​(si​)是半挂车后中心位置隧道左右边界的分段常值函数。\n 半挂车后轴中心边界分段常值函数\nindex=ceil(WBtds)lbt(i)=max[lb(max(i−index,0)),...,lb(i)]ubt(i)=min[lb(max(i−index,0)),...,ub(i)]\\begin{aligned}\nindex = ceil(\\frac{WB_t}{ds}) \\\\\nlb_t(i) = max[lb(max(i - index,0)), ..., lb(i)] \\\\\nub_t(i) = min[lb(max(i - index,0)), ..., ub(i)] \\\\\n\\end{aligned}\nindex=ceil(dsWBt​​)lbt​(i)=max[lb(max(i−index,0)),...,lb(i)]ubt​(i)=min[lb(max(i−index,0)),...,ub(i)]​\n 思考\n如果加入前轴中心横向位移lfl_flf​以及其一阶导数lf′l_f&#x27;lf′​时，注意lf′≠l′l_f&#x27; \\neq l&#x27;lf′​=l′，仅有后轴中心（在没有纵向位移前提下 不能横向位移能力的位置点）的横向一阶导数能代表航向角。\n","categories":["算法"]},{"title":"自行车前后轮轨迹问题 之 基于运动学模型推导","url":"/2023/02/15/%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%89%8D%E5%90%8E%E8%BD%AE%E8%BD%A8%E8%BF%B9%E9%97%AE%E9%A2%98%20%E4%B9%8B%20%E5%9F%BA%E4%BA%8E%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%A8%A1%E5%9E%8B%E6%8E%A8%E5%AF%BC/","content":" 前轮驱动的车辆运动模型\n{dxdt=v⋅cos(ψ+δf)(1)dydt=v⋅sin(ψ+δf)(2)dψdt=v⋅sin(δf)L(3)\\begin{cases}\n\\frac{dx}{dt} = v\\cdot cos(\\psi+\\delta_f) \\quad (1) \\\\\n\\frac{dy}{dt} = v\\cdot sin(\\psi+\\delta_f) \\quad (2) \\\\\n\\frac{d\\psi}{dt} = \\frac{v\\cdot sin(\\delta_f)}{L} \\quad (3) \\\\\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​dtdx​=v⋅cos(ψ+δf​)(1)dtdy​=v⋅sin(ψ+δf​)(2)dtdψ​=Lv⋅sin(δf​)​(3)​\n\n其中(x,y)(x,y)(x,y)为前轴中心的坐标。\n 推导后轴中心坐标\n由(2)/(1)(2)/(1)(2)/(1)和(3)/(1)(3)/(1)(3)/(1)得：\n{dydx=tan(ψ+δf)⇒δf=arctandydx−ψdψdx=sin(δf)L⋅cos(ψ+δf)\\begin{cases}\n\\frac{dy}{dx}=tan(\\psi+\\delta_f) \\Rightarrow \\delta_f=arctan\\frac{dy}{dx} - \\psi \\\\\n\\frac{d\\psi}{dx}=\\frac{sin(\\delta_f)}{L\\cdot cos(\\psi+\\delta_f)}\n\\end{cases}\n{dxdy​=tan(ψ+δf​)⇒δf​=arctandxdy​−ψdxdψ​=L⋅cos(ψ+δf​)sin(δf​)​​\ndψdx=sin(δf)L⋅cos(ψ+δf)\\frac{d\\psi}{dx} = \\frac{sin(\\delta_f)}{L\\cdot cos(\\psi+\\delta_f)}\ndxdψ​=L⋅cos(ψ+δf​)sin(δf​)​\n=sin(arctandydx−ψ)L⋅cos(arctandydx)= \\frac{sin(arctan\\frac{dy}{dx} - \\psi)}{L\\cdot cos(arctan\\frac{dy}{dx} )} \n=L⋅cos(arctandxdy​)sin(arctandxdy​−ψ)​\n=sin(arctandydx)⋅cos(ψ)−cos(arctandydx)⋅sin(ψ)L⋅cos(arctandydx)= \\frac{\nsin(arctan\\frac{dy}{dx})\\cdot cos(\\psi) - cos(arctan\\frac{dy}{dx})\\cdot sin(\\psi)\n}{L\\cdot cos(arctan\\frac{dy}{dx} )} \n=L⋅cos(arctandxdy​)sin(arctandxdy​)⋅cos(ψ)−cos(arctandxdy​)⋅sin(ψ)​\n=tan(arctandydx)⋅cos(ψ)−sin(ψ))L= \\frac{\ntan(arctan\\frac{dy}{dx})\\cdot cos(\\psi) - sin(\\psi))}{L} \n=Ltan(arctandxdy​)⋅cos(ψ)−sin(ψ))​\n=dydx⋅cos(ψ)−sin(ψ)L= \\frac{\n\\frac{dy}{dx}\\cdot cos(\\psi) - sin(\\psi)}{L} \n=Ldxdy​⋅cos(ψ)−sin(ψ)​\n得到最终微分方程：\ndψdx=dydxcosψ−sinψL\\frac{d\\psi}{dx}=\\frac{\\frac{dy}{dx}cos\\psi-sin\\psi}{L}\ndxdψ​=Ldxdy​cosψ−sinψ​\n\n其中：(x,y)是前轴中心的坐标\n\n注意：dydx=tan(θfront)\\frac{dy}{dx} = tan(\\theta_{front})dxdy​=tan(θfront​)，当θfront\\theta_{front}θfront​较小时，dydx≈θfront\\frac{dy}{dx} \\approx \\theta_{front}dxdy​≈θfront​。使用时尽量避免大的θfront\\theta_{front}θfront​，就可以直接使用近似等式。因为使用tan(θfront)tan(\\theta_{front})tan(θfront​)存在一个问题，当θfront\\theta_{front}θfront​接近90度时，tan(θfront)tan(\\theta_{front})tan(θfront​)趋近无穷大。\n 分析结论\n\n不能直接把tan(θ)≈θtan(\\theta) \\approx \\thetatan(θ)≈θ，只有θ\\thetaθ较小时才可以；同理，sin(θ)≈θsin(\\theta) \\approx \\thetasin(θ)≈θ也需要注意。\n使用tan(θ)tan(\\theta)tan(θ)时，需要注意θ\\thetaθ接近90度时，会趋近无穷大，使用时要尽量避开该区间。\n为了避开上述不利区间，可以考虑在SL坐标系下进行算法处理，或者使用车身坐标系；这也是使用车身坐标系的优点之一。\n\n 特定情况下可以解析求解\n特例1：\n当dydx=0\\frac{dy}{dx}= 0dxdy​=0，即y=C1y=C_1y=C1​\ndψdx=−sinψL\\frac{d\\psi}{dx}=\\frac{-sin\\psi}{L} \ndxdψ​=L−sinψ​\n⇒1sinψdψ=−1Ldx\\Rightarrow\n\\frac{1}{sin\\psi}d\\psi = -\\frac{1}{L}dx \n⇒sinψ1​dψ=−L1​dx\n⇒ln(tanψ2)+C2=−1Lx+C3\\Rightarrow\nln(tan\\frac{\\psi}{2})+C_2 = -\\frac{1}{L}x+C_3 \n⇒ln(tan2ψ​)+C2​=−L1​x+C3​\n⇒tanψ2=e−1Lx+C4withC4=C3−C2\\Rightarrow\ntan\\frac{\\psi}{2} = e^{-\\frac{1}{L}x+C_4}  \\quad with \\quad C_4=C_3-C_2\n⇒tan2ψ​=e−L1​x+C4​withC4​=C3​−C2​\n特例2：\n当dydx=k\\frac{dy}{dx}= kdxdy​=k，即y=kx+C1y=kx+C_1y=kx+C1​\ndψdx=k⋅cosψ−sinψL\\frac{d\\psi}{dx}=\\frac{k\\cdot cos\\psi-sin\\psi}{L} \ndxdψ​=Lk⋅cosψ−sinψ​\n⇒1sinψ−k⋅cosψdψ=−1Ldx\\Rightarrow\n\\frac{1}{sin\\psi-k\\cdot cos\\psi}d\\psi = -\\frac{1}{L}dx \n⇒sinψ−k⋅cosψ1​dψ=−L1​dx\n⇒11+k2(11+k2⋅sinψ−k1+k2⋅cosψ)dψ=−1Ldx\\Rightarrow\n\\frac{1}{\\sqrt{1+k^2}(\\frac{1}{\\sqrt{1+k^2}}\\cdot sin\\psi-\\frac{k}{\\sqrt{1+k^2}}\\cdot cos\\psi)}d\\psi = -\\frac{1}{L}dx \\\\\n⇒1+k2​(1+k2​1​⋅sinψ−1+k2​k​⋅cosψ)1​dψ=−L1​dx\n令cos(t)=11+k2，sin(t)=k1+k2则：令 cos(t)= \\frac{1}{\\sqrt{1+k^2}}，sin(t)=\\frac{k}{\\sqrt{1+k^2}} 则：\n令cos(t)=1+k2​1​，sin(t)=1+k2​k​则：\n11+k2[cos(t)⋅sin(ψ)−sin(t)⋅cos(ψ)]dψ=−1Ldx\\frac{1}{\\sqrt{1+k^2}\n[cos(t)\\cdot sin(\\psi)-sin(t)\\cdot cos(\\psi)]}\nd\\psi = -\\frac{1}{L}dx \n1+k2​[cos(t)⋅sin(ψ)−sin(t)⋅cos(ψ)]1​dψ=−L1​dx\n⇒1sin(ψ−t)dψ=−1+k2Ldx令h=ψ−t，则\\Rightarrow\n\\frac{1}{sin(\\psi-t)}d\\psi = -\\frac{\\sqrt{1+k^2}}{L}dx \n令h=\\psi -t，则\n⇒sin(ψ−t)1​dψ=−L1+k2​​dx令h=ψ−t，则\n1sin(h)dh=−1+k2Ldx\\frac{1}{sin(h)}dh = -\\frac{\\sqrt{1+k^2}}{L}dx \nsin(h)1​dh=−L1+k2​​dx\n⇒ln(tanh2)+C2=−1+k2Lx+C3\\Rightarrow\nln(tan\\frac{h}{2})+C_2 = -\\frac{\\sqrt{1+k^2}}{L}x+C_3 \n⇒ln(tan2h​)+C2​=−L1+k2​​x+C3​\n⇒tan(ψ−t2)=e−1+k2Lx+C4withC4=C3−C2\\Rightarrow\ntan(\\frac{\\psi-t}{2})=e^{-\\frac{\\sqrt{1+k^2}}{L}x+C_4} \\quad with \\quad C_4= C_3- C_2\n⇒tan(2ψ−t​)=e−L1+k2​​x+C4​withC4​=C3​−C2​\n","categories":["算法"]},{"title":"自行车前后轮轨迹问题 之 曳物曲线","url":"/2023/02/15/%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%89%8D%E5%90%8E%E8%BD%AE%E8%BD%A8%E8%BF%B9%E9%97%AE%E9%A2%98%20%E4%B9%8B%20%E6%9B%B3%E7%89%A9%E6%9B%B2%E7%BA%BF/","content":"自行车前后轮轨迹问题是一个经典的几何与运动学问题，常出现在机器人路径规划、自动驾驶车辆建模、轨迹控制以及计算机图形学等领域。这个问题的背景源自人们对 非完整系统（nonholonomic system） 运动特性的研究。\n\n 一、问题背景与描述🚲\n 1.1 自行车模型简述\n一个自行车模型是典型的非完整系统，它具有如下特征：\n\n自行车由两个轮子组成：前轮可转向、后轮固定方向。\n车辆只能朝车头方向行驶或倒退，不能像全向机器人一样横向移动。\n通常我们认为两个轮子之间有一个固定轴距 LLL。\n\n 1.2 前后轮轨迹差异的由来\n当自行车行驶时：\n\n前轮通过转向控制运动方向，它的轨迹代表驾驶者期望的行驶路径。\n后轮被动跟随前轮，由于其不具备转向能力，它不能完全走在前轮轨迹上。\n\n这会导致：\n\n前轮和后轮走出的是两条不同的轨迹；\n特别是在转弯或倒车时，轨迹差异尤为明显；\n前后轮之间存在一个几何偏移，这种差异是运动学非完整性的直接表现。\n\n 二、为什么这个问题重要？\n 路径规划与跟踪控制\n\n在自动驾驶或机器人控制中，很多控制算法（如Pure Pursuit、MPC）都必须考虑前后轮轨迹误差。\n路径规划器生成的是某一参考点（通常是后轮中点或车辆中心）的轨迹，但执行时车辆的真实位置是前轮控制的结果。\n\n 倒车与拖车系统\n\n在复杂的倒车过程中（如挂拖车倒车），前后轨迹差异放大，难以控制；\n拖车系统（如牵引车-半挂车）本质上是更复杂的前后轨迹问题的延伸。\n\n 几何推导与轨迹生成\n\n在建模或者仿真中（如绘制车辙线或预测路径），理解前后轮轨迹关系有助于生成更真实的车辆运动轨迹；\n例如你骑车绕一个圆圈，前轮和后轮画出的轨迹是两条不同半径的圆弧。\n\n 三、工程问题\n\n该问题最找出自《Which Way did the Bicycle Go? … and Other Intriguing Mathematical Mysteries》一书。Which Way Did the Bicycle Go? – and other bicycle ponderings\n改问题在工程上变成：已知任意给定的前轮轨迹，如何求解相应的后轮轨迹？\n为方便起见，我们用参数方程来描述曲线上任一点的坐标(x,y)(x,y)(x,y)。\n例如已知前轮轨迹：\nx=α(t),y=β(t)x=\\alpha(t), y=\\beta(t)x=α(t),y=β(t)，\n求解后轮轨迹：\nx=x(t),y=y(t)x=x(t), y=y(t)x=x(t),y=y(t)。\n\n两个条件：\n\n\n两点之间距离为L\n(β−y)2+(α−x)2=L2(\\beta - y)^2 + (\\alpha - x)^2 = L^2(β−y)2+(α−x)2=L2\n\n\nP点运动方向与刚体运动方向一致\ndydx=dydtdxdt=y′x′=β−yα−x\\frac{dy}{dx} = \\frac{\\frac{dy}{dt}}{\\frac{dx}{dt}} = \\frac{y&#x27;}{x&#x27;} =\\frac{\\beta - y}{\\alpha - x}dxdy​=dtdx​dtdy​​=x′y′​=α−xβ−y​\n\n\n 四、工程求解\n条件一两边同时对t求导：\n2∗(β−y)∗(β′−y′)+2∗(α−x)∗(α′−x′)=02*(\\beta - y)*(\\beta&#x27; - y&#x27;) + 2*(\\alpha - x)*(\\alpha&#x27; - x&#x27;) = 0\n2∗(β−y)∗(β′−y′)+2∗(α−x)∗(α′−x′)=0\n⇒(β−y)∗(β′−y′)+(α−x)∗(α′−x′)=0\\Rightarrow (\\beta - y)*(\\beta&#x27; - y&#x27;) + (\\alpha - x)*(\\alpha&#x27; - x&#x27;) = 0\n⇒(β−y)∗(β′−y′)+(α−x)∗(α′−x′)=0\n⇒β′∗(β−y)−y′∗(β−y)+α′∗(α−x)−x′∗(α−x)=0\\Rightarrow \\beta&#x27;*(\\beta - y) - y&#x27;*(\\beta - y) + \\alpha&#x27;*(\\alpha - x) - x&#x27;*(\\alpha - x) = 0 \n⇒β′∗(β−y)−y′∗(β−y)+α′∗(α−x)−x′∗(α−x)=0\n⇒β′∗(β−y)+α′∗(α−x)−[y′∗(β−y)+x′∗(α−x)]=0\\Rightarrow \\beta&#x27;*(\\beta - y)  + \\alpha&#x27;*(\\alpha - x) - [y&#x27;*(\\beta - y) + x&#x27;*(\\alpha - x)] = 0 \\\\ \n⇒β′∗(β−y)+α′∗(α−x)−[y′∗(β−y)+x′∗(α−x)]=0\n有以下方程组：\n{(β−y)2+(α−x)2=L2(1)y′x′=β−yα−x(2)β′∗(β−y)+α′∗(α−x)−[y′∗(β−y)+x′∗(α−x)]=0(3)\\begin{cases}\n(\\beta - y)^2 + (\\alpha - x)^2 = L^2 \\quad (1) \\\\\n\\frac{y&#x27;}{x&#x27;} =\\frac{\\beta - y}{\\alpha - x} \\quad (2) \\\\\n\\beta&#x27;*(\\beta - y)  + \\alpha&#x27;*(\\alpha - x) - [y&#x27;*(\\beta - y) + x&#x27;*(\\alpha - x)] = 0  \\quad (3) \\\\\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​(β−y)2+(α−x)2=L2(1)x′y′​=α−xβ−y​(2)β′∗(β−y)+α′∗(α−x)−[y′∗(β−y)+x′∗(α−x)]=0(3)​\n将方程(2)(2)(2)代入方程(1)(1)(1)得：\ny′x′∗(β−y)+(α−x)=L2(α−x)(4)\\frac{y&#x27;}{x&#x27;} * (\\beta - y) + (\\alpha - x) = \\frac{L^2}{(\\alpha - x)} \\tag 4\nx′y′​∗(β−y)+(α−x)=(α−x)L2​(4)\n⇒y′∗(β−y)+(α−x)∗x′=x′∗L2(α−x)(5)\\Rightarrow y&#x27; * (\\beta - y) + (\\alpha - x) * x&#x27; = \\frac{x&#x27; * L^2}{(\\alpha - x)} \\tag 5\n⇒y′∗(β−y)+(α−x)∗x′=(α−x)x′∗L2​(5)\n或者：\n(β−y)+x′y′∗(α−x)=L2(β−y)(6)(\\beta - y) + \\frac{x&#x27;}{y&#x27;} * (\\alpha - x) = \\frac{L^2}{(\\beta - y)} \\tag 6\n(β−y)+y′x′​∗(α−x)=(β−y)L2​(6)\n⇒y′∗(β−y)+(α−x)∗x′=y′∗L2(β−y)(7)\\Rightarrow y&#x27; * (\\beta - y) + (\\alpha - x) * x&#x27; = \\frac{y&#x27; * L^2}{(\\beta - y)} \\tag 7\n⇒y′∗(β−y)+(α−x)∗x′=(β−y)y′∗L2​(7)\n将方程(5)(5)(5)和(7)(7)(7)代入到方程(3)(3)(3)中，得到：\n{β′∗(β−y)+α′∗(α−x)−x′∗L2(α−x)=0β′∗(β−y)+α′∗(α−x)−y′∗L2(β−y)=0\\begin{cases}\n\\beta&#x27;*(\\beta - y)  + \\alpha&#x27;*(\\alpha - x) -  \\frac{x&#x27; * L^2}{(\\alpha - x)} = 0 \\\\\n\\beta&#x27;*(\\beta - y)  + \\alpha&#x27;*(\\alpha - x) -  \\frac{y&#x27; * L^2}{(\\beta - y)} = 0 \\\\\n\\end{cases}\n{β′∗(β−y)+α′∗(α−x)−(α−x)x′∗L2​=0β′∗(β−y)+α′∗(α−x)−(β−y)y′∗L2​=0​\n⇒{x′=α−xL2∗[β′∗(β−y)+α′∗(α−x)]y′=β−yL2∗[β′∗(β−y)+α′∗(α−x)]\\Rightarrow \n\\begin{cases}\nx&#x27; = \\frac{\\alpha - x}{L^2} * [\\beta&#x27;*(\\beta - y)  + \\alpha&#x27;*(\\alpha - x)] \\\\\ny&#x27; = \\frac{\\beta - y}{L^2} * [\\beta&#x27;*(\\beta - y)  + \\alpha&#x27;*(\\alpha - x)] \\\\\n\\end{cases}\n⇒{x′=L2α−x​∗[β′∗(β−y)+α′∗(α−x)]y′=L2β−y​∗[β′∗(β−y)+α′∗(α−x)]​\n⇒{x′=x−αL2∗[β′∗(y−β)+α′∗(x−α)]y′=y−βL2∗[β′∗(y−β)+α′∗(x−α)]\\Rightarrow \n\\begin{cases}\nx&#x27; = \\frac{x - \\alpha}{L^2} * [\\beta&#x27;*(y - \\beta)  + \\alpha&#x27;*(x - \\alpha)] \\\\\ny&#x27; = \\frac{y - \\beta}{L^2} * [\\beta&#x27;*(y - \\beta)  + \\alpha&#x27;*(x - \\alpha)] \\\\\n\\end{cases}\n⇒{x′=L2x−α​∗[β′∗(y−β)+α′∗(x−α)]y′=L2y−β​∗[β′∗(y−β)+α′∗(x−α)]​\n为一阶常微分方程组。\n 五、特殊情况-曳物线\n{x(t)=a∗[t−tanh(t)]y(t)=a∗sech(t)\\begin{cases}\nx(t) = a * [t-tanh(t)] \\\\\ny(t) = a * sech(t)\n\\end{cases}\n{x(t)=a∗[t−tanh(t)]y(t)=a∗sech(t)​\n推导过程：\n前轴中心路径为xxx轴正方向：\n{α=tβ=0\\begin{cases}\n\\alpha = t \\\\\n\\beta = 0\n\\end{cases}\n{α=tβ=0​\n则：\n{x′=x−αL2∗[β′∗(y−β)+α′∗(x−α)]y′=y−βL2∗[β′∗(y−β)+α′∗(x−α)]\\begin{cases}\nx&#x27; = \\frac{x - \\alpha}{L^2} * [\\beta&#x27;*(y - \\beta)  + \\alpha&#x27;*(x - \\alpha)] \\\\\ny&#x27; = \\frac{y - \\beta}{L^2} * [\\beta&#x27;*(y - \\beta)  + \\alpha&#x27;*(x - \\alpha)] \\\\\n\\end{cases}\n{x′=L2x−α​∗[β′∗(y−β)+α′∗(x−α)]y′=L2y−β​∗[β′∗(y−β)+α′∗(x−α)]​\n⇒{x′=x−tL2∗(x−t)y′=yL2∗(x−t)\\Rightarrow\n\\begin{cases}\nx&#x27; = \\frac{x - t}{L^2} * (x - t) \\\\\ny&#x27; = \\frac{y}{L^2} * (x - t) \\\\\n\\end{cases}\n⇒{x′=L2x−t​∗(x−t)y′=L2y​∗(x−t)​\n 六、参考文献\nPython求解自行车前后轮轨迹问题\n","categories":["算法"]},{"title":"非线性优化工具IPOPT安装","url":"/2025/02/04/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7IPOPT%E5%AE%89%E8%A3%85/","content":"详细记录了在 Linux（Ubuntu 20.04）环境下安装 IPOPT 及其依赖项（如 ASL、HSL、MUMPS、ColPack、Adol-C）的方法，涵盖 C++ 和 Python 两种使用场景，并附带错误排查建议和编译参数说明，是一份非常实用的安装部署手册。\n\n C++\n Ipopt安装\nLinux | Ubuntu 20.04安装ipopt和cppAD | 安装全流程+报错解决\n按照方法二，成功安装Ipot3.14.17版本\n 源码安装\n\n安装依赖\n\nsudo apt-get install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev libblas-dev \n\n创建一个存放所有跟Ipopt相关的文件夹，便于管理\n\nmkdir ~/Ipopt_pkgcd Ipopt_pkg\n\n安装ASL\n\ngit clone https://github.com/coin-or-tools/ThirdParty-ASL.gitcd ThirdParty-ASLsudo ./get.ASLsudo ./configuresudo makesudo make installcd ..\n\n安装HSL\n\ngit clone https://github.com/coin-or-tools/ThirdParty-HSL.gitcd ThirdParty-HSL# 接下来需要下载coinhsl文件，并解压到ThirdParty-HSL目录下\n下载coinhsl.zip文件，并解压到ThirdParty-HSL目录下\n在ThirdParty-HSL目录下，执行以下命令\nsudo ./configuresudo makesudo make installcd ..\n\n安装MUMPS\n\ngit clone https://github.com/coin-or-tools/ThirdParty-Mumps.gitcd ThirdParty-Mumpssudo ./get.Mumpssudo ./configuresudo makesudo make installcd ..\n\n安装Ipopt\n\ngit clone https://github.com/coin-or/Ipopt.gitcd Ipoptmkdir buildcd buildsudo ../configuresudo makesudo make testsudo make install\n\n完善环境\n\ncd /usr/local/includesudo cp coin-or coin -rsudo ln -s /usr/local/lib/libcoinmumps.so.3 /usr/lib/libcoinmumps.so.3sudo ln -s /usr/local/lib/libcoinhsl.so.2 /usr/lib/libcoinhsl.so.2sudo ln -s /usr/local/lib/libipopt.so.3 /usr/lib/libipopt.so.3\n ColPack安装\n 指令安装(验证可行)\nsudo apt-get install libcolpack-dev# 默认安装在/usr目录下\n# 查询是否安装了ColPackldconfig -p | grep ColPack\n\n 源码安装\n\n源码下载\n\ngit clone https://github.com/CSCsw/ColPack.git  #Download ColPackcd ColPack             # ColPack Root Directory\n\n安装\n\n该方法变以后的头文件和库所在位置是错误的，需要调整位置。否则，安装Adolc时会链接不到。\n\n通过autotools安装\n\ncd build/automake      # automake folderautoreconf -vif        # generate configure files based on the machincemkdir mywork           cd myworkfullpath=$(pwd)        # modify fullpath to your destination folder if need../configure --prefix=$&#123;fullpath&#125;  make -j 4              # Where &quot;4&quot; is the number of cores on your machinemake install           # install lib and include/ColPack to destination  \n\n通过cmake安装\n\nmkdir build/cmake/myworkcd build/cmake/myworkfullpath=$(pwd)        # modify fullpath to your destination folder if needcmake .. -DCMAKE_INSTALL_PREFIX:PATH=$&#123;fullpath&#125; make -j 4              # Where &quot;4&quot; is the number of cores on your machinemake install           # install the libararies\n\n如果指定v1.0.10版本(验证可行)\n\ngit checkout v1.0.10./autoconf.sh# 配置安装地址./configure --prefix=$&#123;ColPack的安装地址&#125;makesudo make install\n\n$&#123;ColPack的安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n\n\n头文件在include/ColPack/目录\n库文件在lib/目录\n\n\n可以直接修改autoconf.sh文件内容，配置安装地址\n\n\n Adolc安装\n库地址\n 使用CMake安装(目前还不成熟)\n\n 使用AutoTools安装(验证可行)\n 使用 AutoTools 进行本地安装\n\n\n执行 autoreconf -fi\n\n\n运行 configure，可能需要使用以下选项之一：\n\n--prefix=PREFIX：将库和头文件安装到 PREFIX 目录（默认：${HOME}/adolc_base）。\n--enable-sparse：构建稀疏驱动程序（默认：no）。\n--with-openmp-flag=FLAG：使用 FLAG 来启用编译时的 OpenMP（默认：none）。\n--enable-docexa：构建文档化的示例（默认：no）。\n--enable-addexa：构建额外的示例（默认：no）。\n--enable-parexa：构建并行示例（默认：no）。如果启用此选项，则需要使用 --with-openmp-flag=FLAG。\n--with-cflags=FLAGS：使用 CFLAGS=FLAGS（默认：-g -O2）。\n--with-cxxflags=FLAGS：使用 CXXFLAGS=FLAGS（默认：-g -O2 -std=c++11）。\n--with-boost=BOOST_PATH：指定已编译的 Boost 库路径，默认选择系统库（如果存在）。\n\n\n\n执行 make\n\n\n执行 make install\n默认情况下，make install 会将所有文件安装到 $&#123;PREFIX&#125;/lib 和 $&#123;PREFIX&#125;/include 目录。如果需要指定其他安装目录，可以在 configure 调用时使用 --prefix 选项。\n\n\n此过程会在适当的目录中生成所有必需的makefile。执行 ./configure --help 可以查看其他可用选项的详细信息。\n 非本地安装\n如同在 INSTALL 文件中提到的，可以使用 --prefix=PATH 配置选项将 adolc 软件包安装到与 $&#123;HOME&#125;/adolc_base 不同的目录。这通常用于全局安装。常见的路径包括 /usr 和 /usr/local/，并且还有其他路径也会被使用。通过提供额外的 configure 选项，可以对安装目录进行更精细的控制。详情请参见 ./configure --help。\n执行 make install 完成安装时，目标目录必须具有写权限。确保你拥有相关权限，否则可能会得到意外结果。\n如果需要多个用户共享库文件，全局安装可能会非常有用。通过将库路径添加到 /etc/ld.so.conf，就可以避免使用 LD_LIBRARY_PATH 和 -L 链接选项。在许多情况下，例如 PATH=/usr/local，还可以避免在编译源代码时使用 -I 指令。\n 安装指令(验证可行)\n# 1. 下载源代码git clone https://github.com/coin-or/ADOL-C.gitcd ADOL-C/# 2. 切换到所需版本分支git checkout releases/2.7.2# 3. 执行前期准备（需要AutoTools工具）autoreconf -fi# 4. 配置安装目录和所需驱动CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib \\./configure --prefix=$&#123;Adolc想要安装地址&#125; --enable-sparse --with-colpack=$&#123;ColPack的安装地址&#125;# 5. 编译make# 6. 安装make install\n\n$&#123;Adolc想要安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n$&#123;ColPack的安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n\n注意：\n\n需要切换发布版本，比如releases/2.7.2，否则autoreconf -fi会执行失败\n需要指定CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib，否则会出现yes/lib64等异常路径，导致失败。(通过设置 CPPFLAGS 和 LDFLAGS 环境变量明确指定 ColPack 的路径来配置 ADOL-C)\n\n\n验证是否成功链接上ColPack库: \n\nldd libadolc.so\n\n\n Python\nc++与python非线性规(优)划（化）工具\n在Ubuntu + Anaconda环境下安装pyomo与ipopt：\n## 进入虚拟环境conda update condaconda update anacondaconda install -c conda-forge pyomoconda install -c conda-forge pyomo.extrasconda install -c conda-forge coincbcconda install -c conda-forge ipopt\n 拓展知识\n 编译参数CPPFLAGS、CFLAGS、LDFLAGS的理解\n\n\nCPPFLAGS: 预处理器需要的选项 如：-I(大写i指定头文件路径)\nCFLAGS：编译的时候使用的参数–Wall –g -c\nLDFLAGS：链接库使用的选项–L -l(大写L指定动态库的路径，小写L指定动态库的名称)\n\n\n\n\nCFLAGS表示用于C编译器的选项\nCXXFLAGS表示用于C++编译器的选项\n这两个变量实际上涵盖了编译和汇编的两个步骤\n\n\n\n\nCPPFLAGS：指定头文件(.h)的路径，如：CPPFLAGS=-I/usr/include -I/path/include。\n\n安装一个包时会在安装路径下建立一个include文件夹;\n当安装过程中出现故障时，试着把曾经安装的包的include文件夹增加到该变量中来。\n\n\n\nLDFLAGS：gcc等编译器会用到的一些优化參数，也能够在里面指定库文件的位置。\n使用方法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n\n每安装一个包，一定会在安装文件夹里建立一个lib文件夹。\n假设已经安装了某个包，而在安装另一个包时，它愣是说找不到，那就将那个包的lib路径增加的LDFALGS中试一下。\n\n\n\nLIBS：告诉链接器要链接哪些库文件。如LIBS = -lpthread -liconv\n\n简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。\n有时候LDFLAGS指定-L尽管能让链接器找到库进行链接。可是运行时链接器却找不到这个库。假设要让软件运行时库文件的路径也得到扩展，那么我们须要增加这两个库给-Wl,R：\n假设在运行./configure曾经环境变量设置export LDFLAGS=&quot;-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib&quot;\n\n注意环境变量设置等号两边不能够有空格，并且要加上引号（shell的使用方法）。\n那么运行configure以后。Makefile将会设置这个选项，链接时会有这个參数，编译出来的可运行程序的库文件搜索路径就得到扩展了。LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib\n\n\n\n\n\n","categories":["算法","Linux软件开发"]}]