[{"title":"Apollo r5.5.0 代码解读之规划模块--多项次曲线","url":"/2021/02/02/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E8%A7%84%E5%88%92%E6%A8%A1%E5%9D%97--%E5%A4%9A%E9%A1%B9%E6%AC%A1%E6%9B%B2%E7%BA%BF/","content":" 简介\n点到点的轨迹规划算法可以理解为在规划的时间TTT内，从已知起始点 θstart\\theta_{start}θstart​运动到末尾点θend\\theta_{end}θend​的方法。这里引入中间变量s(t)s(t)s(t)，它是时间的函数，定义域[0,T][0,T][0,T]，值域[0,1][0,1][0,1]，sss与θ\\thetaθ的关系见下面公式。这个公式不难理解，当s=0s=0s=0时，θ=θstart\\theta=\\theta_{start}θ=θstart​；当s=1s=1s=1时，θ=θend\\theta=\\theta_{end}θ=θend​。\n\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)&amp;=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns&amp;=s(t),t\\in[0,T] \\\\\n\\end{aligned}\nθ(s)s​=θstart​+s(θend​−θstart​),s∈[0,1]=s(t),t∈[0,T]​\nθ\\thetaθ对ttt求导是速度，即：\n∂θ∂t=∂θ∂s⋅∂s∂t其中∂θ∂s=θend−θstart∂θ∂t=(θend−θstart)⋅∂s∂t\\begin{aligned}\n\\frac{\\partial\\theta}{\\partial t}&amp;= \\frac{\\partial\\theta}{\\partial s} \\cdot \\frac{\\partial s}{\\partial t} \\quad其中\\frac{\\partial\\theta}{\\partial s}=\\theta_{end} -\\theta_{start} \\\\\n\\frac{\\partial\\theta}{\\partial t}&amp;=(\\theta_{end} -\\theta_{start})\\cdot \\frac{\\partial s}{\\partial t} \\\\\n\\end{aligned}\n∂t∂θ​∂t∂θ​​=∂s∂θ​⋅∂t∂s​其中∂s∂θ​=θend​−θstart​=(θend​−θstart​)⋅∂t∂s​​\nθ\\thetaθ对ttt求二阶导是加速度，即\n∂2θ∂t2=∂(∂θ∂s)∂t⋅∂s∂t+∂θ∂s⋅∂2s∂t2其中∂(∂θ∂s)∂t=∂(θend−θstart)∂t=0∂2θ∂t2=(θend−θstart)⋅∂2s∂t2\\begin{aligned}\n\\frac{\\partial^2\\theta}{\\partial t^2}&amp;= \\frac{\\partial(\\frac{\\partial\\theta}{\\partial s})}{\\partial t} \\cdot \\frac{\\partial s}{\\partial t}+\\frac{\\partial\\theta}{\\partial s} \\cdot \\frac{\\partial^2 s}{\\partial t^2} \\quad其中\\frac{\\partial(\\frac{\\partial\\theta}{\\partial s})}{\\partial t}=\\frac{\\partial(\\theta_{end} -\\theta_{start})}{\\partial t}=0 \\\\\n\\frac{\\partial^2\\theta}{\\partial t^2}&amp;=(\\theta_{end} -\\theta_{start})\\cdot \\frac{\\partial^2 s}{\\partial t^2} \\\\\n\\end{aligned}\n∂t2∂2θ​∂t2∂2θ​​=∂t∂(∂s∂θ​)​⋅∂t∂s​+∂s∂θ​⋅∂t2∂2s​其中∂t∂(∂s∂θ​)​=∂t∂(θend​−θstart​)​=0=(θend​−θstart​)⋅∂t2∂2s​​\n由于θstart\\theta_{start}θstart​和θend\\theta_{end}θend​是已知的，所以速度和加速度随时间的变化取决与s=s(t),t∈[0,T]s=s(t),t\\in[0,T]s=s(t),t∈[0,T]。\n这里的s(t)s(t)s(t)有很多种方法，比较常见的是三次函数，五次函数，梯形函数，S曲线等。\n 三次曲线–&gt;cubic polynomial curve1d\nCubicPolynomialCurve1d::CubicPolynomialCurve1d(const double x0,                                               const double dx0,                                               const double ddx0,                                               const double x1,                                               const double param) &#123;  ComputeCoefficients(x0, dx0, ddx0, x1, param);  param_ = param;  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_ = x1;&#125;\ns(t)=a0+a1t+a2t2+a3t3s(t)=a_0 + a_1t + a_2t^2 + a_3t^3\ns(t)=a0​+a1​t+a2​t2+a3​t3\n入参初始条件\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02s(T)=a0+a1T+a2T2+a3T3=x1  ⟺  a3=x1−x0−dx0T−ddx02T2T3\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\ns(T) = a_0 + a_1T + a_2T^2 + a_3T^3 = x_1 \\iff a_3 = \\frac{x_1 - x_0 - dx_0T - \\frac{ddx_0}{2}T^2}{T^3}\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​s(T)=a0​+a1​T+a2​T2+a3​T3=x1​⟺a3​=T3x1​−x0​−dx0​T−2ddx0​​T2​​\nvoid CubicPolynomialCurve1d::ComputeCoefficients(const double x0,                                                 const double dx0,                                                 const double ddx0,                                                 const double x1,                                                 const double param) &#123;  DCHECK(param &gt; 0.0);  const double p2 = param * param;  const double p3 = param * p2;  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  coef_[3] = (x1 - x0 - dx0 * param - coef_[2] * p2) / p3;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble CubicPolynomialCurve1d::Evaluate(const std::uint32_t order,                                        const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return ((coef_[3] * p + coef_[2]) * p + coef_[1]) * p + coef_[0];    &#125;    case 1: &#123;      return (3.0 * coef_[3] * p + 2.0 * coef_[2]) * p + coef_[1];    &#125;    case 2: &#123;      return 6.0 * coef_[3] * p + 2.0 * coef_[2];    &#125;    case 3: &#123;      return 6.0 * coef_[3];    &#125;    default:      return 0.0;  &#125;&#125;\n 四次曲线–&gt;quartic polynomial curve1d\nQuarticPolynomialCurve1d::QuarticPolynomialCurve1d(    const double x0, const double dx0, const double ddx0, const double dx1,    const double ddx1, const double param) &#123;  param_ = param;  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_[0] = dx1;  end_condition_[1] = ddx1;  ComputeCoefficients(x0, dx0, ddx0, dx1, ddx1, param);&#125;\ns(t)=a0+a1t+a2t2+a3t3+a4t4s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4\ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4\n 入参初始条件（一）: x0, dx0, ddx0, dx1, ddx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(1)s&#x27;(T) = a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 1\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(1)\ns′′(T)=2a2+6a3T+12a4T2=ddx1(2)s&#x27;&#x27;(T) = 2a_2 + 6a_3T + 12a_4T^2 = ddx_1 \\tag2\ns′′(T)=2a2​+6a3​T+12a4​T2=ddx1​(2)\n公式3*(1)-T*(2)得：\n3a1+6a2T+9a3T2+12a4T3=3dx12a2T+6a3T2+12a4T3=T∗ddx1  ⟺  3a1+4a2T+3a3T2=3dx1−T∗ddx1  ⟺  a3=3dx1−T∗ddx1−3a1−4a2T3T2  ⟺  a3=3dx1−T∗ddx1−3dx0−2ddx0T3T2  ⟺  a3=3(dx1−ddx0T−dx0)−T∗(ddx1−ddx0)3T2\\begin{aligned}\n3a_1 + 6a_2T + 9a_3T^2 +12a_4T^3 &amp; = 3dx_1 \\\\\n2a_2T + 6a_3T^2 + 12a_4T^3&amp; = T*ddx_1 \\\\\n\\iff 3a_1 + 4a_2T +3a_3T^2 &amp;= 3dx_1 - T*ddx_1 \\\\\n\\iff a_3 &amp; = \\frac{3dx_1 - T*ddx_1-3a_1-4a_2T}{3T^2} \\\\\n\\iff a_3 &amp; = \\frac{3dx_1 - T*ddx_1-3dx_0 -2ddx_0T}{3T^2} \\\\\n\\iff a_3 &amp; = \\frac{3(dx_1 - ddx_0T - dx_0) - T*(ddx_1 - ddx_0)}{3T^2} \n\\end{aligned}\n3a1​+6a2​T+9a3​T2+12a4​T32a2​T+6a3​T2+12a4​T3⟺3a1​+4a2​T+3a3​T2⟺a3​⟺a3​⟺a3​​=3dx1​=T∗ddx1​=3dx1​−T∗ddx1​=3T23dx1​−T∗ddx1​−3a1​−4a2​T​=3T23dx1​−T∗ddx1​−3dx0​−2ddx0​T​=3T23(dx1​−ddx0​T−dx0​)−T∗(ddx1​−ddx0​)​​\n公式2(1)-T(2)得：\n2a1+4a2T+6a3T2+8a4T3=2dx12a2T+6a3T2+12a4T3=T∗ddx1  ⟺  2a1+2a2T−4a4T3=2dx1−T∗ddx1  ⟺  a4=2a1+2a2T−2dx1+T∗ddx14T3  ⟺  a4=2dx0+ddx0T−2dx1+T∗ddx14T3  ⟺  a4=−2(dx1−ddx0T−dx0)+T∗(ddx1−ddx0)4T3\\begin{aligned}\n2a_1 + 4a_2T + 6a_3T^2 +8a_4T^3 &amp; = 2dx_1 \\\\\n2a_2T + 6a_3T^2 + 12a_4T^3&amp; = T*ddx_1 \\\\\n\\iff 2a_1 + 2a_2T - 4a_4T^3 &amp;= 2dx_1 - T*ddx_1 \\\\\n\\iff a_4 &amp; = \\frac{2a_1 + 2a_2T - 2dx_1 + T*ddx_1}{4T^3} \\\\\n\\iff a_4 &amp; = \\frac{2dx_0 + ddx_0T - 2dx_1 + T*ddx_1}{4T^3} \\\\\n\\iff a_4 &amp; = \\frac{-2(dx_1 - ddx_0T - dx_0) + T*(ddx_1 - ddx_0)}{4T^3} \n\\end{aligned}\n2a1​+4a2​T+6a3​T2+8a4​T32a2​T+6a3​T2+12a4​T3⟺2a1​+2a2​T−4a4​T3⟺a4​⟺a4​⟺a4​​=2dx1​=T∗ddx1​=2dx1​−T∗ddx1​=4T32a1​+2a2​T−2dx1​+T∗ddx1​​=4T32dx0​+ddx0​T−2dx1​+T∗ddx1​​=4T3−2(dx1​−ddx0​T−dx0​)+T∗(ddx1​−ddx0​)​​\nvoid QuarticPolynomialCurve1d::ComputeCoefficients(    const double x0, const double dx0, const double ddx0, const double dx1,    const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  double b0 = dx1 - ddx0 * p - dx0;  double b1 = ddx1 - ddx0;  double p2 = p * p;  double p3 = p2 * p;  coef_[3] = (3 * b0 - b1 * p) / (3 * p2);  coef_[4] = (-2 * b0 + b1 * p) / (4 * p3);&#125;\n 入参初始条件（二）: x0, dx0, ddx0, x1, dx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4=x1(3)s(T)=a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 = x_1 \\tag 3\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4=x1​(3)\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(4)s&#x27;(T) =a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 4\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(4)\n公式4*(3)-T(4)得：\n4a0+4a1T+4a2T2+4a3T3+4a4T4=4x1a1T+2a2T2+3a3T3+4a4T4=T∗dx1  ⟺  4a0+3a1T+2a2T2+a3T3=4x1−T∗dx1  ⟺  a3=4x1−T∗dx1−4a0−3a1T−2a2T2T3  ⟺  a3=4x1−T∗dx1−4x0−3dx0T−ddx0T2T3  ⟺  a3=4(x1−x0−dx0T−ddx02T2)−T∗(dx1−dx0−ddx0T)T3\\begin{aligned}\n4a_0 + 4a_1T + 4a_2T^2 + 4a_3T^3 + 4a_4T^4&amp; = 4x_1 \\\\\na_1T + 2a_2T^2 + 3a_3T^3 + 4a_4T^4&amp; = T*dx_1 \\\\\n\\iff 4a_0 + 3a_1T + 2a_2T^2 + a_3T^3 &amp;= 4x_1 - T*dx_1 \\\\\n\\iff a_3 &amp; = \\frac{4x_1 - T*dx_1-4a_0-3a_1T-2a_2T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{4x_1 - T*dx_1 - 4x_0 - 3dx_0T-ddx_0T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{4(x_1-x_0-dx_0T-\\frac{ddx_0}{2}T^2) - T*(dx_1-dx_0 - ddx_0T)}{T^3} \n\\end{aligned}\n4a0​+4a1​T+4a2​T2+4a3​T3+4a4​T4a1​T+2a2​T2+3a3​T3+4a4​T4⟺4a0​+3a1​T+2a2​T2+a3​T3⟺a3​⟺a3​⟺a3​​=4x1​=T∗dx1​=4x1​−T∗dx1​=T34x1​−T∗dx1​−4a0​−3a1​T−2a2​T2​=T34x1​−T∗dx1​−4x0​−3dx0​T−ddx0​T2​=T34(x1​−x0​−dx0​T−2ddx0​​T2)−T∗(dx1​−dx0​−ddx0​T)​​\n公式3*(3)-T(3)得：\n3a0+3a1T+3a2T2+3a3T3+3a4T4=3x1a1T+2a2T2+3a3T3+4a4T4=T∗dx1  ⟺  3a0+2a1T+a2T2−a4T4=3x1−T∗dx1  ⟺  a4=3a0+2a1T+a2T2−3x1+T∗dx1T4  ⟺  a4=3x0+2dx0T+ddx02T2−3x1+T∗dx1T4  ⟺  a4=T∗(dx1−dx0−ddx0T)−3(x1−x0−dx0T−ddx02T2)T4\\begin{aligned}\n3a_0 + 3a_1T + 3a_2T^2 + 3a_3T^3 + 3a_4T^4&amp; = 3x_1 \\\\\na_1T + 2a_2T^2 + 3a_3T^3 + 4a_4T^4&amp; = T*dx_1 \\\\\n\\iff 3a_0 + 2a_1T + a_2T^2 - a_4T^4 &amp;= 3x_1 - T*dx_1 \\\\\n\\iff a_4 &amp; = \\frac{3a_0 + 2a_1T + a_2T^2 - 3x_1 + T*dx_1}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{3x_0 + 2dx_0T + \\frac{ddx_0}{2}T^2 - 3x_1 + T*dx_1}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{T*(dx_1 - dx_0 - ddx_0T) - 3(x_1-x_0-dx_0T - \\frac{ddx_0}{2}T^2)}{T^4} \n\\end{aligned}\n3a0​+3a1​T+3a2​T2+3a3​T3+3a4​T4a1​T+2a2​T2+3a3​T3+4a4​T4⟺3a0​+2a1​T+a2​T2−a4​T4⟺a4​⟺a4​⟺a4​​=3x1​=T∗dx1​=3x1​−T∗dx1​=T43a0​+2a1​T+a2​T2−3x1​+T∗dx1​​=T43x0​+2dx0​T+2ddx0​​T2−3x1​+T∗dx1​​=T4T∗(dx1​−dx0​−ddx0​T)−3(x1​−x0​−dx0​T−2ddx0​​T2)​​\nQuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointFirstOrder(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double p) &#123;  CHECK_GT(p, 0.0);  param_ = p;  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double b0 = x1 - coef_[0] - coef_[1] * p - coef_[2] * p2;  double b1 = dx1 - dx0 - ddx0 * p;  coef_[4] = (b1 * p - 3 * b0) / p4;  coef_[3] = (4 * b0 - b1 * p) / p3;  return *this;&#125;\n 入参初始条件（三）: x0, dx0, x1, dx1, ddx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4=x1(5)s(T)=a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 = x_1 \\tag 5\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4=x1​(5)\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(6)s&#x27;(T)=a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 6\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(6)\ns′′(T)=2a2+6a3T+12a4T2=ddx1(7)s&#x27;&#x27;(T)=2a_2 + 6a_3T + 12a_4T^2 = ddx_1 \\tag 7\ns′′(T)=2a2​+6a3​T+12a4​T2=ddx1​(7)\n公式12*(5)-6*T*(6)+T*T*(7)得：\n12a0+12a1T+12a2T2+12a3T3+12a4T4=12x16a1T+12a2T2+18a3T3+24a4T4=6dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  12a0+6a1T+2a2T2=12x1−6dx1T+ddx1T2  ⟺  a2=12x1−6dx1T+ddx1T2−12a0−6a1T2T2  ⟺  a2=12x1−6dx1T+ddx1T2−12x0−6dx0T2T2  ⟺  a2=0.5ddx1T2−3(dx1−dx0)T+6(x1−x0−dx0T)T2\\begin{aligned}\n12a_0 + 12a_1T + 12a_2T^2 + 12a_3T^3 + 12a_4T^4 &amp; = 12x_1 \\\\\n6a_1T + 12a_2T^2 + 18a_3T^3 + 24a_4T^4 &amp; = 6dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 12a_0 + 6a_1T + 2a_2T^2 &amp; = 12x_1 - 6dx_1T + ddx_1T^2 \\\\\n\\iff a_2 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12a_0 -6a_1T}{2T^2} \\\\\n\\iff a_2 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12x_0 -6dx_0T}{2T^2} \\\\\n\\iff a_2 &amp; = \\frac{0.5ddx_1T^2 - 3(dx_1-dx_0)T + 6(x_1-x_0-dx_0T)}{T^2} \\\\\n\\end{aligned}\n12a0​+12a1​T+12a2​T2+12a3​T3+12a4​T46a1​T+12a2​T2+18a3​T3+24a4​T42a2​T2+6a3​T3+12a4​T4⟺12a0​+6a1​T+2a2​T2⟺a2​⟺a2​⟺a2​​=12x1​=6dx1​T=ddx1​T2=12x1​−6dx1​T+ddx1​T2=2T212x1​−6dx1​T+ddx1​T2−12a0​−6a1​T​=2T212x1​−6dx1​T+ddx1​T2−12x0​−6dx0​T​=T20.5ddx1​T2−3(dx1​−dx0​)T+6(x1​−x0​−dx0​T)​​\n公式8*(5)-5*T*(6)+T*T*(7)得：\n8a0+8a1T+8a2T2+8a3T3+8a4T4=8x15a1T+10a2T2+15a3T3+20a4T4=5dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  8a0+3a1T−a3T3=8x1−5dx1T+ddx1T2  ⟺  a3=8a0+3a1T−8x1+5dx1T−ddx1T2T3  ⟺  a3=8x0+3dx0T−8x1+5dx1T−ddx1T2T3  ⟺  a3=−ddx1T2+5(dx1−dx0)T−8(x1−x0−dx0T)T3\\begin{aligned}\n8a_0 + 8a_1T + 8a_2T^2 + 8a_3T^3 + 8a_4T^4 &amp; = 8x_1 \\\\\n5a_1T + 10a_2T^2 + 15a_3T^3 + 20a_4T^4 &amp; = 5dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 8a_0 + 3a_1T - a_3T^3 &amp; = 8x_1 - 5dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{8a_0 + 3a_1T - 8x_1 + 5dx_1T - ddx_1T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{8x_0 + 3dx_0T - 8x_1 + 5dx_1T - ddx_1T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{-ddx_1T^2 + 5(dx_1-dx_0)T - 8(x_1-x_0-dx_0T)}{T^3} \\\\\n\\end{aligned}\n8a0​+8a1​T+8a2​T2+8a3​T3+8a4​T45a1​T+10a2​T2+15a3​T3+20a4​T42a2​T2+6a3​T3+12a4​T4⟺8a0​+3a1​T−a3​T3⟺a3​⟺a3​⟺a3​​=8x1​=5dx1​T=ddx1​T2=8x1​−5dx1​T+ddx1​T2=T38a0​+3a1​T−8x1​+5dx1​T−ddx1​T2​=T38x0​+3dx0​T−8x1​+5dx1​T−ddx1​T2​=T3−ddx1​T2+5(dx1​−dx0​)T−8(x1​−x0​−dx0​T)​​\n公式6*(5)-4*T*(6)+T*T*(7)得：\n6a0+6a1T+6a2T2+6a3T3+6a4T4=6x14a1T+8a2T2+12a3T3+16a4T4=4dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  6a0+2a1T+2a4T4=6x1−4dx1T+ddx1T2  ⟺  a3=3x1−2dx1T+0.5ddx1T2−3a0−a1TT4  ⟺  a3=3x1−2dx1T+0.5ddx1T2−3x0−dx0TT4  ⟺  a3=0.5ddx1T2−2(dx1−dx0)T+3(x1−x0−dx0T)T4\\begin{aligned}\n6a_0 + 6a_1T + 6a_2T^2 + 6a_3T^3 + 6a_4T^4 &amp; = 6x_1 \\\\\n4a_1T + 8a_2T^2 + 12a_3T^3 + 16a_4T^4 &amp; = 4dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 6a_0 + 2a_1T + 2a_4T^4 &amp; = 6x_1 - 4dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{3x_1 - 2dx_1T + 0.5ddx_1T^2-3a_0 -a_1T}{T^4} \\\\\n\\iff a_3 &amp; = \\frac{3x_1 - 2dx_1T + 0.5ddx_1T^2-3x_0 -dx_0T}{T^4} \\\\\n\\iff a_3 &amp; = \\frac{0.5ddx_1T^2 - 2(dx_1-dx_0)T + 3(x_1-x_0-dx_0T)}{T^4} \\\\\n\\end{aligned}\n6a0​+6a1​T+6a2​T2+6a3​T3+6a4​T44a1​T+8a2​T2+12a3​T3+16a4​T42a2​T2+6a3​T3+12a4​T4⟺6a0​+2a1​T+2a4​T4⟺a3​⟺a3​⟺a3​​=6x1​=4dx1​T=ddx1​T2=6x1​−4dx1​T+ddx1​T2=T43x1​−2dx1​T+0.5ddx1​T2−3a0​−a1​T​=T43x1​−2dx1​T+0.5ddx1​T2−3x0​−dx0​T​=T40.5ddx1​T2−2(dx1​−dx0​)T+3(x1​−x0​−dx0​T)​​\nQuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointSecondOrder(    const double x0, const double dx0, const double x1, const double dx1,    const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  param_ = p;  coef_[0] = x0;  coef_[1] = dx0;  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double b0 = x1 - coef_[0] - coef_[1] * p;  double b1 = dx1 - coef_[1];  double c1 = b1 * p;  double c2 = ddx1 * p2;  coef_[2] = (0.5 * c2 - 3 * c1 + 6 * b0) / p2;  coef_[3] = (-c2 + 5 * c1 - 8 * b0) / p3;  coef_[4] = (0.5 * c2 - 2 * c1 + 3 * b0) / p4;  return *this;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble QuarticPolynomialCurve1d::Evaluate(const std::uint32_t order,                                          const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return (((coef_[4] * p + coef_[3]) * p + coef_[2]) * p + coef_[1]) * p +             coef_[0];    &#125;    case 1: &#123;      return ((4.0 * coef_[4] * p + 3.0 * coef_[3]) * p + 2.0 * coef_[2]) * p +             coef_[1];    &#125;    case 2: &#123;      return (12.0 * coef_[4] * p + 6.0 * coef_[3]) * p + 2.0 * coef_[2];    &#125;    case 3: &#123;      return 24.0 * coef_[4] * p + 6.0 * coef_[3];    &#125;    case 4: &#123;      return 24.0 * coef_[4];    &#125;    default:      return 0.0;  &#125;&#125;\n 五次曲线–&gt;quintic polynomial curve1d\nQuinticPolynomialCurve1d::QuinticPolynomialCurve1d(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double ddx1, const double param) &#123;  ComputeCoefficients(x0, dx0, ddx0, x1, dx1, ddx1, param);  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_[0] = x1;  end_condition_[1] = dx1;  end_condition_[2] = ddx1;  param_ = param;&#125;\ns(t)=a0+a1t+a2t2+a3t3+a4t4+a5t5s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4 + a_5t^5\ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4+a5​t5\n{a0=x0a1=dx0a2=ddx02a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TTa5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{cases}{}\na_0 = x_0 \\\\ \na_1 = dx_0 \\\\\na_2 = \\frac{ddx_0}{2} \\\\\na_3 = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\na_4 =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\na_5 =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​a0​=x0​a1​=dx0​a2​=2ddx0​​a3​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)a4​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​a5​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n入参初始条件\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4+a5T5=x1(8)s(T) = a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 + a_5T^5 = x_1\\tag 8\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4+a5​T5=x1​(8)\ns′(T)=a1+2a2T+3a3T2+4a4T3+5a5T4=dx1(9)s&#x27;(T) = a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 + 5a_5T^4 = dx_1 \\tag 9\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3+5a5​T4=dx1​(9)\ns′′(T)=2a2+6a3T+12a4T2+20a5T3=ddx1(10)s&#x27;&#x27;(T) = 2a_2 + 6a_3T + 12a_4T^2 + 20a_5T^3 = ddx_1 \\tag{10}\ns′′(T)=2a2​+6a3​T+12a4​T2+20a5​T3=ddx1​(10)\n公式20*(8)-5*T*(9)+T*T*(10)得：\n20a0+20a1T+20a2T2+20a3T3+20a4T4+20a5T5=20x18a1T+16a2T2+24a3T3+32a4T4+40a5T5=8dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  20a0+12a1T+6a2T2+2a3T3=20x1−8dx1T+ddx1T2  ⟺  a3=20x1−8dx1T+ddx1T2−20a0−12a1T−6a2T22T3  ⟺  a3=20x1−8dx1T+ddx1T2−20x0−12dx0T−3ddx0T22T3  ⟺  a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)\\begin{aligned}\n20a_0 + 20a_1T + 20a_2T^2 + 20a_3T^3 + 20a_4T^4 + 20a_5T^5 &amp; = 20x_1 \\\\\n8a_1T + 16a_2T^2 + 24a_3T^3 + 32a_4T^4 + 40a_5T^5 &amp; = 8dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 20a_0 + 12a_1T + 6a_2T^2 + 2a_3T^3&amp; = 20x_1 - 8dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{20x_1 - 8dx_1T + ddx_1T^2 - 20a_0 - 12a_1T - 6a_2T^2}{2T^3} \\\\\n\\iff a_3 &amp; = \\frac{20x_1 - 8dx_1T + ddx_1T^2 - 20x_0 - 12dx_0T - 3ddx_0T^2}{2T^3} \\\\\n\\iff a_3 &amp; = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\n\\end{aligned}\n20a0​+20a1​T+20a2​T2+20a3​T3+20a4​T4+20a5​T58a1​T+16a2​T2+24a3​T3+32a4​T4+40a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺20a0​+12a1​T+6a2​T2+2a3​T3⟺a3​⟺a3​⟺a3​​=20x1​=8dx1​T=ddx1​T2=20x1​−8dx1​T+ddx1​T2=2T320x1​−8dx1​T+ddx1​T2−20a0​−12a1​T−6a2​T2​=2T320x1​−8dx1​T+ddx1​T2−20x0​−12dx0​T−3ddx0​T2​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)​\n提示：逆推一下得证。\n公式15*(8)-7*T*(9)+T*T*(10)得：\n15a0+15a1T+15a2T2+15a3T3+15a4T4+15a5T5=15x17a1T+14a2T2+21a3T3+28a4T4+35a5T5=7dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  15a0+8a1T+3a2T2−a4T4=15x1−7dx1T+ddx1T2  ⟺  a4=15a0+8a1T+3a2T2−15x1+7dx1T−ddx1T2T4  ⟺  a4=15x0+8dx0T+3ddx02T2−15x1+7dx1T−ddx1T2T4  ⟺  a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TT\\begin{aligned}\n15a_0 + 15a_1T + 15a_2T^2 + 15a_3T^3 + 15a_4T^4 + 15a_5T^5 &amp; = 15x_1 \\\\\n7a_1T + 14a_2T^2 + 21a_3T^3 + 28a_4T^4 + 35a_5T^5 &amp; = 7dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 15a_0 + 8a_1T + 3a_2T^2 - a_4T^4&amp; = 15x_1 - 7dx_1T + ddx_1T^2 \\\\\n\\iff a_4 &amp; = \\frac{15a_0 + 8a_1T + 3a_2T^2 - 15x_1 + 7dx_1T - ddx_1T^2}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{15x_0 + 8dx_0T + 3\\frac{ddx_0}{2}T^2 - 15x_1 + 7dx_1T - ddx_1T^2}{T^4} \\\\\n\\iff a_4 &amp; =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\n\\end{aligned}\n15a0​+15a1​T+15a2​T2+15a3​T3+15a4​T4+15a5​T57a1​T+14a2​T2+21a3​T3+28a4​T4+35a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺15a0​+8a1​T+3a2​T2−a4​T4⟺a4​⟺a4​⟺a4​​=15x1​=7dx1​T=ddx1​T2=15x1​−7dx1​T+ddx1​T2=T415a0​+8a1​T+3a2​T2−15x1​+7dx1​T−ddx1​T2​=T415x0​+8dx0​T+32ddx0​​T2−15x1​+7dx1​T−ddx1​T2​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​​\n提示：逆推一下得证。\n公式12*(8)-6*T*(9)+T*T*(10)得：\n12a0+12a1T+12a2T2+12a3T3+12a4T4+12a5T5=12x16a1T+12a2T2+18a3T3+24a4T4+30a5T5=6dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  12a0+6a1T+2a2T2+2a5T5=12x1−6dx1T+ddx1T2  ⟺  a5=12x1−6dx1T+ddx1T2−12a0−6a1T−2a2T22T5  ⟺  a5=12x1−6dx1T+ddx1T2−12x0−6dx0T−ddx0T22T5  ⟺  a5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{aligned}\n12a_0 + 12a_1T + 12a_2T^2 + 12a_3T^3 + 12a_4T^4 + 12a_5T^5 &amp; = 12x_1 \\\\\n6a_1T + 12a_2T^2 + 18a_3T^3 + 24a_4T^4 + 30a_5T^5 &amp; = 6dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 12a_0 + 6a_1T + 2a_2T^2 + 2a_5T^5&amp; = 12x_1 - 6dx_1T + ddx_1T^2 \\\\\n\\iff a_5 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12a_0 - 6a_1T - 2a_2T^2}{2T^5} \\\\\n\\iff a_5 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12x_0 - 6dx_0T - ddx_0T^2}{2T^5} \\\\\n\\iff a_5 &amp; =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{aligned}\n12a0​+12a1​T+12a2​T2+12a3​T3+12a4​T4+12a5​T56a1​T+12a2​T2+18a3​T3+24a4​T4+30a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺12a0​+6a1​T+2a2​T2+2a5​T5⟺a5​⟺a5​⟺a5​​=12x1​=6dx1​T=ddx1​T2=12x1​−6dx1​T+ddx1​T2=2T512x1​−6dx1​T+ddx1​T2−12a0​−6a1​T−2a2​T2​=2T512x1​−6dx1​T+ddx1​T2−12x0​−6dx0​T−ddx0​T2​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n提示：逆推一下得证。\nvoid QuinticPolynomialCurve1d::ComputeCoefficients(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = ddx0 / 2.0;  const double p2 = p * p;  const double p3 = p * p2;  // the direct analytical method is at least 6 times faster than using matrix  // inversion.  const double c0 = (x1 - 0.5 * p2 * ddx0 - dx0 * p - x0) / p3;  const double c1 = (dx1 - ddx0 * p - dx0) / p2;  const double c2 = (ddx1 - ddx0) / p;  coef_[3] = 0.5 * (20.0 * c0 - 8.0 * c1 + c2);  coef_[4] = (-15.0 * c0 + 7.0 * c1 - c2) / p;  coef_[5] = (6.0 * c0 - 3.0 * c1 + 0.5 * c2) / p2;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble QuinticPolynomialCurve1d::Evaluate(const uint32_t order,                                          const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return ((((coef_[5] * p + coef_[4]) * p + coef_[3]) * p + coef_[2]) * p +              coef_[1]) *                 p +             coef_[0];    &#125;    case 1: &#123;      return (((5.0 * coef_[5] * p + 4.0 * coef_[4]) * p + 3.0 * coef_[3]) * p +              2.0 * coef_[2]) *                 p +             coef_[1];    &#125;    case 2: &#123;      return (((20.0 * coef_[5] * p + 12.0 * coef_[4]) * p) + 6.0 * coef_[3]) *                 p +             2.0 * coef_[2];    &#125;    case 3: &#123;      return (60.0 * coef_[5] * p + 24.0 * coef_[4]) * p + 6.0 * coef_[3];    &#125;    case 4: &#123;      return 120.0 * coef_[5] * p + 24.0 * coef_[4];    &#125;    case 5: &#123;      return 120.0 * coef_[5];    &#125;    default:      return 0.0;  &#125;&#125;\n","categories":["Apollo源码解读"]},{"title":"Apollo r5.5.0 代码解读之积分(Integral)","url":"/2022/09/26/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E7%A7%AF%E5%88%86(Integral)/","content":"解读integral.h integral.cc文件。\n\n 简介\nI=∫abf(x)dxI=\\int_{a}^{b}f(x)dx \\quad\nI=∫ab​f(x)dx\n只要找到被积公式的原函数F(x)F(x)F(x)，利用牛顿-莱布尼兹公式有：\n∫abf(x)dx=F(b)−F(a)\\int_{a}^{b}f(x)dx=F(b)-F(a)\n∫ab​f(x)dx=F(b)−F(a)\n还可以使用分割法，分割成无穷多个小区间：\n∫abf(x)dx=lim⁡x→∞∑i=1nb−anf(a+b−ani)\\int_{a}^{b}f(x)dx=\\lim_{x \\to \\infty}\\sum_{i=1}^{n}\\frac{b-a}{n}f(a+\\frac{b-a}{n}i)\n∫ab​f(x)dx=x→∞lim​i=1∑n​nb−a​f(a+nb−a​i)\n此外，可以使用数值积分。\n 数值积分：\n 高斯勒让德积分公式(GaussLegendre)\n 理论\n∫abf(x)dx≈∑k=0nAkf(xk)\\int_{a}^{b}f(x)dx\\approx \\sum_{k=0}^{n}A_kf(x_k)\n∫ab​f(x)dx≈k=0∑n​Ak​f(xk​)\n高斯–勒让德求积公式是构造高精度差值积分的最好方法之一。他是通过让节点和积分系数待定让函数f(x)f(x)f(x)以此取i=0,1,2...ni=0,1,2 ...ni=0,1,2...n次多项式使其尽可能多的能够精确成立来求出积分节点和积分系数。高斯积分的代数精度是2n−12n-12n−1，而且是最高的。通常的运用的是(−1,1)(-1,1)(−1,1)的积分节点和积分系数，其他积分域是通过变换公式x=(b−a)∗t/2+(b+a)/2x=(b-a)*t/2+(b+a)/2x=(b−a)∗t/2+(b+a)/2变换到-1到1之间积分。t∈(−1,1)t \\in (-1,1)t∈(−1,1)\nf(x)x∈(a,b)f(x) \\quad x\\in(a,b) \nf(x)x∈(a,b)\nx=(b−a)∗t/2+(b+a)/2t∈(−1,1)x=(b-a)*t/2+(b+a)/2 \\quad t\\in(-1,1)\nx=(b−a)∗t/2+(b+a)/2t∈(−1,1)\n⇔f((b−a)∗t/2+(b+a)/2)t∈(−1,1)\\Leftrightarrow\nf((b-a)*t/2+(b+a)/2) \\quad t\\in(-1,1)\n⇔f((b−a)∗t/2+(b+a)/2)t∈(−1,1)\n⇔g(t)t∈(−1,1)\\Leftrightarrow\ng(t) \\quad t\\in(-1,1)\n⇔g(t)t∈(−1,1)\n∫abf(x)dx=b−a2∫−11f((b−a)∗t/2+(b+a)/2)dt=b−a2∫−11g(t)dt\\int_{a}^{b}f(x)dx= \\frac{b-a}{2}\\int_{-1}^{1}f((b-a)*t/2+(b+a)/2)dt = \\frac{b-a}{2}\\int_{-1}^{1}g(t)dt\n∫ab​f(x)dx=2b−a​∫−11​f((b−a)∗t/2+(b+a)/2)dt=2b−a​∫−11​g(t)dt\n最终使用的标准形式：\n∫−11f(x)dx≈∑k=0nAkf(xk)\\int_{-1}^{1}f(x)dx\\approx \\sum_{k=0}^{n}A_kf(x_k)\n∫−11​f(x)dx≈k=0∑n​Ak​f(xk​)\ne.g.n=4e.g. \\quad n=4\ne.g.n=4\n∫−11f(x)dx≈A0f(x0)+A1f(x1)+A2f(x2)+A3f(x3)+A4f(x4)\\int_{-1}^{1}f(x)dx\\approx A_0f(x_0) + A_1f(x_1) + A_2f(x_2) + A_3f(x_3) + A_4f(x_4) \n∫−11​f(x)dx≈A0​f(x0​)+A1​f(x1​)+A2​f(x2​)+A3​f(x3​)+A4​f(x4​)\n有五组(n+1)(n+1)(n+1)系数(xk,Ak)(x_k, A_k)(xk​,Ak​)\n下表列出高斯–勒让德求积公式的节点和系数\n\n\n\nn\nxkx_kxk​\nAkA_kAk​\n\n\n\n\n0\n0.00.00.0\n2.02.02.0\n\n\n1\n±0.577350269189625764507\\pm 0.577350269189625764507±0.577350269189625764507\n1.01.01.0\n\n\n2\n0.00.00.0±0.774596669241483377010\\pm 0.774596669241483377010±0.774596669241483377010\n0.8888888888888888888770.8888888888888888888770.8888888888888888888770.5555555555555555555620.5555555555555555555620.555555555555555555562\n\n\n3\n±0.339981043584856264792\\pm 0.339981043584856264792±0.339981043584856264792±0.861136311594052575248\\pm 0.861136311594052575248±0.861136311594052575248\n0.6521451548625461426440.6521451548625461426440.6521451548625461426440.3478548451374538573830.3478548451374538573830.347854845137453857383\n\n\n4\n0.00.00.0±0.538469310105683091018\\pm 0.538469310105683091018±0.538469310105683091018±0.906179845938663992811\\pm 0.906179845938663992811±0.906179845938663992811\n0.5688888888888888888830.5688888888888888888830.5688888888888888888830.4786286704993664680300.4786286704993664680300.4786286704993664680300.2369268850561890875150.2369268850561890875150.236926885056189087515\n\n\n5\n±0.661209386466264513688\\pm 0.661209386466264513688±0.661209386466264513688±0.238619186083196908630\\pm 0.238619186083196908630±0.238619186083196908630±0.932469514203152027832\\pm 0.932469514203152027832±0.932469514203152027832\n0.3607615730481386075690.3607615730481386075690.3607615730481386075690.4679139345726910473890.4679139345726910473890.4679139345726910473890.1713244923791703450430.1713244923791703450430.171324492379170345043\n\n\n6\n0.00.00.0±0.405845151377397166917\\pm 0.405845151377397166917±0.405845151377397166917±0.741531185599394439864\\pm 0.741531185599394439864±0.741531185599394439864±0.949107912342758524541\\pm 0.949107912342758524541±0.949107912342758524541\n0.4179591836734693877490.4179591836734693877490.4179591836734693877490.3818300505051189449610.3818300505051189449610.3818300505051189449610.2797053914892766678900.2797053914892766678900.2797053914892766678900.1294849661688696932740.1294849661688696932740.129484966168869693274\n\n\n7\n±0.183434642495649804936\\pm 0.183434642495649804936±0.183434642495649804936±0.525532409916328985830\\pm 0.525532409916328985830±0.525532409916328985830±0.796666477413626739567\\pm 0.796666477413626739567±0.796666477413626739567±0.960289856497536231661\\pm 0.960289856497536231661±0.960289856497536231661\n0.3626837833783619829760.3626837833783619829760.3626837833783619829760.3137066458778872873380.3137066458778872873380.3137066458778872873380.2223810344533744705460.2223810344533744705460.2223810344533744705460.1012285362903762591540.1012285362903762591540.101228536290376259154\n\n\n8\n0.00.00.0±0.836031107326635794313\\pm 0.836031107326635794313±0.836031107326635794313±0.968160239507626089810\\pm 0.968160239507626089810±0.968160239507626089810±0.324253423403808929042\\pm 0.324253423403808929042±0.324253423403808929042±0.613371432700590397285\\pm 0.613371432700590397285±0.613371432700590397285\n0.3302393550012597631540.3302393550012597631540.3302393550012597631540.1806481606948574040590.1806481606948574040590.1806481606948574040590.8127438836157441197370.8127438836157441197370.8127438836157441197370.3123470770400028400570.3123470770400028400570.3123470770400028400570.2606106964029354623130.2606106964029354623130.260610696402935462313\n\n\n9\n±0.148874338981631210881\\pm 0.148874338981631210881±0.148874338981631210881±0.433395394129247190794\\pm 0.433395394129247190794±0.433395394129247190794±0.679409568299024406207\\pm 0.679409568299024406207±0.679409568299024406207±0.865063366688984510759\\pm 0.865063366688984510759±0.865063366688984510759±0.973906528517171720066\\pm 0.973906528517171720066±0.973906528517171720066\n0.2955242247147528701870.2955242247147528701870.2955242247147528701870.2692667193099963551050.2692667193099963551050.2692667193099963551050.2190863625159820440000.2190863625159820440000.2190863625159820440000.1494513491505805931500.1494513491505805931500.1494513491505805931500.6667134430868813759200.6667134430868813759200.666713443086881375920\n\n\n\n 代码实现\n/** * @brief Compute the integral of a target single-variable function *        from a lower bound to an upper bound, by 5-th Gauss-Legendre method * Given a target function and integral lower and upper bound, * compute the integral approximation using 5th order Gauss-Legendre * integration. * The target function must be a smooth function. * Example: * target function: auto func = [](const double x) &#123;return x * x;&#125;; *                  double integral = gauss_legendre(func, -2, 3); * This gives you the approximated integral of function x^2 in bound [-2, 3] * * reference: https://en.wikipedia.org/wiki/Gaussian_quadrature *            http://www.mymathlib.com/quadrature/gauss_legendre.html * * @param func The target single-variable function * @param lower_bound The lower bound of the integral * @param upper_bound The upper bound of the integral * @return The integral result */template &lt;std::size_t N&gt;double IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,                                const double lower_bound,                                const double upper_bound) &#123;  // 根据输入阶数，获取对应系数，这里N对应上表的n+1  // Apollo提供了N从2到10，也就是上表n从1到9  auto p = GetGaussLegendrePoints&lt;N&gt;();  std::array&lt;double, N&gt; x = p.first;  std::array&lt;double, N&gt; w = p.second;  // 复化系数  const double t = (upper_bound - lower_bound) * 0.5;  const double m = (upper_bound + lower_bound) * 0.5;  double integral = 0.0;  for (size_t i = 0; i &lt; N; ++i) &#123;    // 逐一累加各项和    integral += w[i] * func(t * x[i] + m);  &#125;  // 注意还乘t  return integral * t;&#125;/** * @brief Get the points and weights for different ordered Gauss-Legendre *        integration. Currently support order 2 - 10. Other input order will *        trigger compiling error. */template &lt;std::size_t N&gt;std::pair&lt;std::array&lt;double, N&gt;, std::array&lt;double, N&gt;&gt;GetGaussLegendrePoints();template &lt;&gt;inline std::pair&lt;std::array&lt;double, 2&gt;, std::array&lt;double, 2&gt;&gt;GetGaussLegendrePoints&lt;2&gt;() &#123;  std::array&lt;double, 2&gt; x;  x[0] = -5.77350269189625764507e-01;  x[1] = 5.77350269189625764507e-01;  std::array&lt;double, 2&gt; w;  w[0] = 1.0;  w[1] = 1.0;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 3&gt;, std::array&lt;double, 3&gt;&gt;GetGaussLegendrePoints&lt;3&gt;() &#123;  std::array&lt;double, 3&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 7.74596669241483377010e-01;  x[2] = -7.74596669241483377010e-01;  std::array&lt;double, 3&gt; w;  w[0] = 8.88888888888888888877e-01;  w[1] = 5.55555555555555555562e-01;  w[2] = 5.55555555555555555562e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 4&gt;, std::array&lt;double, 4&gt;&gt;GetGaussLegendrePoints&lt;4&gt;() &#123;  std::array&lt;double, 4&gt; x;  x[0] = 3.39981043584856264792e-01;  x[1] = -3.39981043584856264792e-01;  x[2] = 8.61136311594052575248e-01;  x[3] = -8.61136311594052575248e-01;  std::array&lt;double, 4&gt; w;  w[0] = 6.52145154862546142644e-01;  w[1] = 6.52145154862546142644e-01;  w[2] = 3.47854845137453857383e-01;  w[3] = 3.47854845137453857383e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 5&gt;, std::array&lt;double, 5&gt;&gt;GetGaussLegendrePoints&lt;5&gt;() &#123;  std::array&lt;double, 5&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 5.38469310105683091018e-01;  x[2] = -5.38469310105683091018e-01;  x[3] = 9.06179845938663992811e-01;  x[4] = -9.06179845938663992811e-01;  std::array&lt;double, 5&gt; w;  w[0] = 5.68888888888888888883e-01;  w[1] = 4.78628670499366468030e-01;  w[2] = 4.78628670499366468030e-01;  w[3] = 2.36926885056189087515e-01;  w[4] = 2.36926885056189087515e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 6&gt;, std::array&lt;double, 6&gt;&gt;GetGaussLegendrePoints&lt;6&gt;() &#123;  std::array&lt;double, 6&gt; x;  x[0] = 6.61209386466264513688e-01;  x[1] = -6.61209386466264513688e-01;  x[2] = 2.38619186083196908630e-01;  x[3] = -2.38619186083196908630e-01;  x[4] = 9.32469514203152027832e-01;  x[5] = -9.32469514203152027832e-01;  std::array&lt;double, 6&gt; w;  w[0] = 3.60761573048138607569e-01;  w[1] = 3.60761573048138607569e-01;  w[2] = 4.67913934572691047389e-01;  w[3] = 4.67913934572691047389e-01;  w[4] = 1.71324492379170345043e-01;  w[5] = 1.71324492379170345043e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 7&gt;, std::array&lt;double, 7&gt;&gt;GetGaussLegendrePoints&lt;7&gt;() &#123;  std::array&lt;double, 7&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 4.05845151377397166917e-01;  x[2] = -4.05845151377397166917e-01;  x[3] = 7.41531185599394439864e-01;  x[4] = -7.41531185599394439864e-01;  x[5] = 9.49107912342758524541e-01;  x[6] = -9.49107912342758524541e-01;  std::array&lt;double, 7&gt; w;  w[0] = 4.17959183673469387749e-01;  w[1] = 3.81830050505118944961e-01;  w[2] = 3.81830050505118944961e-01;  w[3] = 2.79705391489276667890e-01;  w[4] = 2.79705391489276667890e-01;  w[5] = 1.29484966168869693274e-01;  w[6] = 1.29484966168869693274e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 8&gt;, std::array&lt;double, 8&gt;&gt;GetGaussLegendrePoints&lt;8&gt;() &#123;  std::array&lt;double, 8&gt; x;  x[0] = 1.83434642495649804936e-01;  x[1] = -1.83434642495649804936e-01;  x[2] = 5.25532409916328985830e-01;  x[3] = -5.25532409916328985830e-01;  x[4] = 7.96666477413626739567e-01;  x[5] = -7.96666477413626739567e-01;  x[6] = 9.60289856497536231661e-01;  x[7] = -9.60289856497536231661e-01;  std::array&lt;double, 8&gt; w;  w[0] = 3.62683783378361982976e-01;  w[1] = 3.62683783378361982976e-01;  w[2] = 3.13706645877887287338e-01;  w[3] = 3.13706645877887287338e-01;  w[4] = 2.22381034453374470546e-01;  w[5] = 2.22381034453374470546e-01;  w[6] = 1.01228536290376259154e-01;  w[7] = 1.01228536290376259154e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 9&gt;, std::array&lt;double, 9&gt;&gt;GetGaussLegendrePoints&lt;9&gt;() &#123;  std::array&lt;double, 9&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 8.36031107326635794313e-01;  x[2] = -8.36031107326635794313e-01;  x[3] = 9.68160239507626089810e-01;  x[4] = -9.68160239507626089810e-01;  x[5] = 3.24253423403808929042e-01;  x[6] = -3.24253423403808929042e-01;  x[7] = 6.13371432700590397285e-01;  x[8] = -6.13371432700590397285e-01;  std::array&lt;double, 9&gt; w;  w[0] = 3.30239355001259763154e-01;  w[1] = 1.80648160694857404059e-01;  w[2] = 1.80648160694857404059e-01;  w[3] = 8.12743883615744119737e-02;  w[4] = 8.12743883615744119737e-02;  w[5] = 3.12347077040002840057e-01;  w[6] = 3.12347077040002840057e-01;  w[7] = 2.60610696402935462313e-01;  w[8] = 2.60610696402935462313e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 10&gt;, std::array&lt;double, 10&gt;&gt;GetGaussLegendrePoints&lt;10&gt;() &#123;  std::array&lt;double, 10&gt; x;  x[0] = 1.48874338981631210881e-01;  x[1] = -1.48874338981631210881e-01;  x[2] = 4.33395394129247190794e-01;  x[3] = -4.33395394129247190794e-01;  x[4] = 6.79409568299024406207e-01;  x[5] = -6.79409568299024406207e-01;  x[6] = 8.65063366688984510759e-01;  x[7] = -8.65063366688984510759e-01;  x[8] = 9.73906528517171720066e-01;  x[9] = -9.73906528517171720066e-01;  std::array&lt;double, 10&gt; w;  w[0] = 2.95524224714752870187e-01;  w[1] = 2.95524224714752870187e-01;  w[2] = 2.69266719309996355105e-01;  w[3] = 2.69266719309996355105e-01;  w[4] = 2.19086362515982044000e-01;  w[5] = 2.19086362515982044000e-01;  w[6] = 1.49451349150580593150e-01;  w[7] = 1.49451349150580593150e-01;  w[8] = 6.66713443086881375920e-02;  w[9] = 6.66713443086881375920e-02;  return std::make_pair(x, w);&#125;\n 梯形(Trapezoidal)求积公式\n 理论\n要求f(x)f(x)f(x)在[a,b][ a , b ][a,b]上的积分，将积分区间等长分成nnn段，则每两个分段点之间的距离h=b−anh=\\frac{b-a}{n}h=nb−a​，然后如下图进行近似：\n\n则该区间上的积分值就近似等同于每个小梯形的面积之和。\n第一个梯形（最左边）的上底f(x0)f(x_0)f(x0​)，下底f(x1)f(x_1)f(x1​)，高为h=b−anh=\\frac{b-a}{n}h=nb−a​，因此对应的面积为S1=(f(x0)+f(x1))∗h/2S_1=(f(x_0)+f(x_1))*h/2S1​=(f(x0​)+f(x1​))∗h/2。\n以此类推，最后一个（最右边）的上底f(xn−1)f(x_{n-1})f(xn−1​)，下底f(xn)f(x_n)f(xn​)，高为h=b−anh=\\frac{b-a}{n}h=nb−a​，因此对应的面积为Sn=(f(xn−1)+f(xn))∗h/2S_n=(f(x_{n-1})+f(x_n))*h/2Sn​=(f(xn−1​)+f(xn​))∗h/2。\n因此，所有梯形的总面积为：\n∫abf(x)dx≈∑i=1nSi=S1+S2+...+Sn=h/2[f(x0)+f(x1)+f(x1)+f(x2)+...+f(xn−2)+f(xn−1)+f(xn−1)+f(xn)]=h2[f(x0)+2∑i=1n−1f(xi)+f(xn)]=h∗∑i=1n−1f(xi)+0.5∗h(f(x0)+f(xn))\\begin{aligned}\n\\int_{a}^{b}f(x)dx \\approx \\sum_{i=1}^{n}S_i = S_1+S_2+...+S_n\n= h/2[f(x_0)+f(x_1)+f(x_1)+f(x_2)+...+f(x_{n-2})+f(x_{n-1})+f(x_{n-1})+f(x_n)] \\\\ \n= \\frac{h}{2}[f(x_0)+2\\sum_{i=1}^{n-1}f(x_i)+f(x_n)] \\\\\n= h*\\sum_{i=1}^{n-1}f(x_i)+0.5*h(f(x_0)+f(x_n))\n\\end{aligned}\n∫ab​f(x)dx≈i=1∑n​Si​=S1​+S2​+...+Sn​=h/2[f(x0​)+f(x1​)+f(x1​)+f(x2​)+...+f(xn−2​)+f(xn−1​)+f(xn−1​)+f(xn​)]=2h​[f(x0​)+2i=1∑n−1​f(xi​)+f(xn​)]=h∗i=1∑n−1​f(xi​)+0.5∗h(f(x0​)+f(xn​))​\n 代码实现\ndouble IntegrateByTrapezoidal(const std::vector&lt;double&gt;&amp; func, const double dx,                              const std::size_t nsteps) &#123;  // nsteps表示func集合元素的个数，也就是下标从0到nsteps-1，也就是意味着有nsteps-1个梯形  // 如参func为f(x_0)到f(x_&#123;nsteps-1&#125;)的集合，有nsteps个数，有nsteps-1个梯形  // dx就是步长(b-a)/(nsteps-1)，也就是公式里面的h  double sum = 0;  for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) &#123;    // 从i=1到i=nsteps-2的累加和    sum += func[i];  &#125;  return dx * sum + 0.5 * dx * (func[0] + func[nsteps - 1]);&#125;\n 辛普森(Simpson)求积公式\n 理论\n要求将区间划分成偶数个。\n\n辛普森积分法是一种用抛物线近似函数曲线来求定积分数值解的方法。把积分区间等分成若干段，对被积函数在每一段上使用辛普森公式，根据其在每一段的两端和中点处的值近似为抛物线，逐段积分后加起来，即得到原定积分的数值解。\n基本思想就是把复杂的函数f(x)f(x)f(x)近似成二次函数。\n∫abf(x)dx≈∫ab(Ax2+Bx+C)dx=A3(b3−a3)+B2(b2−a2)+C(b−a)=2A(b3−a3)+3B(b2−a2)+6C(b−a)6=(b−a)[2A(b2+ab+a2)+3B(b+a)+6C]6=(b−a)(Aa2+Ba+C+Ab2+Bb+C+Aa2+2Aab+Ab2+2Bb+2Ba+4C)6=(b−a)[f(a)+f(b)+A(a+b)2+2B(a+b)+4C]6=(b−a)[f(a)+f(b)+4(A(a+b2)2+Ba+b2+C)]6=(b−a)[f(a)+f(b)+4f(a+b2)]6\\begin{aligned}\n&amp;\\int_a^bf(x)dx \\approx \\int_a^b(Ax^2+Bx+C)dx \\\\\n&amp;=\\frac{A}{3}(b^3-a^3)+\\frac{B}{2}(b^2-a^2)+C(b-a) \\\\\n&amp;=\\frac{2A(b^3-a^3)+3B(b^2-a^2)+6C(b-a)}{6} \\\\\n&amp;=\\frac{(b-a)[2A(b^2+ab+a^2)+3B(b+a)+6C]}{6} \\\\\n&amp;=\\frac{(b-a)(Aa^2+Ba+C+Ab^2+Bb+C+Aa^2+2Aab+Ab^2+2Bb+2Ba+4C)}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+A(a+b)^2+2B(a+b)+4C]}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+4(A(\\frac{a+b}{2})^2+B\\frac{a+b}{2}+C)]}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+4f(\\frac{a+b}{2})]}{6}\n\\end{aligned}\n​∫ab​f(x)dx≈∫ab​(Ax2+Bx+C)dx=3A​(b3−a3)+2B​(b2−a2)+C(b−a)=62A(b3−a3)+3B(b2−a2)+6C(b−a)​=6(b−a)[2A(b2+ab+a2)+3B(b+a)+6C]​=6(b−a)(Aa2+Ba+C+Ab2+Bb+C+Aa2+2Aab+Ab2+2Bb+2Ba+4C)​=6(b−a)[f(a)+f(b)+A(a+b)2+2B(a+b)+4C]​=6(b−a)[f(a)+f(b)+4(A(2a+b​)2+B2a+b​+C)]​=6(b−a)[f(a)+f(b)+4f(2a+b​)]​​\n先求定积分∫abf(x)dx(a&lt;b)\\int_a^bf(x)dx \\quad (a&lt;b)∫ab​f(x)dx(a&lt;b)\n将闭区间等分成2n2n2n，即偶数个小区间[xi,xi+1](xi&lt;xi+1,x0=a,x2n=b,i∈[0,2n])[x_i, x_{i+1}] \\quad (x_i&lt;x_{i+1},x_0=a,x_{2n}=b,i\\in[0,2n])[xi​,xi+1​](xi​&lt;xi+1​,x0​=a,x2n​=b,i∈[0,2n])。在每个小区间上，用抛物线近似函数f(x)f(x)f(x)的曲线。每个区间长度为b−a2n\\frac{b-a}{2n}2nb−a​。\n以两个区间为基本单位，基本单位长度为b−an\\frac{b-a}{n}nb−a​，使用辛普森公式近似求积分：\ne.g.∫x0x2f(x)dx≈(x2−x0)[f(x0)+f(x2)+4f(x1)]6=(b−a)6n[f(x0)+4f(x1)+f(x2)]e.g. \\quad \\int_{x_0}^{x_2} f(x)dx\\approx \\frac{(x_2-x_0)[f(x_0)+f(x_2)+4f(x_1)]}{6} \\\\\n= \\frac{(b-a)}{6n} [f(x_0)+4f(x_1)+f(x_2)]\\\\\ne.g.∫x0​x2​​f(x)dx≈6(x2​−x0​)[f(x0​)+f(x2​)+4f(x1​)]​=6n(b−a)​[f(x0​)+4f(x1​)+f(x2​)]\ne.g.∫x2n−2x2nf(x)dx≈(x2n−x2n−2)[f(x2n−2)+f(x2n)+4f(x2n−1)]6=(b−a)6n[f(x2n−2)+4f(x2n−1)+f(x2n)]e.g. \\quad \\int_{x_{2n-2}}^{x_{2n}} f(x)dx\\approx \\frac{(x_{2n}-x_{2n-2})[f(x_{2n-2})+f(x_{2n})+4f(x_{2n-1})]}{6} \\\\\n= \\frac{(b-a)}{6n} [f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n})]\\\\\ne.g.∫x2n−2​x2n​​f(x)dx≈6(x2n​−x2n−2​)[f(x2n−2​)+f(x2n​)+4f(x2n−1​)]​=6n(b−a)​[f(x2n−2​)+4f(x2n−1​)+f(x2n​)]\n所以累加全部基本单位，可得：\n∫abf(x)dx≈∫x0x2f(x)dx+∫x2x4f(x)dx+...+∫x2n−2x2nf(x)dx=b−a6n[f(x0)+4f(x1)+f(x2)+f(x2)+4f(x3)+f(x4)+...+f(x2n−2)+4f(x2n−1)+f(x2n)]=b−a3∗2n[f(x0)+f(x2n)+4[f(x1)+f(x3)+...+f(x2n−1)]+2[f(x2)+f(x4)+...+f(x2n−2)]]\\begin{aligned}\n\\int_a^bf(x)dx \\approx \\int_{x_0}^{x_2} f(x)dx+\\int_{x_2}^{x_4} f(x)dx+...+\\int_{x_{2n-2}}^{x_{2n}} f(x)dx \\\\\n=\\frac{b-a}{6n}[f(x_0)+4f(x_1)+f(x_2) + f(x_2)+4f(x_3)+f(x_4) + ... + f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n})] \\\\\n=\\frac{b-a}{3*2n}[f(x_0)+f(x_{2n}) + 4[f(x_1)+f(x_3)+...+f(x_{2n-1})] + 2[f(x_2)+f(x_4)+...+f(x_{2n-2})]] \\\\\n\\end{aligned}\n∫ab​f(x)dx≈∫x0​x2​​f(x)dx+∫x2​x4​​f(x)dx+...+∫x2n−2​x2n​​f(x)dx=6nb−a​[f(x0​)+4f(x1​)+f(x2​)+f(x2​)+4f(x3​)+f(x4​)+...+f(x2n−2​)+4f(x2n−1​)+f(x2n​)]=3∗2nb−a​[f(x0​)+f(x2n​)+4[f(x1​)+f(x3​)+...+f(x2n−1​)]+2[f(x2​)+f(x4​)+...+f(x2n−2​)]]​\n 代码实现\ndouble IntegrateBySimpson(const std::vector&lt;double&gt;&amp; func, const double dx,                          const std::size_t nsteps) &#123;  // nsteps表示func集合元素的个数，也就是下标从0到nsteps-1，也就是意味着有nsteps-1个梯形  // 要求nsteps为奇数，也就是平分成偶数个梯形，nsteps-1个区间  // 如参func为f(x_0)到f(x_&#123;nsteps-1&#125;)的集合，有nsteps个数，有nsteps-1个梯形，即偶数个梯形  // dx就是步长(b-a)/(nsteps-1)，也就是每个区间的长度  CHECK_EQ(1, nsteps &amp; 1);  double sum1 = 0.0;  double sum2 = 0.0;  for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) &#123;    if ((i &amp; 1) != 0) &#123;      // 奇数求和      sum1 += func[i];    &#125; else &#123;      // 偶数求和      sum2 += func[i];    &#125;  &#125;  return dx / 3.0 * (4.0 * sum1 + 2.0 * sum2 + func[0] + func[nsteps - 1]);&#125;\n 参考文献\n[1]https://blog.csdn.net/xyz32768/article/details/81392369\n[2]https://baike.baidu.com/item/辛普森积分法/23337870?fr=aladdin\n[3]https://blog.csdn.net/justidle/article/details/112839920\n[4]https://wenku.baidu.com/view/b3fc62d74b7302768e9951e79b89680203d86bb7.html\n[5]https://max.book118.com/html/2019/0414/7142125161002020.shtm\n","categories":["Apollo源码解读"]},{"title":"CyberRT自定义部署流程 之 从零搭建交叉编译Docker镜像","url":"/2025/07/08/CyberRT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E4%B9%8B%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91Docker%E9%95%9C%E5%83%8F/","content":"本文章主要提供思路，许多地方都可以根据自定义修改以适配自己的实际情况。\n\n 准备好目标平台的交叉编译工具\n存放在toolchains/文件夹下。\n这个根据自己项目需求，网上或者找厂家获取交叉编译工具。\n比如：\n\n 准备好依赖库\n 依赖库是二进制库\n存放在sysroot/文件夹下。\n最好一份是x86，一份是目标平台。\n\n 依赖库是源码\n以压缩包形式存放在thirdparty/tarball/文件夹下。\n\n CyberRT v9.0.0版本依赖库\n\n本人梳理了CyberRT v9.0.0版本的依赖库，并从下载地址以压缩包形式下载下来：\n\nfast-rtps-1.5.0\nFast-CDR源码地址\nFast-DDS/Fast-rtps源码地址\nncurses-6.4（源码压缩包）\nncurses源码地址\nutil-linux-2.39（源码压缩包）\nutil-linux源码地址\nglog（通过git拉取源码）源码地址\nnlohmann_json（通过git拉取源码）源码地址\npython源码压缩包地址\n\n 搭建Docker镜像\n 创建docker_release_xcyber.sh脚本\n该脚本用于一键创建镜像，bash docker_release_xcyber.sh。\n#!/usr/bin/env bash# 自定义镜像名字DOCKER_REGISTRY=i-nogIMAGE_REPO=nog-cyber-kitIMAGE_TAG=$&#123;1:-&quot;1.1.0&quot;&#125;PLATFORM_X86=x86PLATFORM_ORIN=orin# 镜像名称ORIN_IMAGE_REPO=$&#123;DOCKER_REGISTRY&#125;/$&#123;IMAGE_REPO&#125;/plat_$&#123;PLATFORM_ORIN&#125;_devTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;# 指定dockerfile文件DOCKERFILE_ORIN_XCYBER=$&#123;TOP_DIR&#125;/dockerfile/Dockerfile.orin.xcyber# 创建一个文件夹，专门用于docker镜像构建的上下文CYBER_KIT=$&#123;TOP_DIR&#125;/cyber-kitORIN_IMAGE_CONTEXT=$&#123;CYBER_KIT&#125;-$&#123;PLATFORM_ORIN&#125;# 在上下文中创建所需文件夹，用于存放库和工具链mkdir -p $&#123;ORIN_IMAGE_CONTEXT&#125;/&#123;sysroot,toolchains&#125;echo &quot;=== prepare cyber-kit files for x86 ... ===&quot;# 压缩已有的 x86 版本的系统库，并拷贝到上下文中cd $&#123;TOP_DIR&#125;/sysroottar czf $&#123;PLATFORM_X86&#125;.tar.gz $&#123;PLATFORM_X86&#125;cp $&#123;PLATFORM_X86&#125;.tar.gz $&#123;ORIN_IMAGE_CONTEXT&#125;/sysrootecho &quot;=== prepare cyber-kit files for x86 done ===&quot;echo &quot;=== prepare cyber-kit files for ORIN ... ===&quot;# 压缩已有的 orin 版本的系统库，并拷贝到上下文中cd $&#123;TOP_DIR&#125;/sysroottar czf $&#123;PLATFORM_ORIN&#125;.tar.gz $&#123;PLATFORM_ORIN&#125;mv $&#123;PLATFORM_ORIN&#125;.tar.gz $&#123;ORIN_IMAGE_CONTEXT&#125;/sysroot# 拷贝交叉编译工具链cp -r $&#123;TOP_DIR&#125;/&#123;cmake,scripts&#125; $&#123;ORIN_IMAGE_CONTEXT&#125;cp -r $&#123;TOP_DIR&#125;/toolchains/$&#123;PLATFORM_ORIN&#125; $&#123;ORIN_IMAGE_CONTEXT&#125;/toolchainsecho &quot;=== prepare cyber-kit files for ORIN done ===&quot;# 删除压缩包cd $&#123;TOP_DIR&#125;/sysrootrm *.gzecho &quot;=== build platform orin docker images ... ===&quot;# 基于dockerfile文件创建镜像docker build --network=host \\    --build-arg platform=$&#123;PLATFORM_ORIN&#125; \\    --build-arg plat_version_value=$&#123;IMAGE_TAG&#125; \\    # 同时打两个标签（版本号和latest）    -t $&#123;ORIN_IMAGE_REPO&#125;:$&#123;IMAGE_TAG&#125; -t $&#123;ORIN_IMAGE_REPO&#125;:latest \\    -f $DOCKERFILE_ORIN_XCYBER $ORIN_IMAGE_CONTEXTecho &quot;=== build platform orin docker images done ===&quot;# 创建镜像成功，删除上下文rm -rf $ORIN_IMAGE_CONTEXT\n 创建Dockerfile.orin.xcyber\n操作的内容都是在上下文里面。\nFROM ubuntu:20.04# 传入参数ARG platformARG plat_version_valueARG DEBIAN_FRONTEND=noninteractiveUSER root # 以下指令使用root权限# stage 1: install dev and debug tools# 安装必备的基础工具，根据实际需求需要RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends build-essential cmake \\    pkg-config flex bison autoconf m4 gdb sudo file ca-certificates lsb-release git vim \\    bash-completion &amp;&amp; update-ca-certificates &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libpng-dev libjpeg-dev \\    libopenblas-dev libeigen3-dev libtbb-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libavcodec-dev \\    libavformat-dev libswscale-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgstreamer1.0-dev \\    libgstreamer-plugins-base1.0-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgtk-3-0 librsvg2-2 libgvc6 \\    openscenegraph &amp;&amp; apt-get clean## Set a passwordless sudoer user# 创建一个无密码用户RUN adduser --disabled-password --gecos &quot;&quot; autometa &amp;&amp; usermod -aG sudo autometa &amp;&amp; \\    mkdir -p /etc/sudoers.d &amp;&amp; touch /etc/sudoers.d/nopasswd &amp;&amp; \\    echo &quot;autometa ALL=(ALL) NOPASSWD: ALL&quot; &gt; /etc/sudoers.d/nopasswd# fix LANG for displaying Chinese textRUN echo &quot;export LANG=C.UTF-8&quot; &gt;&gt; $&#123;HOME&#125;/.bashrc# stage 2: add cyber-kitRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;mkdir -p /opt/cyber-kit/&#123;cmake,scripts,sysroot,toolchains&#125;&quot;]# 拷贝目标平台的工具链COPY toolchains /opt/cyber-kit/toolchains# 这里其实只拷贝 x86 的系统库ADD sysroot/$&#123;x86&#125;.tar.gz /opt/cyber-kit/sysrootADD sysroot/$&#123;platform&#125;.tar.gz /opt/cyber-kit/sysroot# setup toolchains# 拷贝工具链环境配置脚本，并执行，这里使用root权限COPY scripts/setup.sh /opt/cyber-kit/scripts# 主要就是配置环境变量，及解压目标平台的交叉编译工具链RUN /opt/cyber-kit/scripts/setup.sh# update cmake files &amp; scriptsCOPY cmake /opt/cyber-kit/cmakeCOPY scripts /opt/cyber-kit/scripts# setup env for user autometaUSER autometa# 使用用户权限，再执行一遍工具链环境配置脚本RUN /opt/cyber-kit/scripts/setup.sh# git config settings# 配置git命令简写RUN git config --global alias.ci commit &amp;&amp; \\    git config --global alias.co checkout &amp;&amp; \\    git config --global alias.br branch &amp;&amp; \\    git config --global alias.st status &amp;&amp; \\    git config --global alias.au add -u &amp;&amp; \\    git config --global alias.ca commit --amend &amp;&amp; \\    git config --global core.editor vim# set plat versionENV PLAT_VERSION &quot;$&#123;plat_version_value&#125;&quot;# docker start command or argsCMD [&quot;bash&quot;]\n\n\n由于拉取基础镜像要联网，有时不好拉取，所以可以把基础镜像先保存起来：\n  docker save -o ubuntu-20.04-base.tar ubuntu:20.04\n\n\n载入镜像\n  docker load -i ubuntu-20.04-base.tar\n\n\n 创建环境配置脚本setup.sh\n#!/usr/bin/env bashplatform_array=(all xavier rk356x orin cv22)usage()&#123;cat &lt;&lt; EOFUsage: $1 &lt;platform&gt;platform: [$&#123;platform_array[*]&#125;]EOF&#125;platform=$&#123;1:-&quot;all&quot;&#125;echo &quot;platform: $platform&quot;platform_valid=falsefor target in $&#123;platform_array[@]&#125;do    if [ x$target = x$platform ]; then        platform_valid=true    fidoneif ! $&#123;platform_valid&#125;; then    echo &quot;platform is not valid&quot;    usage $&#123;BASH_SOURCE[0]&#125;        if [ $0 = $&#123;BASH_SOURCE[0]&#125; ]; then        exit -1    else        return -1    fifiKIT_PATH=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;/ORIGIN_KIT_PATH=$CYBER_KIT_PATHecho &quot;New cyber kit path is : $&#123;KIT_PATH&#125;&quot;echo &quot;Origin cyber kit path is : $&#123;ORIGIN_KIT_PATH&#125;&quot;HOST_ARCH=$(arch)if [[ $&#123;KIT_PATH&#125; != $&#123;ORIGIN_KIT_PATH&#125; ]]; then    echo &quot;*** The Cyber Kit Path is not set or changed!, Now setting...&quot;    BASH_RC=$&#123;HOME&#125;/.bashrc    touch $BASH_RC    sed -i &#x27;/CYBER_KIT_PATH/d&#x27; $&#123;BASH_RC&#125;    echo &quot;export CYBER_KIT_PATH=$&#123;KIT_PATH&#125;&quot; &gt;&gt; $BASH_RC    if [ $&#123;HOST_ARCH&#125; = &quot;x86&quot; ]; then        echo &#x27;export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/bin&#x27; &gt;&gt; $BASH_RC        echo &#x27;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib&#x27; &gt;&gt; $BASH_RC        if [ $platform = &quot;orin&quot; ]; then            echo &#x27;export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/orin/bin&#x27; &gt;&gt; $BASH_RC            echo &#x27;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/orin/lib&#x27; &gt;&gt; $BASH_RC        fi    fi    source $BASH_RC    echo &quot;*** The Poseidon Kit Path env setting done&quot;fi# unpack and install different platform cross toolchains# check whether the tar file need to be unpackif [ $&#123;HOST_ARCH&#125; = &quot;aarch64&quot; ]; then    echo &quot;The host arch is : $&#123;HOST_ARCH&#125;, do not need to unpack cross compile toolchains.&quot;        if [ $0 = $&#123;BASH_SOURCE[0]&#125; ]; then        exit 0    else        return 0    fifiecho &quot;The host arch is : $&#123;HOST_ARCH&#125;, need to unpack cross compile toolchains.&quot;# orinORIN_GCC_NAME=aarch64--glibc--stable-finalORIN_TOOLCHAIN_FILE=$&#123;KIT_PATH&#125;/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;.tar.gzif [ -f $ORIN_TOOLCHAIN_FILE ] &amp;&amp; [[ $platform = &quot;all&quot; || $platform = &quot;orin&quot; ]]; then    if [ ! -d  /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125; ]; then        echo -e &quot;\\e[33m############### orin: unpack ###############\\e[0m&quot;        sudo mkdir -p /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;        sudo tar -xvf $ORIN_TOOLCHAIN_FILE -C /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;        echo -e &quot;\\e[33m############### orin: unpack done ###############\\e[0m&quot;    else        echo &quot;The orin platform cross compile toolchains is already exists.&quot;    fifi\n整个流程里首次配置环境变量 CYBER_KIT_PATH。\n# docker 容器里 $&#123;HOME&#125;/.bashrcexport CYBER_KIT_PATH=/opt/cyber-kit/export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/binexport LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib\n （交叉）编译依赖库\n创建build_thirdparty.sh用于编译所需依赖库。\n# 编译安装指定版本的依赖库bash build_thirdparty.sh x86bash build_thirdparty.sh orin\n#!/usr/bin/env bashset -o errexit# 这里是这两个依赖库为例GLOG_SOURCE=glog-0.4.0NLOHMANN_JSON_SOURCE=json-3.12.0target_array=(x86 rk356x orin)BUILD_TARGET=x86if [ $# -gt 0 ]; then    BUILD_TARGET=$1else    echo -e &quot;\\e[33m* target arch not given ($&#123;target_array[*]&#125;), use x86 as default!\\e[0m&quot;fitarget_valid=falsefor target in $&#123;target_array[@]&#125;do    if [ x$&#123;BUILD_TARGET&#125; = x$target ]; then        target_valid=true    fidoneif ! $&#123;target_valid&#125;; then    echo -e &quot;\\e[33m* target arch should be in ($&#123;target_array[*]&#125;)\\e[0m&quot;    exit -1fiecho &quot;* BUILD_TARGET=$&#123;BUILD_TARGET&#125;&quot;# 1 setup toolchainecho -e &quot;\\e[33m=== setup toolchain ===\\e[0m&quot;if $&#123;BUILD_TARGET&#125; = &quot;orin&quot; ]; then    COMPILER_PATH=/opt/toolchains/orin/aarch64--glibc--stable-final/bin    TARGET_HOST=aarch64-buildroot-linux-gnu    COMPILER_PREFIX=aarch64-linux-fiexport PATH=$&#123;COMPILER_PATH&#125;:$&#123;PATH&#125;export CROSS_COMPILE=$&#123;COMPILER_PREFIX&#125;# 2 build packagesecho -e &quot;\\e[33m=== build packages ===\\e[0m&quot;TOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;## 指定安装目录和目标平台的cmake文件export CYBER_KIT_PATH=/opt/cyber-kit/INSTALL_PREFIX=$&#123;CYBER_KIT_PATH&#125;sysroot/$BUILD_TARGETTOOLCHAIN_FILE=$&#123;CYBER_KIT_PATH&#125;cmake/sysroot/$&#123;BUILD_TARGET&#125;.cmakeexport PKG_CONFIG_PATH=$&#123;INSTALL_PREFIX&#125;/share/pkgconfig:$&#123;INSTALL_PREFIX&#125;/lib/pkgconfigTHIRDPARTY_DIR=$&#123;TOP_DIR&#125;/thirdpartyPROGRESS_FILE=$&#123;THIRDPARTY_DIR&#125;/build-log.conftouch $PROGRESS_FILEcd $THIRDPARTY_DIR## glogif [[ $(cat $&#123;PROGRESS_FILE&#125; | grep $&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125;) ]]; then    echo &quot;$&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125; already build&quot;else    rm -rf $GLOG_SOURCE    tar xf tarball/$&#123;GLOG_SOURCE&#125;.tar.gz &amp;&amp; cd $GLOG_SOURCE    mkdir -p build-$&#123;BUILD_TARGET&#125; &amp;&amp; cd build-$&#123;BUILD_TARGET&#125;        # 使用新的 C++11 ABI（默认 GCC 5+ 的行为）    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\    -DCMAKE_POSITION_INDEPENDENT_CODE=ON \\    -DBUILD_SHARED_LIBS=ON \\    -DCMAKE_CXX_FLAGS=-D_GLIBCXX_USE_CXX11_ABI=1 \\    -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; ..    make -j$(nproc) install &amp;&amp; echo $&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125; &gt;&gt; $PROGRESS_FILE        cd ../..fi## nlohmann jsonif [[ $(cat $&#123;PROGRESS_FILE&#125; | grep $&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125;) ]]; then    echo &quot;$&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125; already build&quot;else    rm -rf $NLOHMANN_JSON_SOURCE    tar xf tarball/$&#123;NLOHMANN_JSON_SOURCE&#125;.tar.gz &amp;&amp; cd $NLOHMANN_JSON_SOURCE    mkdir -p build-$&#123;BUILD_TARGET&#125; &amp;&amp; cd build-$&#123;BUILD_TARGET&#125;        # 使用新的 C++11 ABI（默认 GCC 5+ 的行为）    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\    -DBUILD_SHARED_LIBS=ON \\    -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; ..    make -j$(nproc) install &amp;&amp; echo $&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125; &gt;&gt; $PROGRESS_FILE        cd ../..firm -rf $GLOG_SOURCErm -rf $NLOHMANN_JSON_SOURCEecho &quot;all done !&quot;\n orin.cmake文件分析\n交叉编译使用到该脚本，主要用于指定编译器以及编译根目录。\nif(NOT DEFINED ENV&#123;CYBER_KIT_PATH&#125;)    message(FATAL_ERROR &quot;Environment \\&quot;CYBER_KIT_PATH\\&quot; not set!&quot;)endif()set(TARGET_ARCH aarch64)set(TARGET_PLATFORM orin)set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR aarch64)set(HOST_PROCESSOR $&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125;)set(TOOLCHAIN_ROOT /usr)if($&#123;HOST_PROCESSOR&#125; STREQUAL &quot;x86_64&quot;)    set(TOOLCHAIN_ROOT /opt/toolchains/orin/aarch64--glibc--stable-final)    set(CROSS_COMPILE aarch64-linux-)endif()set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_ROOT&#125;/bin/$&#123;CROSS_COMPILE&#125;gcc)set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_ROOT&#125;/bin/$&#123;CROSS_COMPILE&#125;g++)set(CMAKE_FIND_ROOT_PATH $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin)if($&#123;HOST_PROCESSOR&#125; STREQUAL &quot;x86_64&quot;)    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)else()    set(CMAKE_SYSROOT /)    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)endif()set(CYBER_SYSROOT_LIB_DIR $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin/lib)set(CYBER_SYSROOT_INCLUDE_DIR $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin/include)\n 重新保存镜像\ndocker commit d063a8a6bdd5 i-nog/nog-cyber-kit/plat_orin_dev:v1.1.0\n工作区的改动会被保存进新镜像，前提是这些改动是在容器的文件系统内进行的。\n\n\n✅ 情况 1：改动在容器内部\n如果你在容器中运行了如下操作：\n  cd /workspaceapt install ...touch somefile.txtpip install ...\n然后执行：\n  docker commit &lt;容器名&gt; &lt;镜像名&gt;\n这些文件、安装的软件、代码改动 都会被保存进新镜像 ✅。\n\n\n❌ 情况 2：挂载的目录（如-v $&#123;WORK_DIR&#125;:/workspace）\n如果启动容器时使用了：\n  -v $&#123;WORK_DIR&#125;:/workspace\n则：\n\n/workspace实际是宿主机的目录；\n改动发生在宿主机，不属于容器文件系统；\ndocker commit不会保存这些改动 ❌。\n\n\n\n📌 举例说明\n\n有挂载：  docker run -v /home/lxp/code:/workspace ...\n你在容器内/workspace修改的所有内容，其实是修改的宿主机/home/lxp/code，不属于容器，docker commit不会打包它。\n无挂载（纯容器内）：  docker run ...# 没有 -v /workspace\n创建或修改/workspace的文件，commit后会保存在镜像里。\n\n","categories":["CyberRT中间件"]},{"title":"CyberRT自定义部署流程 之 部署cyber Cmake工程","url":"/2025/07/11/CyberRT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E4%B9%8B%E9%83%A8%E7%BD%B2cyber%20Cmake%E5%B7%A5%E7%A8%8B/","content":"CyberRT编译原本是基于Bazel，但入行以来都是基于Cmake搭建编译工程，所以更习惯用Cmake搭建工程。\nCmake工程搭建可以参考Baidu Apollo CyberRT Framework CMake Build。不过个人项目操作逻辑不一致，所以对其进行了魔改。\n\n CyberRT工程创建\n将CyberRT源码拷贝到自定义目录下，比如nog-cyber-kit。\n 进入构建好的镜像\n在工程目录下创建进入镜像脚本enter_docker.sh，脚本如下：\n#!/bin/bashplatform_array=(rk356x orin orin_cuda all all_cuda)usage()&#123;cat &lt;&lt; EOFUsage: $1 &lt;platform&gt; [docker_image_tag]platform: [$&#123;platform_array[*]&#125;]docker_image_tag: default is latestEOF&#125;log_highlight()&#123;    echo -e &quot;\\e[30;31m&quot;$1&quot;$(tput sgr0)&quot;&#125;if [[ $# -lt 1 || $1 == &quot;-h&quot; || $1 == &quot;--help&quot; ]]; then    usage $0    exit 0fiplatform=$&#123;1-&quot;xavier&quot;&#125;echo &quot;platform: $platform&quot;platform_valid=falsefor target in $&#123;platform_array[@]&#125;do    if [ x$platform = x$target ]; then        platform_valid=true    fidoneif ! $&#123;platform_valid&#125;; then    echo &quot;platform is not valid&quot;    usage $0    exit -1fi# sudo apt install x11-xserver-utilsxhost +docker_image_tag=$&#123;2-&quot;latest&quot;&#125;docker_image_repo=&quot;i-nog/nog-cyber-kit/plat_$&#123;platform&#125;_dev&quot;machine_name=plat-$&#123;platform&#125;-$&#123;docker_image_tag&#125;machine_id=`docker ps -a -q -f name=$&#123;machine_name&#125;`if [[ $&#123;machine_id&#125; != &#x27;&#x27; ]]; then    log_highlight &quot;Enter docker: $&#123;machine_name&#125;/$&#123;machine_id&#125; ...&quot;    docker start $&#123;machine_id&#125;    docker exec -it $&#123;machine_id&#125; /bin/bashelse    WORK_DIR=$PWD    docker_image_url=$&#123;docker_image_repo&#125;:$&#123;docker_image_tag&#125;    log_highlight &quot;Run docker from $&#123;docker_image_url&#125;&quot;    docker run  -it --privileged \\      --name $&#123;machine_name&#125; --net=host -v /dev:/dev \\      -v $&#123;WORK_DIR&#125;:/workspace -w /workspace \\      -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY \\      -v /media:/media \\      --gpus all \\      $&#123;docker_image_url&#125;fi\nbash enter_docker.sh orin v1.1.0进入容器。\n 顶层CMakeLists.txt\n根据自己项目修改：\ncmake_minimum_required(VERSION 3.5.1)project(cyber VERSION 9.0.0)set(TARGET_NAME $&#123;PROJECT_NAME&#125;)include(&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../cmake/nog.cmake&quot;)if(NOT CMAKE_BUILD_TYPE)  set(CMAKE_BUILD_TYPE Debug)endif()enable_language(ASM)# Use ccache if availablefind_program(CCACHE_FOUND ccache)if(CCACHE_FOUND)  message(STATUS &quot;### use ccache&quot;)  set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)  set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)endif()# PIC flagsset(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fPIC&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fPIC&quot;)# Architecture-specific assembly fileif(CMAKE_SYSTEM_PROCESSOR STREQUAL &quot;x86_64&quot;)  set(CROUTINE_FILE &quot;cyber/croutine/detail/swap_x86_64.S&quot;)else()  set(CROUTINE_FILE &quot;cyber/croutine/detail/swap_aarch64.S&quot;)endif()message(&quot;### SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125; $&#123;CROUTINE_FILE&#125;&quot;)set(CYBER_PYTHON_PATH &quot;lib/python$&#123;Python_VERSION&#125;/site-packages/cyber/python&quot;)set(CYBER_PYTHON_INTERNAL_PATH &quot;$&#123;CYBER_PYTHON_PATH&#125;/internal&quot;)set(CYBER_PYTHON_PROTOBUF_PATH &quot;lib/python$&#123;Python_VERSION&#125;/site-packages/cyber/proto&quot;)# Add include directoriesinclude_directories(  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;  $&#123;CMAKE_BINARY_DIR&#125;)file(GLOB CYBER_PROTO_FILES  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/proto/*.proto&quot;  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/examples/proto/*.proto&quot;)# Only generate proto files onceset(CYBER_MSGS_CACHE ON CACHE BOOL &quot;generate cyber proto msgs flag.&quot; FORCE)if(CYBER_MSGS_CACHE)  message(STATUS &quot;Generating proto files...&quot;)  foreach(FIL $&#123;CYBER_PROTO_FILES&#125;)    message(&quot;### generate proto file: $&#123;FIL&#125;&quot;)    execute_process(      COMMAND $&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;      -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;      --cpp_out=$&#123;CMAKE_BINARY_DIR&#125;      --python_out=$&#123;CMAKE_BINARY_DIR&#125;      $&#123;FIL&#125;    )  endforeach()  # Avoid regenerating in subsequent runs  set(CYBER_MSGS_CACHE OFF CACHE BOOL &quot;generate cyber proto msgs flag.&quot; FORCE)endif()file(GLOB CYBER_PROTO_SRCS  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/*.pb.cc&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/*.pb.h&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/*.pb.cc&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/*.pb.h&quot;)file(GLOB CYBER_SRCS  &quot;cyber/base/*.cc&quot;  &quot;cyber/blocker/*.cc&quot;  &quot;cyber/class_loader/*.cc&quot;  &quot;cyber/class_loader/*/*.cc&quot;  &quot;cyber/common/*.cc&quot;  &quot;cyber/component/*.cc&quot;  &quot;cyber/croutine/*.cc&quot;  &quot;cyber/croutine/*/*.cc&quot;  &quot;cyber/data/*.cc&quot;  &quot;cyber/event/*.cc&quot;  &quot;cyber/io/*.cc&quot;  &quot;cyber/logger/*.cc&quot;  &quot;cyber/message/*.cc&quot;  &quot;cyber/node/*.cc&quot;  &quot;cyber/parameter/*.cc&quot;  &quot;cyber/plugin_manager/*.cc&quot;  &quot;cyber/record/*.cc&quot;  &quot;cyber/record/*/*.cc&quot;  &quot;cyber/scheduler/*.cc&quot;  &quot;cyber/scheduler/*/*.cc&quot;  &quot;cyber/service/*.cc&quot;  &quot;cyber/service_discovery/*.cc&quot;  &quot;cyber/service_discovery/*/*.cc&quot;  &quot;cyber/task/*.cc&quot;  &quot;cyber/time/*.cc&quot;  &quot;cyber/timer/*.cc&quot;  &quot;cyber/transport/*.cc&quot;  &quot;cyber/transport/*/*.cc&quot;  &quot;cyber/*.cc&quot;  &quot;cyber/sysmo/*.cc&quot;  $&#123;CROUTINE_FILE&#125;)# Exclude test files robustlylist(FILTER CYBER_SRCS EXCLUDE REGEX &quot;.*test[.]cc&quot;)list(FILTER CYBER_SRCS EXCLUDE REGEX &quot;.*/cyber/class_loader/test/.*&quot;)list(REMOVE_ITEM CYBER_SRCS &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/class_loader/shared_library/sample.cc&quot;)add_library($&#123;TARGET_NAME&#125; SHARED  $&#123;CYBER_PROTO_SRCS&#125;  $&#123;CYBER_SRCS&#125;)target_link_libraries($&#123;TARGET_NAME&#125;  fastcdr   fastrtps  $&#123;Protobuf_LIBRARIES&#125;  z  glog  atomic  dl  rt  pthread  gflags  tinyxml2  uuid)add_subdirectory(cyber/mainboard)add_subdirectory(cyber/examples)add_subdirectory(cyber/tools)add_subdirectory(cyber/python)install(DIRECTORY cyber/  DESTINATION include/cyber/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/  DESTINATION include/cyber/proto/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/  DESTINATION include/cyber/examples/proto/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY cyber/conf/ DESTINATION share/conf/)configure_file(&quot;setup.bash.in&quot; &quot;$&#123;CMAKE_BINARY_DIR&#125;/setup.bash&quot; @ONLY)install(FILES $&#123;CMAKE_BINARY_DIR&#125;/setup.bash DESTINATION .)install(DIRECTORY cyber/python/  DESTINATION $&#123;CYBER_PYTHON_PATH&#125;  FILES_MATCHING PATTERN &quot;*.py&quot;)file(WRITE $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;/__init__.py   &quot;import os\\nimport sys\\nsys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))\\n&quot;)file(COPY $&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/  DESTINATION $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;  FILES_MATCHING PATTERN &quot;*.py&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;/  DESTINATION $&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;)install(TARGETS $&#123;TARGET_NAME&#125;  EXPORT $&#123;TARGET_NAME&#125;-targets  ARCHIVE DESTINATION lib  LIBRARY DESTINATION lib  RUNTIME DESTINATION bin)\n 构建编译脚本build.sh\nbash build.sh -t x86 -i -r\n#!/usr/bin/env bashset -eTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;0&#125;&quot;)&quot; &amp;&amp; pwd -P)&quot;# script usageusage()&#123;    echo &quot;Usage: $&#123;0&#125; [-t &lt;x86|xavier|rk356x&gt;] [-r (cmake reconfig)] [-i (install)] [-d (Debug)]&quot; 1&gt;&amp;2;    exit 0;&#125;# default settings: target architecture, build type, if reconfig, if installTARGET_ARCH=&quot;x86&quot;BUILD_TYPE=&quot;Release&quot;RECONFIG=falseMAKE_INSTALL=false# parse command line argswhile getopts &#x27;t:rid&#x27; OPTION; do    case &quot;$OPTION&quot; in        t)            TARGET_ARCH=&quot;$&#123;OPTARG&#125;&quot;            ;;        r)            RECONFIG=true            ;;        i)            MAKE_INSTALL=true            ;;        d)            BUILD_TYPE=&quot;Debug&quot;            ;;        *)            usage            ;;    esacdoneshift &quot;$(($&#123;OPTIND&#125; - 1))&quot; # delete option argsecho &quot;* build taget arch: $&#123;TARGET_ARCH&#125;&quot;echo &quot;* build type: $&#123;BUILD_TYPE&#125;&quot;# check if the environment variable POSEIDON_KIT_PATH existsif [ ! -v CYBER_KIT_PATH ]; then    echo -e &quot;\\e[31m[ERROR]The environment variable CYBER_KIT_PATH was not set, please &quot;\\            &quot;run &#x27;source &lt;path/to/dvpn-cyber-kit&gt;/scripts/setup.sh&#x27; first!\\e[0m&quot;    exit 1fiecho &quot;CYBER_KIT_PATH=$&#123;CYBER_KIT_PATH&#125;&quot;export PATH=$&#123;CYBER_KIT_PATH&#125;sysroot/x86/bin:$PATHexport LD_LIBRARY_PATH=$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib:$LD_LIBRARY_PATHPROJECT_DIR=$&#123;TOP_DIR&#125;export OUTPUT_DIR=$&#123;TOP_DIR&#125;/../output/$&#123;TARGET_ARCH&#125;INSTALL_PREFIX=$&#123;OUTPUT_DIR&#125;/cyberBUILD_DIR=$&#123;TOP_DIR&#125;/../build/$&#123;TARGET_ARCH&#125;/cyberTOOLCHAIN_FILE=$&#123;CYBER_KIT_PATH&#125;cmake/sysroot/$&#123;TARGET_ARCH&#125;.cmake# if reconfig delete the build cache filesif $&#123;RECONFIG&#125;; then    rm -rf $&#123;BUILD_DIR&#125;/*fimkdir -pv $&#123;BUILD_DIR&#125; &amp;&amp; cd $&#123;BUILD_DIR&#125;if [ ! -f &quot;CMakeCache.txt&quot; ] || [ ! -f &quot;Makefile&quot; ]; then    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\          -DCMAKE_BUILD_TYPE=$&#123;BUILD_TYPE&#125; \\          -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; \\          $&#123;PROJECT_DIR&#125;fimake -j$(nproc)# installif $&#123;MAKE_INSTALL&#125;; then    make installfi","categories":["CyberRT中间件"]},{"title":"Latex数学公式测试","url":"/2025/07/03/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95/","content":"测试博客 markdown 相关语法书写。\n\n 列表\n\n文本：\n\n[ ] 你好[x] 你好\n\n效果：\n\n你好\n你好\n 行内公式\n\n文本：\n\n$E = mc^2$\n\n效果：E=mc2E = mc^2E=mc2\n\n 块级公式\n\n文本：\n\n$$i\\hbar \\frac&#123;\\partial \\psi&#125;&#123;\\partial t&#125; = -\\frac&#123;\\hbar^2&#125;&#123;2m&#125; \\nabla^2 \\psi + V \\psi$$\n\n效果：\n\niℏ∂ψ∂t=−ℏ22m∇2ψ+Vψi\\hbar \\frac{\\partial \\psi}{\\partial t} = -\\frac{\\hbar^2}{2m} \\nabla^2 \\psi + V \\psi\niℏ∂t∂ψ​=−2mℏ2​∇2ψ+Vψ\n 字体颜色\n\n文本：\n\n1. ==高亮文本==2. &lt;span style=&quot;color: green;&quot;&gt;绿色文本&lt;/span&gt;3. **&lt;span style=&quot;color: green;&quot;&gt;绿色文本加粗&lt;/span&gt;**4. &lt;code style=&quot;color: green;&quot;&gt;green Codes: abcdef&lt;/code&gt;5. **&lt;code style=&quot;color: green;&quot;&gt;blod green Codes: abcdef&lt;/code&gt;**# 老式写法，需要打开# markdown_it_plus:#    html: true                 # 允许原始 HTML 标签6. &lt;font color=green&gt;文本&lt;/font&gt;7. &lt;font color=red size=5&gt;文本&lt;/font&gt;\n\n效果：\n\n\n高亮文本\n绿色文本\n绿色文本加粗\ngreen Codes: abcdef\nblod green Codes: abcdef\n文本\n文本\n\n 字体大小\n\n文本：\n\n&lt;span style=&quot;font-size: 18px;&quot;&gt;这是 18px 大小的文字&lt;/span&gt;\n\n效果：\n这是 18px 大小的文字\n\n 公式换行\n\n文本：\n\n$$\\begin&#123;aligned&#125;\\theta(s)=\\theta_&#123;start&#125;+s(\\theta_&#123;end&#125;-\\theta_&#123;start&#125;),s\\in[0,1] \\\\s=s(t),t\\in[0,T]\\end&#123;aligned&#125;$$# 带对齐符号$$\\begin&#123;aligned&#125;\\theta(s)&amp;=\\theta_&#123;start&#125;+s(\\theta_&#123;end&#125;-\\theta_&#123;start&#125;),s\\in[0,1] \\\\s&amp;=s(t),t\\in[0,T]\\end&#123;aligned&#125;$$# 不带aligned$$a = b+c \\\\d = e+f$$\n\n效果：\n\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns=s(t),t\\in[0,T]\n\\end{aligned}\nθ(s)=θstart​+s(θend​−θstart​),s∈[0,1]s=s(t),t∈[0,T]​\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)&amp;=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns&amp;=s(t),t\\in[0,T]\n\\end{aligned}\nθ(s)s​=θstart​+s(θend​−θstart​),s∈[0,1]=s(t),t∈[0,T]​\na=b+cd=e+fa = b+c \\\\\nd = e+f\na=b+cd=e+f\n 矩阵\nxT⋅wxI4×4⋅x=(x1x2x3x4)1×4⋅wx(1000010000100001)4×4⋅(x1x2x3x4)4×1=wxx12+wxx22+wxx32+wxx42=wx∑i=14xi2\\begin{aligned}\nx^T\\cdot w_{x}\\textbf{I}_{4\\times4} \\cdot x &amp; =\\begin{pmatrix} x_1 &amp; x_2 &amp; x_3 &amp; x_4 \\end{pmatrix}_{1\\times4} \n\\cdot w_{x}\n\\begin{pmatrix} \n1 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\end{pmatrix}_{4\\times4}\n\\cdot\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1} \\\\\n&amp; = w_{x}x_1^2+w_{x}x_2^2+w_{x}x_3^2+w_{x}x_4^2 \\\\\n&amp; = w_{x} \\sum_{i=1}^{4}x_i^2\n\\end{aligned}\nxT⋅wx​I4×4​⋅x​=(x1​​x2​​x3​​x4​​)1×4​⋅wx​⎝⎜⎜⎜⎛​1000​0100​0010​0001​⎠⎟⎟⎟⎞​4×4​⋅⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​=wx​x12​+wx​x22​+wx​x32​+wx​x42​=wx​i=1∑4​xi2​​\n","categories":["博客搭建"]},{"title":"sysroot目录的作用","url":"/2025/04/14/sysroot%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"在软件开发和交叉编译中，sysroot（System Root）是一个关键概念，它定义了目标系统根目录的路径，帮助开发工具链（如编译器、链接器）在构建过程中正确找到目标平台的头文件、库和其他依赖资源。以下是其核心作用的详细说明：\n\n 1. sysroot 的核心作用\n\n隔离开发环境：\n在交叉编译（例如在 x86 主机上编译 ARM 程序）时，sysroot 会指定目标设备的根文件系统路径，确保编译工具链不会误用宿主机的头文件和库。\n路径重定向：\n当工具链访问标准路径（如 /usr/include、/lib）时，实际会从 sysroot 指定的目录下查找文件（即 sysroot/usr/include、sysroot/lib）。\n\n 2. 典型使用场景\n (1) 交叉编译（Cross-Compilation）\n假设你在 x86_64 主机上编译一个运行在 ARM 嵌入式设备的程序：\n\n目标设备的根文件系统可能存放在主机的 /opt/arm-sysroot 目录下。\n通过指定 --sysroot=/opt/arm-sysroot，编译器会从该目录下查找 ARM 架构的头文件和库，而非宿主机的 x86 资源。\n\n示例命令：\narm-linux-gnueabihf-gcc --sysroot=/opt/arm-sysroot -o myapp myapp.c\n (2) 嵌入式开发\n嵌入式设备的文件系统通常通过工具（如 Buildroot、Yocto）生成，并导出为 sysroot，供开发工具链使用。\n (3) 容器化构建\n在 Docker 容器中构建应用时，sysroot 可指向容器内的根文件系统，避免依赖宿主机环境。\n 3. sysroot 的目录结构\n一个典型的 sysroot 目录结构如下：\n/opt/arm-sysroot├── lib         # 目标系统的库文件（如 libc.so）├── usr│   ├── include # 目标系统的头文件（如 stdio.h）│   └── lib     # 目标系统的其他库└── ...\n 4. 如何配置 sysroot\n (1) 编译器参数\n在编译时通过 --sysroot 指定路径：\ngcc --sysroot=/path/to/sysroot -o output input.c\n (2) 工具链配置\n交叉编译工具链（如 arm-linux-gnueabihf-gcc）通常预置了默认的 sysroot。可通过 -print-sysroot 查看：\narm-linux-gnueabihf-gcc -print-sysroot\n (3) 构建系统配置\n在 CMake 中设置 CMAKE_SYSROOT：\nset(CMAKE_SYSROOT &quot;/opt/arm-sysroot&quot;)\n在 Autotools 中通过 --with-sysroot：\n./configure --with-sysroot=/opt/arm-sysroot\n 5. 常见问题与解决\n (1) 错误：头文件或库找不到\n\n原因：sysroot 路径未正确配置，或目标文件系统中缺失依赖。\n解决：\n\n检查 sysroot 路径是否存在且包含目标系统的 include 和 lib 目录。\n使用 find 命令验证文件是否存在：find /opt/arm-sysroot -name &quot;stdio.h&quot;\n\n\n\n\n (2) 错误：链接到宿主机库\n\n原因：未正确隔离环境，工具链仍使用宿主机默认路径。\n解决：\n\n确保编译命令包含 --sysroot。\n使用 -nostdinc 和 -nostdlib 强制禁用宿主机默认路径。\n\n\n\n 6. 对比 sysroot 与 chroot\n\nsysroot：仅影响编译工具链的路径查找，用于构建阶段。\nchroot：改变进程的根目录视图，用于运行时环境隔离。\n\n 总结\n\nsysroot 是目标系统根目录的镜像，确保编译工具链使用正确的资源。\n在交叉编译、嵌入式开发和容器化构建中必不可少，避免环境污染和兼容性问题。\n配置时需确保目标系统的头文件、库和工具链架构（如 ARM、x86）一致。\n\n","categories":["CyberRT中间件","Linux软件开发"]},{"title":"个人博客网站搭建","url":"/2025/07/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/","content":"Ubuntu18.04 + GitHub + Hexo免费配置个人博客\n\n 必要环境安装\n git\nsudo apt install git\n一般问题不大\n npm\n\nnpm (Node Package Manager)是一个用于JavaScript和Node.js的包管理器。它不仅是Node.js的默认包管理器，还提供了发布和共享代码、管理依赖、版本控制等功能。npm允许开发者从全球的代码库中获取并安装Node.js模块，这些模块可以用于构建应用程序、工具和包等。\n简单来说，npm就像一个巨大的软件仓库，里面存放了各种JavaScript和Node.js的模块（也叫包）。\n\nsudo apt-get install npm\n\nChatGPT建议使用nvm安装Node.js + npm（更干净灵活）。\n Node.js\n不想让系统包干扰，可以用nvm（Node Version Manager）来安装Node.js + npm：\n# 安装 nvmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash# 激活 nvm（或者重启终端）export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;# 安装 Node.js 最新 LTS 版本（或指定版本）nvm install --lts# 检查版本node -vnpm -v\n如果报以下错误：\n\n说明当前系统的GLIBC版本太低，而你安装的Node.js二进制文件依赖于更高版本的GLIBC（2.28）。\n\n🧠 原因分析\nUbuntu 18.04 的默认 glibc 是 2.27。\nNode.js 官方预构建二进制从某个版本开始依赖 glibc &gt;= 2.28（通常从 Node.js 18 或更高版本开始）。\n所以如果在 Ubuntu 18.04 或老系统上安装了较新的 Node.js，就会出这个错。\n\n\n\n彻底删除旧版本Node.js，以防系统中残留了之前的node安装路径或链接。\n执行以下命令清理旧的node/npm：\n sudo apt purge -y nodejs npmsudo rm -rf /usr/local/bin/node /usr/local/bin/npmsudo rm -rf /usr/bin/node /usr/bin/npmsudo rm -rf ~/.npm ~/.nvm ~/.node*hash -r\n\n\n安装 nvm（Node Version Manager）\n # 下载并安装 nvmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash# 加载 nvm（也可以重启终端）export NVM_DIR=&quot;$HOME/.nvm&quot;source &quot;$NVM_DIR/nvm.sh&quot;\n\n\n使用nvm安装Node.js 16\n nvm install 16nvm use 16nvm alias default 16\n\n\n验证：\n node -v      # 应输出 v16.x.xnpm -v       # 应输出 8.x.x\n\n\n\n 🚀 总结\n使用 nvm 方式安装Node.js是：\n\n✅ 最兼容的\n✅ 不依赖系统 glibc\n✅ 不需要 root 权限\n✅ 可随时切换 Node.js 版本\n\n nvm使用\n\n\n查看已安装的Node.js版本\n  nvm ls\n\n\n\n版本切换\n  # 切换使用 Node.js 14nvm use 14# 切回 Node.js 16nvm use 16\n\n\n设置默认版本（打开终端自动使用）\n  # 以后打开终端就会自动使用 Node.js 16。nvm alias default 16\n\n\n如果没有安装目标版本\n  # 先安装再切换：nvm install 14nvm use 14\n\n\n 基于Hexo框架搭建\n\nHexo项目中，源代码（markdown、主题等） 和生成后的网页是分开的\n\n一个仓库存放Hexo源码（如hexo-iNog-blog）（可选）\n一个仓库存放部署页面（如i-nog.github.io）\n\n\n\n\n下载 Hexo\n  npm install hexo-cli -g\n\n安装hexo插件  # 按需选择安装npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --save # 本人只安装这个npm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save\n\n\n\n\n创建框架\n  (base) lxp@lxp-os:~/projects$ mkdir hexo-iNog-blog(base) lxp@lxp-os:~/projects$ cd hexo-iNog-blog/(base) lxp@lxp-os:~/projects/hexo-iNog-blog$ hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesINFO  Start blogging with Hexo!(base) lxp@lxp-os:~/projects/hexo-iNog-blog$ ls_config.landscape.yml  _config.yml  node_modules  package.json  package-lock.json  scaffolds  source  themes\nhexo的文件结构：\n\npublic最终所见网页的所有内容\nnode_modules插件以及hexo所需node.js模块\n_config.yml站点配置文件，设定一些公开信息等\npackage.json应用程序信息，配置hexo运行所需js包\nscaffolds模板文件夹，新建文章，会默认包含对应模板内容\nthemes存放主题文件，hexo根据主题生成静态网页（速度贼快）\nsource用于存放用户资源（除posts文件夹，其余命名方式为 “ + 文件名”的文件被忽略）\n\n注意：hexo-iNog-blog/文件夹无需配置git仓库，除非个人想进行版本管理，方便长期开发。\n\n\n下载自己喜欢的主题\n在Themes查找自己喜欢的主题，比如Keep主题\n  # 在 hexo-iNog-blog/ 下，Keep主题git clone https://github.com/XPoet/hexo-theme-keep themes/keep# 或Fengye主题git clone https://github.com/chen-yingfa/hexo-theme-fengye.git themes/fengye# 或Fluid主题git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid\n\n\n配置主题\n在Hexo配置文件_config.yml中将theme设置为keep。\n\n\n\n自定义主题内容\n需要修改themes/keep/_config.yml文件\n\n\n\n本地预览\n  hexo clean //执行此命令后继续下一条hexo g // 生成博客目录，hexo generate 的缩写hexo s // 本地预览，hexo server 的缩写\n\n\n\n 创建及配置Gitbub Pages\n\n\n创建同用户名仓库，且是公共(Public)仓库\n\nGitHub Pages只支持公共仓库免费部署。如果仓库是私有的：\n\n地址不会生成；\n或者会提示升级为付费账户。\n\n\n\n设置仓库Pages信息\n\n\n\n本地关联github，需配置_config.yml文件中将deploy\n注意，是用户名.github.io那个仓库 。\n\n同时还需要配置git参数，如下：\n git config --global user.name &quot;用户名&quot;git config --global user.email &quot;******@gmail.com&quot;\n注意：是要配置全局的name和email。\n\n\n上传\n # 在自己的博客目录下，比如 hexo-iNog-blog/ 目录下# 清除缓存hexo clean# 生成hexo目录hexo generate# 可以先本地预览hexo server# 部署到远程仓库hexo deploy # 缩写 hexo d，如果失败，需要先安装 npm install hexo-deployer-git --save\ndeploy过程会生成.deploy_git/文件夹（内容同public/目录），自动关联到用户名.github.io仓库，将文件夹的内容推送到该仓库。\n\n\n❌ 不推荐直接把Hexo项目源码上传到.github.io仓库\n因为GitHub Pages无法直接解析source/里的.md文件，它只支持静态HTML页面。\n\n\n 资源压缩\n\n\n在 Hexo 项目根目录下安装 hexo-all-minifier\n cd your-hexonpm install hexo-all-minifier\n\n\n在 Hexo 配置文件 _config.yml 文件中，添加以下配置项\n all_minifier: true\n\n\n注意：Node.js需要升级到 18 或更高版本。\n 图片压缩工具\n网上搜索一大堆推荐，个人使用uTools工具里面的插件TinyJpg，不是通过API，插件自带压缩算法，压缩速度很快，感觉蛮好用，大家觉得好用的话，记得好评给作者一点动力（鞭策下作者这头牛马，继续优化，提高下压缩效率）。\n\n 图片生成\n\n本地部署\nMac本地安装部署Stable diffusion最全教程，AI绘画无痛入门指南\n在线生成\n\nBing Image Creator\n即梦AI\n\n\n\n Latex渲染\n 介绍\nLaTeX公式渲染引擎：\n\nMathJax\nKaTex\n\nmarkdown渲染器：\n\nhexo-renderer-pandoc\nhexo-renderer-markdown-it\nhexo-renderer-markdown-it-plus\n\n 使用\n因为Katex能使用\\\\换行，之前文档块公式都是采用\\\\换行，所以采用katex；\n本人采用markdown_it_plus（自带katex）。\n\n\n安装markdown-it-plus\n  npm i hexo-renderer-markdown-it-plus --save# --save 是 npm 的一个命令参数，用来表示：# 安装这个依赖，并将它写入 package.json 的 dependencies 字段中。# 但注意：从 npm v5（Node 8+）开始，默认就会自动写入 dependenciesnpm install hexo-renderer-markdown-it-plus# 效果是一样的，--save 可写可不写，它只是 早期版本需要显式加上。# 基于 package.json，使用 npm install 可以直接安装全部依赖\nmarkdown_it_plus默认启用的插件：\n\nmarkdown-it-emoji # 支持表情符号\nmarkdown-it-sub # 支持下标\nmarkdown-it-sup # 支持上标\nmarkdown-it-deflist # 支持定义列表\nmarkdown-it-abbr # 支持缩略词\nmarkdown-it-footnote # 支持脚注\nmarkdown-it-ins # 支持插入文本\nmarkdown-it-mark # 支持高亮文本\n@iktakahiro/markdown-it-katex # 公式渲染引擎\nmarkdown-it-toc-and-anchor # 目录\n\n\n\n安装额外插件\n  npm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n\nmarkdown-it-checkbox # 支持复选框\nmarkdown-it-imsize # 自定义图片宽高\nmarkdown-it-expandable # 折叠/展开内容\n\n\n\n# hexo项目的_config.yml文件markdown_it_plus:    highlight: true  # 是否启用代码高亮（内置 Prism.js）    html: true       # 允许原始 HTML 标签（&lt;font&gt;...&lt;/font&gt;）    xhtmlOut: true   # 输出 XHTML 格式标签（如 &lt;br/&gt; 而不是 &lt;br&gt;）    breaks: true     # 自动将换行符转换为 &lt;br&gt;    langPrefix:      # 代码块的语言 class 前缀，例如 language-python    linkify: true    # 自动识别链接并转为 &lt;a&gt;    typographer:     # 使用智能标点（如自动替换 -- 为 —）    quotes: “”‘’     # 引号样式（中英文分别）    plugins:        - plugin:            name: markdown-it-mark            enable: false # 关闭        - plugin:            name: markdown-it-checkbox            enable: true # 开启\n 双重渲染问题\n\n在使用 hexo-renderer-markdown-it-plus 时，它通常会生成如下结构：\n&lt;span class=&quot;katex&quot;&gt;  &lt;span class=&quot;katex-mathml&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;...&lt;/span&gt; &lt;!-- 这个是你要隐藏的 --&gt;&lt;/span&gt;\n\n其中：\n\nkatex-mathml 是给屏幕阅读器（辅助功能）用的。\nkatex-html 是用来实际显示公式的。\n有时 Keep 主题或 MathJax 会再渲染一次，导致重复。\n\n解决方式：\n使用 可注入的 CSS 样式 来隐藏 katex-html 元素，避免公式重复显示。\n\n\nkeep主题配置\n  # _config.keep.ymlinject:  enable: true  # Option values: true | false  css:\t- /css/custom-1.css\t# e.g.\t# - /css/custom-1.css\t# - /css/custom-2.css\t# - ...  js:\t-\t# e.g.\t# - /js/custom-1.js\t# - /js/custom-2.js\t# - ...\n\n\n增加source/css/custom-1.css文件\n  .katex-html &#123;\tdisplay: none !important;&#125;\n\n\n 评论系统搭建\n\ngiscus\n\n目前 Keep 主题支持该插件，所以本人直接使用该插件，按照说明配置就行；主要就是创建一个 public 的仓库，然后安装 giscus app，在打开 Discussions 功能；\nKeep 主题暴露了 Giscus 评论插件五个配置项：repo、repo_id、category、category_id、reactions_enabled，根据生成的配置项填写就行\n\n\n\nutterances\n\n与上者类似，目前 Keep 主题不支持，所以没深入研究。\n\n\n\n两者都会生成&lt;script src=...&lt;/script&gt;，在哪个位置添加该标签，评论就出现在哪个位置。\n 与JopLin笔记本配合（无很好适配）\nJoplin Publisher插件教程\n\n配置仓库的读写权限\n\n\n\n结果：\n\n\n 参考文献\nKeep 主题使用手册\nUbuntu20.04 +GitHub+Hexo 0基础0成本免费配置个人博客\n快速搭建个人博客 —— 保姆级教程\n","categories":["博客搭建"]},{"title":"分段加加速度路径规划OSQP仿真参数分析","url":"/2022/04/01/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92OSQP%E4%BB%BF%E7%9C%9F%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","content":" 分段加加速度路径规划OSQP仿真参数分析\n在自动驾驶横向路径规划中，分段加加速度模型（最小 jerk）常用于生成平滑轨迹，并以 OSQP 作为优化求解器。本文通过系统性仿真实验，分析路径规划中各种参数对轨迹形状与可行性的影响，并总结出一套实用的参数调试指南。\n\n\n\n参数名\n默认值\n建议范围\n说明\n\n\n\n\nl_weight\n1.0\n[10, 33]\n越大越贴中心线，过大不自然\n\n\ndl_weight\nmax(5.0, 初始dl²)\n[0, 10000]\n越大越直，对结果影响小\n\n\nddl_weight\n1000.0\n任意\n影响极小\n\n\ndddl_weight\n50000.0\n[50000, 500000]\n控制曲线“硬直”程度\n\n\nx_ref_weight\n10.0\n[10, 30]\n越大越接近目标线，但存在跳变\n\n\nend_state_weight_l\n1000.0\n[1000, 10000]\n控制终点位置贴合度\n\n\nend_state_weight_dl/ddl\n0.0\n任意\n基本无影响\n\n\n\n跳变提示：\n\n多个权重参数（如 l_weight、x_ref_weight）在某些区间会出现“跳变点”，即微小调整导致轨迹急剧变化，建议避开。\nx_ref_weight 在 [8.8, 9.0] 存在跳变，l_weight 在 [9, 10]、[33, 34]、[43, 44] 存在跳变。\n\n\n 默认参数\n采用单一变量原则：只改变其中一个值，其余不变。\n# state (l, dl, ddl) : tuplefirst_state = (3.0, 0., 0.)last_state = (3.5, 0., 0.)# weight (l, dl, ddl) : tupleend_state_weight = (1000.0, 0.0, 0.0)weight_x_ref = 10.0# weights &#123;l_weight, dl_weight, ddl_weight, dddl_weight, 0.0&#125;weights = np.array([1.0, max(5.0, first_state[1] * first_state[1]), 1000.0, 50000.0, 0.0])# scale_factors (l_scale_factor, dl_scale_factor, ddl_scale_factor) : tuplescale_factors = (1.0, 10.0, 100.0)default_lateral_derivative_bound = 2.0default_lateral_jerk_bound = 4.0\n 边界约束条件分析\n l_bounds根据障碍物道路构造边界\n就是障碍物边界，硬约束，需要注意的是起点一定要在约束条件以内，不然会导致计算失败(primal infeasible)；终点不一定，即终点可以在边界之外。\n# end_state (l, dl, ddl) : tuple\n\n0是个需要额外注意的情况，曲线是独特的。\n dl_bounds默认值为2.0，对曲线影响不大\n理解成横向速度。\n\n默认情况下，计算得到的dl在(−0.3,0.2)(-0.3,0.2)(−0.3,0.2)之间。\n设置default_lateral_derivative_bound太小就会导致计算失败(primal infeasible)。\n如下设置为0.19，发现会与边界相交。\n\n\n只要满足规划需求，对结果影响不大。\n ddl_bounds根据车辆性能与参考线曲率设定\n理解成车辆的转弯曲率边界，以自卸车为例，最大转弯曲率为0.1左右。体现为，计算结果的曲线能转弯的能力。\n\n值越小，拐弯能力越不行，绕障时就需要大幅度的摆动。\n\n\n dddl_bound对曲线影响不大，默认值为4.0\n\n\n对曲线影响不大。只要不为零，就不会导致计算失败(primal infeasible)。\n\ndl,ddl的上下限约束必须包括零点，即下限必须小于零，上限必须大于零，否则会造成primal infeasible求解失败。\n weights参数分析\nweights &#123;l_weight, dl_weight, ddl_weight, dddl_weight, 0.0&#125;\n无x_reference情况下：\n weight_l默认值1.0，建议区间[10,33][10,33][10,33]\n\nl_weight比重越大，越贴近中心线，整体感觉就是晚点绕障，提早回中心线，曲线越柔软；值在[0, 1.0]效果差不多；\n比重为1000已经使得曲线基本贴着边界，不可取；\n\n比重为[1,9][1,9][1,9]曲线差不多，也就是[0,9.0][0,9.0][0,9.0]，影响不大。在[9,10][9,10][9,10]存在一个跳变值，同end_state_weight_l。\n\n\n可见比重在50之后，变化不大，所以调试参数可定在[10,33][10,33][10,33]。\n\n\n比重在[33,34][33,34][33,34]之间存在跳变。\n\n比重在[34,43][34,43][34,43]之间对曲线影响不大。\n\n比重在[43,44][43,44][43,44]之间存在跳变。\n weight_dl默认值为5与初始dl平方最大值，对曲线其实影响不大\n\n\ndl_weight比重越大，整体拉得越直，[0,1000][0, 1000][0,1000]差别不大；比重为100000的曲线不平滑，不可取。\n\n[10000,100000][10000,100000][10000,100000]之间的比重，曲线过于柔软，贴近别解，不建议。\n\n比重在区间[1000,10000][1000,10000][1000,10000]，对曲线其实影响不大。车辆初始dl一般也不会超过100，也就是比重一般不会超过10000。\n weight_ddl对曲线影响不大，默认值1000.0\n\nddl_weight比重对曲线影响不大。\n weight_dddl影响结果拐弯性能，默认值50000.0，建议区间[50000.0,500000.0][50 000.0,500 000.0][50000.0,500000.0]，间隔100000.0100 000.0100000.0\n\n\n\ndddl_weight比重越小，越接近中心线，曲线越扭曲 (柔软) ，晚点绕障，提前回位；比重越大，整体曲线越平缓，感觉越 硬直 ，曲线拐弯性能越差。\n\n end_state_weight参数分析\n# weight (l, dl, ddl) : tuple\n end_state_weight_l默认值是1000，建议end_state=(0.,0.,0.)end\\_state= (0., 0., 0.)end_state=(0.,0.,0.)，对曲线影响不大\n 当end_state=(0.,0.,0.)end\\_state= (0., 0., 0.)end_state=(0.,0.,0.)\n\n该比重对曲线影响不大，比重为[0.0,10.0][0.0,10.0][0.0,10.0]，结果曲线基本一致。当比重为[100,1000000][100,1000000][100,1000000]时，末尾曲线比较靠近0.0，整体上基本一致。\n 当end_state=(0.1,0.,0.)end\\_state= (0.1, 0., 0.)end_state=(0.1,0.,0.)，建议区间[1000,10000][1000,10000][1000,10000]，特殊时候区间[100000,1000000][100000,1000000][100000,1000000]\n\n\n比重为[0,1000][0,1000][0,1000]时，结果曲线与边界相交，不建议；当然如果障碍物buffer考虑很大时，可以适当妥协。\n\n比重为[10000,100000][10000,100000][10000,100000]的结果曲线差别不大，当达到1000000时，曲线过于柔软，不建议。\n\n建议区间[1000,10000][1000,10000][1000,10000]，间隔1000，比重越大避障时，越早开始绕障，越早回位。\n\n比重也可以在[1000，2000][1000，2000][1000，2000]，间隔100，之间进行微调，比重越大避障时，越早开始绕障，越早回位。\n\n某些时候，可以采用该比重区间[100000,1000000][100000,1000000][100000,1000000]，让车在避障时远离障碍物。\n 当end_state=(3.5,0.,0.)end\\_state= (3.5, 0., 0.)end_state=(3.5,0.,0.)，建议区间[2000,10000][2000,10000][2000,10000]，特殊时候区间[10000,100000][10000,100000][10000,100000]\n\n\n比重为[0,1000][0,1000][0,1000]时，结果曲线与边界相交，不建议；当然如果障碍物buffer考虑很大时，可以适当妥协。\n\n比重为[100000,1000000][100000,1000000][100000,1000000]的结果曲线差别不大，过于柔软，不建议。\n\n存在跳变。\n\n依旧存在跳变。\n\n跳变存在在[1500,1600][1500,1600][1500,1600]之间。\n\n比重在[2000,3000][2000,3000][2000,3000]，间隔100，可以微调结果曲线。\n\n某些时候，可以采用该比重区间[10000,100000][10000,100000][10000,100000]，让车在避障时远离障碍物。\n end_state_weight_dl对曲线影响不大，默认值0.00.00.0\n\n比重越大，让曲线的末尾段斜率越接近设定值，对整体曲线的影响不大。\n end_state_weight_ddl对曲线影响不大，默认值0.00.00.0\n\n对生成路径整体影响不大。\n weight_x_ref参数分析，默认值101010，建议区间[10,30][10,30][10,30]\n\n比重越大，曲线越接近目标线。超过100，基本不满足非和谐系统的运动。取值可以考虑在[0,100][0,100][0,100]。\n\n进一步分析，可以发现在区间[0,20][0,20][0,20]曲线较为敏感，对曲影响较大。\n\n\n比重为5,6,7,85,6,7,85,6,7,8曲线较为一致，比重为9,109,109,10曲线较为一致，所以下一步分析区间[8,9][8,9][8,9]\n\n不存在过渡性，即存在跳变(跳变存在在区间[8.8,9.0][8.8,9.0][8.8,9.0])，不方便调试，所以考虑区间[10,30][10,30][10,30]。\n\n比重越大，曲线越接近目标线，越早回中心线。\n","categories":["算法"]},{"title":"非线性优化工具IPOPT安装","url":"/2025/02/04/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7IPOPT%E5%AE%89%E8%A3%85/","content":"详细记录了在 Linux（Ubuntu 20.04）环境下安装 IPOPT 及其依赖项（如 ASL、HSL、MUMPS、ColPack、Adol-C）的方法，涵盖 C++ 和 Python 两种使用场景，并附带错误排查建议和编译参数说明，是一份非常实用的安装部署手册。\n\n C++\n Ipopt安装\nLinux | Ubuntu 20.04安装ipopt和cppAD | 安装全流程+报错解决\n按照方法二，成功安装Ipot3.14.17版本\n 源码安装\n\n安装依赖\n\nsudo apt-get install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev libblas-dev \n\n创建一个存放所有跟Ipopt相关的文件夹，便于管理\n\nmkdir ~/Ipopt_pkgcd Ipopt_pkg\n\n安装ASL\n\ngit clone https://github.com/coin-or-tools/ThirdParty-ASL.gitcd ThirdParty-ASLsudo ./get.ASLsudo ./configuresudo makesudo make installcd ..\n\n安装HSL\n\ngit clone https://github.com/coin-or-tools/ThirdParty-HSL.gitcd ThirdParty-HSL# 接下来需要下载coinhsl文件，并解压到ThirdParty-HSL目录下\n下载coinhsl.zip文件，并解压到ThirdParty-HSL目录下\n在ThirdParty-HSL目录下，执行以下命令\nsudo ./configuresudo makesudo make installcd ..\n\n安装MUMPS\n\ngit clone https://github.com/coin-or-tools/ThirdParty-Mumps.gitcd ThirdParty-Mumpssudo ./get.Mumpssudo ./configuresudo makesudo make installcd ..\n\n安装Ipopt\n\ngit clone https://github.com/coin-or/Ipopt.gitcd Ipoptmkdir buildcd buildsudo ../configuresudo makesudo make testsudo make install\n\n完善环境\n\ncd /usr/local/includesudo cp coin-or coin -rsudo ln -s /usr/local/lib/libcoinmumps.so.3 /usr/lib/libcoinmumps.so.3sudo ln -s /usr/local/lib/libcoinhsl.so.2 /usr/lib/libcoinhsl.so.2sudo ln -s /usr/local/lib/libipopt.so.3 /usr/lib/libipopt.so.3\n ColPack安装\n 指令安装(验证可行)\nsudo apt-get install libcolpack-dev# 默认安装在/usr目录下\n# 查询是否安装了ColPackldconfig -p | grep ColPack\n\n 源码安装\n\n源码下载\n\ngit clone https://github.com/CSCsw/ColPack.git  #Download ColPackcd ColPack             # ColPack Root Directory\n\n安装\n\n该方法变以后的头文件和库所在位置是错误的，需要调整位置。否则，安装Adolc时会链接不到。\n\n通过autotools安装\n\ncd build/automake      # automake folderautoreconf -vif        # generate configure files based on the machincemkdir mywork           cd myworkfullpath=$(pwd)        # modify fullpath to your destination folder if need../configure --prefix=$&#123;fullpath&#125;  make -j 4              # Where &quot;4&quot; is the number of cores on your machinemake install           # install lib and include/ColPack to destination  \n\n通过cmake安装\n\nmkdir build/cmake/myworkcd build/cmake/myworkfullpath=$(pwd)        # modify fullpath to your destination folder if needcmake .. -DCMAKE_INSTALL_PREFIX:PATH=$&#123;fullpath&#125; make -j 4              # Where &quot;4&quot; is the number of cores on your machinemake install           # install the libararies\n\n如果指定v1.0.10版本(验证可行)\n\ngit checkout v1.0.10./autoconf.sh# 配置安装地址./configure --prefix=$&#123;ColPack的安装地址&#125;makesudo make install\n\n$&#123;ColPack的安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n\n\n头文件在include/ColPack/目录\n库文件在lib/目录\n\n\n可以直接修改autoconf.sh文件内容，配置安装地址\n\n\n Adolc安装\n库地址\n 使用CMake安装(目前还不成熟)\n\n 使用AutoTools安装(验证可行)\n 使用 AutoTools 进行本地安装\n\n\n执行 autoreconf -fi\n\n\n运行 configure，可能需要使用以下选项之一：\n\n--prefix=PREFIX：将库和头文件安装到 PREFIX 目录（默认：${HOME}/adolc_base）。\n--enable-sparse：构建稀疏驱动程序（默认：no）。\n--with-openmp-flag=FLAG：使用 FLAG 来启用编译时的 OpenMP（默认：none）。\n--enable-docexa：构建文档化的示例（默认：no）。\n--enable-addexa：构建额外的示例（默认：no）。\n--enable-parexa：构建并行示例（默认：no）。如果启用此选项，则需要使用 --with-openmp-flag=FLAG。\n--with-cflags=FLAGS：使用 CFLAGS=FLAGS（默认：-g -O2）。\n--with-cxxflags=FLAGS：使用 CXXFLAGS=FLAGS（默认：-g -O2 -std=c++11）。\n--with-boost=BOOST_PATH：指定已编译的 Boost 库路径，默认选择系统库（如果存在）。\n\n\n\n执行 make\n\n\n执行 make install\n默认情况下，make install 会将所有文件安装到 $&#123;PREFIX&#125;/lib 和 $&#123;PREFIX&#125;/include 目录。如果需要指定其他安装目录，可以在 configure 调用时使用 --prefix 选项。\n\n\n此过程会在适当的目录中生成所有必需的makefile。执行 ./configure --help 可以查看其他可用选项的详细信息。\n 非本地安装\n如同在 INSTALL 文件中提到的，可以使用 --prefix=PATH 配置选项将 adolc 软件包安装到与 $&#123;HOME&#125;/adolc_base 不同的目录。这通常用于全局安装。常见的路径包括 /usr 和 /usr/local/，并且还有其他路径也会被使用。通过提供额外的 configure 选项，可以对安装目录进行更精细的控制。详情请参见 ./configure --help。\n执行 make install 完成安装时，目标目录必须具有写权限。确保你拥有相关权限，否则可能会得到意外结果。\n如果需要多个用户共享库文件，全局安装可能会非常有用。通过将库路径添加到 /etc/ld.so.conf，就可以避免使用 LD_LIBRARY_PATH 和 -L 链接选项。在许多情况下，例如 PATH=/usr/local，还可以避免在编译源代码时使用 -I 指令。\n 安装指令(验证可行)\n# 1. 下载源代码git clone https://github.com/coin-or/ADOL-C.gitcd ADOL-C/# 2. 切换到所需版本分支git checkout releases/2.7.2# 3. 执行前期准备（需要AutoTools工具）autoreconf -fi# 4. 配置安装目录和所需驱动CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib \\./configure --prefix=$&#123;Adolc想要安装地址&#125; --enable-sparse --with-colpack=$&#123;ColPack的安装地址&#125;# 5. 编译make# 6. 安装make install\n\n$&#123;Adolc想要安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n$&#123;ColPack的安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n\n注意：\n\n需要切换发布版本，比如releases/2.7.2，否则autoreconf -fi会执行失败\n需要指定CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib，否则会出现yes/lib64等异常路径，导致失败。(通过设置 CPPFLAGS 和 LDFLAGS 环境变量明确指定 ColPack 的路径来配置 ADOL-C)\n\n\n验证是否成功链接上ColPack库: \n\nldd libadolc.so\n\n\n Python\nc++与python非线性规(优)划（化）工具\n在Ubuntu + Anaconda环境下安装pyomo与ipopt：\n## 进入虚拟环境conda update condaconda update anacondaconda install -c conda-forge pyomoconda install -c conda-forge pyomo.extrasconda install -c conda-forge coincbcconda install -c conda-forge ipopt\n 拓展知识\n 编译参数CPPFLAGS、CFLAGS、LDFLAGS的理解\n\n\nCPPFLAGS: 预处理器需要的选项 如：-I(大写i指定头文件路径)\nCFLAGS：编译的时候使用的参数–Wall –g -c\nLDFLAGS：链接库使用的选项–L -l(大写L指定动态库的路径，小写L指定动态库的名称)\n\n\n\n\nCFLAGS表示用于C编译器的选项\nCXXFLAGS表示用于C++编译器的选项\n这两个变量实际上涵盖了编译和汇编的两个步骤\n\n\n\n\nCPPFLAGS：指定头文件(.h)的路径，如：CPPFLAGS=-I/usr/include -I/path/include。\n\n安装一个包时会在安装路径下建立一个include文件夹;\n当安装过程中出现故障时，试着把曾经安装的包的include文件夹增加到该变量中来。\n\n\n\nLDFLAGS：gcc等编译器会用到的一些优化參数，也能够在里面指定库文件的位置。\n使用方法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n\n每安装一个包，一定会在安装文件夹里建立一个lib文件夹。\n假设已经安装了某个包，而在安装另一个包时，它愣是说找不到，那就将那个包的lib路径增加的LDFALGS中试一下。\n\n\n\nLIBS：告诉链接器要链接哪些库文件。如LIBS = -lpthread -liconv\n\n简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。\n有时候LDFLAGS指定-L尽管能让链接器找到库进行链接。可是运行时链接器却找不到这个库。假设要让软件运行时库文件的路径也得到扩展，那么我们须要增加这两个库给-Wl,R：\n假设在运行./configure曾经环境变量设置export LDFLAGS=&quot;-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib&quot;\n\n注意环境变量设置等号两边不能够有空格，并且要加上引号（shell的使用方法）。\n那么运行configure以后。Makefile将会设置这个选项，链接时会有这个參数，编译出来的可运行程序的库文件搜索路径就得到扩展了。LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib\n\n\n\n\n\n","categories":["Linux软件开发","算法"]}]