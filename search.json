[{"title":"Apollo r5.5.0 代码解读 之 混合A星算法调试工具","url":"/2021/09/18/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E6%B7%B7%E5%90%88A%E6%98%9F%E7%AE%97%E6%B3%95%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","content":"这篇博客介绍了 Apollo r5.5.0 中混合 A* 路径规划算法的调试工具实现。通过 C++ 类封装障碍物与结果容器，并通过 extern “C” 接口实现 Python 与 C++ 的调用对接。文中还详细解析了关键参数如 step_size、delta_t 等对轨迹质量与计算效率的影响，并展示了不同配置下的可视化效果，帮助读者深入理解混合 A* 算法的内部机制与调试方法。\n\n 代码分析\n在hybrid_a_star_wrapper.cc定义了两个类，用于存储障碍物(HybridAObstacleContainer)和计算结果(HybridAResultContainer)。\n// hybrid_a_star_wrapper.ccclass HybridAObstacleContainer &#123; public:  HybridAObstacleContainer() = default;  // 输入是double类型的指针，所以可以是一个数列  void AddVirtualObstacle(double* obstacle_x, double* obstacle_y,                          int vertice_num) &#123;    std::vector&lt;common::math::Vec2d&gt; obstacle_vertices;    for (int i = 0; i &lt; vertice_num; i++) &#123;      common::math::Vec2d vertice(obstacle_x[i], obstacle_y[i]);      obstacle_vertices.emplace_back(vertice);    &#125;    obstacles_list.emplace_back(obstacle_vertices);  &#125;  const std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt;&amp;  // 返回障碍物线段集合  GetObstaclesVerticesVec() &#123;    return obstacles_list;  &#125; private:  std::vector&lt;std::vector&lt;common::math::Vec2d&gt;&gt; obstacles_list;&#125;;\n\n如果是Box障碍物，则输入五个点，第一个点和最后一个点一致。\n// hybrid_a_star_wrapper.ccclass HybridAResultContainer &#123; public:  HybridAResultContainer() = default;  void LoadResult() &#123;    // 输出结果    x_ = std::move(result_.x);    y_ = std::move(result_.y);    phi_ = std::move(result_.phi);    v_ = std::move(result_.v);    a_ = std::move(result_.a);    steer_ = std::move(result_.steer);  &#125;  std::vector&lt;double&gt;* GetX() &#123; return &amp;x_; &#125;  std::vector&lt;double&gt;* GetY() &#123; return &amp;y_; &#125;  std::vector&lt;double&gt;* GetPhi() &#123; return &amp;phi_; &#125;  std::vector&lt;double&gt;* GetV() &#123; return &amp;v_; &#125;  std::vector&lt;double&gt;* GetA() &#123; return &amp;a_; &#125;  std::vector&lt;double&gt;* GetSteer() &#123; return &amp;steer_; &#125;  HybridAStartResult* PrepareResult() &#123; return &amp;result_; &#125; private:  HybridAStartResult result_;  std::vector&lt;double&gt; x_;  std::vector&lt;double&gt; y_;  std::vector&lt;double&gt; phi_;  std::vector&lt;double&gt; v_;  std::vector&lt;double&gt; a_;  std::vector&lt;double&gt; steer_;&#125;;\n 类C和C++的混合编成\nextern &quot;C&quot; &#123; &#125;的真实目的是实现 类C 和 C++ 的混合编程。在C源文件中的语句前面加上extern &quot;C&quot;，表明它按照 类C 的编译和连接规约来编译和连接，而不是C的编译的连接规约。这样在 类C 的代码中就可以调用C++的函数or变量等。（注：我在这里所说的类C，代表的是跟C语言的编译和连接方式一致的所有语言）\n// hybrid_a_star_wrapper.ccextern &quot;C&quot; &#123;// 创建混合A星解决器指针HybridAStar* CreatePlannerPtr() &#123;  apollo::planning::PlannerOpenSpaceConfig planner_open_space_config_;  // 导入配置参数  CHECK(apollo::cyber::common::GetProtoFromFile(      FLAGS_hybrid_a_star_test_config_filename, &amp;planner_open_space_config_))      &lt;&lt; &quot;Failed to load open space config file &quot;      &lt;&lt; FLAGS_hybrid_a_star_test_config_filename;  AERROR &lt;&lt; FLAGS_hybrid_a_star_test_config_filename;  return new HybridAStar(planner_open_space_config_);&#125;// 创建装载输入障碍物容器，返回指针类型HybridAObstacleContainer* CreateObstaclesPtr() &#123;  return new HybridAObstacleContainer();&#125;// 创建装载计算结果容器，返回指针类型HybridAResultContainer* CreateResultPtr() &#123;  return new HybridAResultContainer();&#125;// 往障碍物容器里面添加障碍物函数void AddVirtualObstacle(HybridAObstacleContainer* obstacles_ptr,                        double* obstacle_x, double* obstacle_y,                        int vertice_num) &#123;  obstacles_ptr-&gt;AddVirtualObstacle(obstacle_x, obstacle_y, vertice_num);&#125;// 关键函数，输入混合A星解决器以及其他条件进行轨迹计算bool Plan(HybridAStar* planner_ptr, HybridAObstacleContainer* obstacles_ptr,          HybridAResultContainer* result_ptr, double sx, double sy, double sphi,          double ex, double ey, double ephi, double* XYbounds) &#123;  std::vector&lt;double&gt; XYbounds_(XYbounds, XYbounds + 4);  return planner_ptr-&gt;Plan(sx, sy, sphi, ex, ey, ephi, XYbounds_,                           obstacles_ptr-&gt;GetObstaclesVerticesVec(),                           result_ptr-&gt;PrepareResult());&#125;// 结果输出函数，将结果分解到对应的数列集里面void GetResult(HybridAResultContainer* result_ptr, double* x, double* y,               double* phi, double* v, double* a, double* steer,               size_t* output_size) &#123;  result_ptr-&gt;LoadResult();  size_t size = result_ptr-&gt;GetX()-&gt;size();  std::cout &lt;&lt; &quot;return size is &quot; &lt;&lt; size &lt;&lt; std::endl;  for (size_t i = 0; i &lt; size; i++) &#123;    x[i] = result_ptr-&gt;GetX()-&gt;at(i);    y[i] = result_ptr-&gt;GetY()-&gt;at(i);    phi[i] = result_ptr-&gt;GetPhi()-&gt;at(i);    v[i] = result_ptr-&gt;GetV()-&gt;at(i);  &#125;  for (size_t i = 0; i &lt; size - 1; i++) &#123;    a[i] = result_ptr-&gt;GetA()-&gt;at(i);    steer[i] = result_ptr-&gt;GetSteer()-&gt;at(i);  &#125;  *output_size = size;&#125;&#125;;\n python与c交互\n怎么告诉 Python 一个外来函数的形参类型和返回的值的类型呢？\n这就要需要给函数的两个属性 restype 和 argtypes 赋值了。它们分别对应返回类型和参数类型。\n如果返回类型是void，可以不用说明。\n# hybrid_a_star_python_interface.py#!/usr/bin/env pythonimport ctypesfrom ctypes import *import math# 加载需要引用的c++库lib = cdll.LoadLibrary(    &#x27;/apollo/lib/libmodules_planning_open_space_tools_hybrid_a_star_wrapper.so&#x27;)# python需要调用到c++库里面的函数，都需要说明下函数的返回类型和参数类型# CreatePlannerPtr()没有输入参数，为空，所以使用[]，或者赋值为 None# CreatePlannerPtr()返回一个类的指针，所以使用c_void_plib.CreatePlannerPtr.argtypes = []lib.CreatePlannerPtr.restype = c_void_plib.CreateResultPtr.argtypes = []lib.CreateResultPtr.restype = c_void_plib.CreateObstaclesPtr.argtypes = []lib.CreateObstaclesPtr.restype = c_void_p# AddVirtualObstacle()输入参数指定类型，注意：指针使用# AddVirtualObstacle()返回是void，所以没有赋值lib.AddVirtualObstacle.argtypes = [c_void_p, POINTER(c_double), POINTER(c_double), c_int]# Plan()函数的返回类型是布尔类型lib.Plan.restype = c_bool# Plan()输入参数类型指定与c++里面代码一一对应lib.Plan.argtypes = [c_void_p, c_void_p, c_void_p, c_double, c_double, c_double, c_double,                     c_double, c_double, POINTER(c_double)]lib.GetResult.argtypes = [c_void_p, POINTER(c_double), POINTER(c_double), POINTER(c_double),            POINTER(c_double), POINTER(c_double), POINTER(c_double), POINTER(c_ushort)]# 定义pytho的一个类，用于外部调用class HybridAStarPlanner(object):    def __init__(self):        self.planner = lib.CreatePlannerPtr()        self.obstacles = lib.CreateObstaclesPtr()        self.result = lib.CreateResultPtr()    def AddVirtualObstacle(self, obstacle_x, obstacle_y, vertice_num):        lib.AddVirtualObstacle(self.obstacles, POINTER(c_double)(obstacle_x),                               POINTER(c_double)(obstacle_y), (c_int)(vertice_num))    def Plan(self, sx, sy, sphi, ex, ey, ephi, XYbounds):        return lib.Plan(self.planner, self.obstacles, self.result, c_double(sx),                        c_double(sy), c_double(sphi), c_double(ex), c_double(ey),                        c_double(ephi), POINTER(c_double)(XYbounds))    def GetResult(self, x, y, phi, v, a, steer, output_size):        lib.GetResult(self.result, POINTER(c_double)(x), POINTER(c_double)(y),                      POINTER(c_double)(phi), POINTER(c_double)(v), POINTER(c_double)(a),                      POINTER(c_double)(steer), POINTER(c_ushort)(output_size))\n# hybrid_a_star_visualizer.py# 先定以一个解决器HybridAStar = HybridAStarPlanner()# 然后通过AddVirtualObstacle()函数增加障碍物约束# 三点是折线，两条线段，三个点HybridAStar.AddVirtualObstacle(left_boundary_x_c, left_boundary_y_c, 3)# 紧接通过Plan()函数进行轨迹规划HybridAStar.Plan(sx, sy, sphi, ex, ey, ephi, XYbounds_ctype)# 最后通过GetResult()函数获得计算结果HybridAStar.GetResult(x, y, phi, v, a, steer, size)\n需要留意：python类型数据作为c++库里函数输入参数时，需要进行数据转换；反之，输出也是。\nleft_boundary_x = [-30.0, 0.0, 0.0]left_boundary_x_c = (c_double * 3)(*left_boundary_x)num_output_buffer = 100000x = (c_double * num_output_buffer)()y = (c_double * num_output_buffer)()\n 配置参数分析\nroi_config &#123;  roi_longitudinal_range: 15.0  parking_start_range: 12.0  parking_inwards: false&#125;warm_start_config &#123;  xy_grid_resolution: 1.5  phi_grid_resolution: 0.6  next_node_num: 10  step_size: 1.5  traj_forward_penalty: 1.0  traj_back_penalty: 1.0  traj_gear_switch_penalty: 10.0  traj_steer_penalty: 1.5  traj_steer_change_penalty: 0.0  grid_a_star_xy_resolution: 1.5  node_radius: 0.25  s_curve_config &#123;    acc_weight: 1.0    jerk_weight: 0.0    kappa_penalty_weight: 100.0    ref_s_weight: 0.1    ref_v_weight: 0.0  &#125;&#125;trajectory_partition_config &#123;  interpolated_pieces_num: 50  initial_gear_check_horizon: 3  heading_searching_range: 0.3  gear_shift_period_duration: 2.0  gear_shift_max_t: 3.0  gear_shift_unit_t: 0.02&#125;delta_t: 0.5is_near_destination_threshold: 0.05enable_check_parallel_trajectory: falseenable_linear_interpolation: false\n warm_start_config\n xy_grid_resolution\nx_grid_ = static_cast&lt;int&gt;(    (x_ - XYbounds[0]) /    open_space_conf.warm_start_config().xy_grid_resolution());y_grid_ = static_cast&lt;int&gt;(    (y_ - XYbounds[2]) /    open_space_conf.warm_start_config().xy_grid_resolution());\n\n phi_grid_resolution\nphi_grid_ = static_cast&lt;int&gt;(      (phi_ - (-M_PI)) /      open_space_conf.warm_start_config().phi_grid_resolution());\n next_node_num\n混合A星当前点往外拓展点的数量，例字如下(next_node_num: 10)\n\n step_size\n基本点之间的距离，决定了输出结果点的数量。\ntraveled_distance = step_size_;double arc = std::sqrt(2) * xy_grid_resolution_;for (size_t i = 0; i &lt; arc / step_size_; ++i) &#123;    const double next_x = last_x + traveled_distance * std::cos(last_phi);    ...&#125;\n\n比如：\n# step_size: 1.5 输出结果如下planning time is 0.00040459632873535156return size is 29\n\n\n# step_size: 0.5 输出结果如下planning time is 0.0005877017974853516return size is 75\n\n\n traj_forward_penalty\n主要是针对混合A星（非RS曲线算法）算法，往前移动一个步长(step_size_)的惩罚系数\npiecewise_cost += static_cast&lt;double&gt;(next_node-&gt;GetStepSize() - 1) *                  step_size_ * traj_forward_penalty_;\n traj_back_penalty\n主要是针对混合A星（非RS曲线算法）算法，往后移动一个步长(step_size_)的惩罚系数\npiecewise_cost += static_cast&lt;double&gt;(next_node-&gt;GetStepSize() - 1) *                  step_size_ * traj_back_penalty_;\n traj_gear_switch_penalty\n主要是针对混合A星（非RS曲线算法）算法，前进后退档位切换的惩罚系数\nif (current_node-&gt;GetDirec() != next_node-&gt;GetDirec()) &#123;  piecewise_cost += traj_gear_switch_penalty_;&#125;\n traj_steer_penalty\n主要是针对混合A星（非RS曲线算法）算法，对方向盘转角惩罚系数，也就是尽量地保持直行\nif (current_node-&gt;GetDirec() != next_node-&gt;GetDirec()) &#123;  piecewise_cost += traj_gear_switch_penalty_;&#125;\n traj_steer_change_penalty\n主要是针对混合A星（非RS曲线算法）算法，对方向盘变化的惩罚系数，也就是要尽量地保持方向盘方向不变\npiecewise_cost += traj_steer_change_penalty_ *                  std::abs(next_node-&gt;GetSteer() - current_node-&gt;GetSteer());\n enable_dp_map\n设置为true时，启发H值采用动态规划算法计算；设置为false时，采用曼哈顿距离或者欧氏距离。\n enable_euler_distance\n设置为true时，使用欧氏距离作为H值；设置为false时，采用曼哈顿距离最为H值。\n grid_a_star_xy_resolution\n通过动态规划获得启发H值，用于计算cost，类似配置参数xy_grid_resolution\n node_radius\n在动态规划算法里，判断与障碍物碰撞的阈值。\nif (linesegment.DistanceTo(&#123;node-&gt;GetGridX(), node-&gt;GetGridY()&#125;) &lt;    node_radius_) &#123;  return false;&#125;\n required_size_of_rs_segs\n限制最短RS曲线的段数。段数不大于设定值。\n delta_t\n混合A星算法得到的路径点，点与点的时间间隔，通过这个参数以及step_size影响速度的计算。\n∣max(velocity)∣≤step_sizedelta_t|max(velocity)|\\leq \\frac{step\\_size}{delta\\_t}\n∣max(velocity)∣≤delta_tstep_size​\ndouble discrete_v = (((result-&gt;x[i + 1] - result-&gt;x[i]) / delta_t_) *                         std::cos(result-&gt;phi[i]) +                     ((result-&gt;x[i] - result-&gt;x[i - 1]) / delta_t_) *                         std::cos(result-&gt;phi[i])) /                        2.0 +                    (((result-&gt;y[i + 1] - result-&gt;y[i]) / delta_t_) *                         std::sin(result-&gt;phi[i]) +                     ((result-&gt;y[i] - result-&gt;y[i - 1]) / delta_t_) *                         std::sin(result-&gt;phi[i])) /                        2.0;\n\n\nstep_size:1.5 delta_t: 0.3\n\nstep_size:1.5 delta_t: 0.5\n\n FLAGS_use_s_curve_speed_smooth\n为true时，使用二次规划算法(GenerateSCurveSpeedAcceleration())生成速度加速度。为false时，使用位置差除时间(GenerateSpeedAcceleration())得到速度，再求加速度。\n\n\n使用GenerateSpeedAcceleration()\n  I0911 17:28:25.671339 570808 hybrid_a_star.cc:906] [planning]searched RS num is 23I0911 17:28:25.671344 570808 hybrid_a_star.cc:907] [planning]explored node num is 59E0911 17:28:25.671348 570808 hybrid_a_star.cc:910] [planning]hybrid astar total time is 0.00175691planning time is 0.0018563270568847656return size is 38\n\n\n\n\n使用GenerateSCurveSpeedAcceleration()\n  I0911 17:54:39.282204 578265 hybrid_a_star.cc:906] [planning]searched RS num is 23I0911 17:54:39.282224 578265 hybrid_a_star.cc:907] [planning]explored node num is 59E0911 17:54:39.282227 578265 hybrid_a_star.cc:910] [planning]hybrid astar total time is 0.0897994planning time is 0.08991193771362305return size is 81\n\n\n\n\n FLAGS_enable_parallel_hybrid_a\n采用多线程形式进行计算RS曲线。\nif (FLAGS_enable_parallel_hybrid_a) &#123;  // AINFO &lt;&lt; &quot;parallel hybrid a*&quot;;  if (!GenerateRSPPar(start_node, end_node, all_possible_paths)) &#123;    ADEBUG &lt;&lt; &quot;Fail to generate general profile of different RSPs&quot;;    return false;  &#125;&#125; else &#123;  if (!GenerateRSP(start_node, end_node, all_possible_paths)) &#123;    AERROR &lt;&lt; &quot;Fail to generate general profile of different RSPs&quot;;    return false;  &#125;&#125;\n","categories":["算法","Apollo源码解读"]},{"title":"Apollo r5.5.0 代码解读之规划模块--多项次曲线","url":"/2021/02/02/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E8%A7%84%E5%88%92%E6%A8%A1%E5%9D%97--%E5%A4%9A%E9%A1%B9%E6%AC%A1%E6%9B%B2%E7%BA%BF/","content":" 简介\n点到点的轨迹规划算法可以理解为在规划的时间TTT内，从已知起始点 θstart\\theta_{start}θstart​运动到末尾点θend\\theta_{end}θend​的方法。这里引入中间变量s(t)s(t)s(t)，它是时间的函数，定义域[0,T][0,T][0,T]，值域[0,1][0,1][0,1]，sss与θ\\thetaθ的关系见下面公式。这个公式不难理解，当s=0s=0s=0时，θ=θstart\\theta=\\theta_{start}θ=θstart​；当s=1s=1s=1时，θ=θend\\theta=\\theta_{end}θ=θend​。\n\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)&amp;=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns&amp;=s(t),t\\in[0,T] \\\\\n\\end{aligned}\nθ(s)s​=θstart​+s(θend​−θstart​),s∈[0,1]=s(t),t∈[0,T]​\nθ\\thetaθ对ttt求导是速度，即：\n∂θ∂t=∂θ∂s⋅∂s∂t其中∂θ∂s=θend−θstart∂θ∂t=(θend−θstart)⋅∂s∂t\\begin{aligned}\n\\frac{\\partial\\theta}{\\partial t}&amp;= \\frac{\\partial\\theta}{\\partial s} \\cdot \\frac{\\partial s}{\\partial t} \\quad其中\\frac{\\partial\\theta}{\\partial s}=\\theta_{end} -\\theta_{start} \\\\\n\\frac{\\partial\\theta}{\\partial t}&amp;=(\\theta_{end} -\\theta_{start})\\cdot \\frac{\\partial s}{\\partial t} \\\\\n\\end{aligned}\n∂t∂θ​∂t∂θ​​=∂s∂θ​⋅∂t∂s​其中∂s∂θ​=θend​−θstart​=(θend​−θstart​)⋅∂t∂s​​\nθ\\thetaθ对ttt求二阶导是加速度，即\n∂2θ∂t2=∂(∂θ∂s)∂t⋅∂s∂t+∂θ∂s⋅∂2s∂t2其中∂(∂θ∂s)∂t=∂(θend−θstart)∂t=0∂2θ∂t2=(θend−θstart)⋅∂2s∂t2\\begin{aligned}\n\\frac{\\partial^2\\theta}{\\partial t^2}&amp;= \\frac{\\partial(\\frac{\\partial\\theta}{\\partial s})}{\\partial t} \\cdot \\frac{\\partial s}{\\partial t}+\\frac{\\partial\\theta}{\\partial s} \\cdot \\frac{\\partial^2 s}{\\partial t^2} \\quad其中\\frac{\\partial(\\frac{\\partial\\theta}{\\partial s})}{\\partial t}=\\frac{\\partial(\\theta_{end} -\\theta_{start})}{\\partial t}=0 \\\\\n\\frac{\\partial^2\\theta}{\\partial t^2}&amp;=(\\theta_{end} -\\theta_{start})\\cdot \\frac{\\partial^2 s}{\\partial t^2} \\\\\n\\end{aligned}\n∂t2∂2θ​∂t2∂2θ​​=∂t∂(∂s∂θ​)​⋅∂t∂s​+∂s∂θ​⋅∂t2∂2s​其中∂t∂(∂s∂θ​)​=∂t∂(θend​−θstart​)​=0=(θend​−θstart​)⋅∂t2∂2s​​\n由于θstart\\theta_{start}θstart​和θend\\theta_{end}θend​是已知的，所以速度和加速度随时间的变化取决与s=s(t),t∈[0,T]s=s(t),t\\in[0,T]s=s(t),t∈[0,T]。\n这里的s(t)s(t)s(t)有很多种方法，比较常见的是三次函数，五次函数，梯形函数，S曲线等。\n 三次曲线–&gt;cubic polynomial curve1d\nCubicPolynomialCurve1d::CubicPolynomialCurve1d(const double x0,                                               const double dx0,                                               const double ddx0,                                               const double x1,                                               const double param) &#123;  ComputeCoefficients(x0, dx0, ddx0, x1, param);  param_ = param;  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_ = x1;&#125;\ns(t)=a0+a1t+a2t2+a3t3s(t)=a_0 + a_1t + a_2t^2 + a_3t^3\ns(t)=a0​+a1​t+a2​t2+a3​t3\n入参初始条件\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02s(T)=a0+a1T+a2T2+a3T3=x1  ⟺  a3=x1−x0−dx0T−ddx02T2T3\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\ns(T) = a_0 + a_1T + a_2T^2 + a_3T^3 = x_1 \\iff a_3 = \\frac{x_1 - x_0 - dx_0T - \\frac{ddx_0}{2}T^2}{T^3}\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​s(T)=a0​+a1​T+a2​T2+a3​T3=x1​⟺a3​=T3x1​−x0​−dx0​T−2ddx0​​T2​​\nvoid CubicPolynomialCurve1d::ComputeCoefficients(const double x0,                                                 const double dx0,                                                 const double ddx0,                                                 const double x1,                                                 const double param) &#123;  DCHECK(param &gt; 0.0);  const double p2 = param * param;  const double p3 = param * p2;  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  coef_[3] = (x1 - x0 - dx0 * param - coef_[2] * p2) / p3;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble CubicPolynomialCurve1d::Evaluate(const std::uint32_t order,                                        const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return ((coef_[3] * p + coef_[2]) * p + coef_[1]) * p + coef_[0];    &#125;    case 1: &#123;      return (3.0 * coef_[3] * p + 2.0 * coef_[2]) * p + coef_[1];    &#125;    case 2: &#123;      return 6.0 * coef_[3] * p + 2.0 * coef_[2];    &#125;    case 3: &#123;      return 6.0 * coef_[3];    &#125;    default:      return 0.0;  &#125;&#125;\n 四次曲线–&gt;quartic polynomial curve1d\nQuarticPolynomialCurve1d::QuarticPolynomialCurve1d(    const double x0, const double dx0, const double ddx0, const double dx1,    const double ddx1, const double param) &#123;  param_ = param;  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_[0] = dx1;  end_condition_[1] = ddx1;  ComputeCoefficients(x0, dx0, ddx0, dx1, ddx1, param);&#125;\ns(t)=a0+a1t+a2t2+a3t3+a4t4s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4\ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4\n 入参初始条件（一）: x0, dx0, ddx0, dx1, ddx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(1)s&#x27;(T) = a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 1\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(1)\ns′′(T)=2a2+6a3T+12a4T2=ddx1(2)s&#x27;&#x27;(T) = 2a_2 + 6a_3T + 12a_4T^2 = ddx_1 \\tag2\ns′′(T)=2a2​+6a3​T+12a4​T2=ddx1​(2)\n公式3*(1)-T*(2)得：\n3a1+6a2T+9a3T2+12a4T3=3dx12a2T+6a3T2+12a4T3=T∗ddx1  ⟺  3a1+4a2T+3a3T2=3dx1−T∗ddx1  ⟺  a3=3dx1−T∗ddx1−3a1−4a2T3T2  ⟺  a3=3dx1−T∗ddx1−3dx0−2ddx0T3T2  ⟺  a3=3(dx1−ddx0T−dx0)−T∗(ddx1−ddx0)3T2\\begin{aligned}\n3a_1 + 6a_2T + 9a_3T^2 +12a_4T^3 &amp; = 3dx_1 \\\\\n2a_2T + 6a_3T^2 + 12a_4T^3&amp; = T*ddx_1 \\\\\n\\iff 3a_1 + 4a_2T +3a_3T^2 &amp;= 3dx_1 - T*ddx_1 \\\\\n\\iff a_3 &amp; = \\frac{3dx_1 - T*ddx_1-3a_1-4a_2T}{3T^2} \\\\\n\\iff a_3 &amp; = \\frac{3dx_1 - T*ddx_1-3dx_0 -2ddx_0T}{3T^2} \\\\\n\\iff a_3 &amp; = \\frac{3(dx_1 - ddx_0T - dx_0) - T*(ddx_1 - ddx_0)}{3T^2} \n\\end{aligned}\n3a1​+6a2​T+9a3​T2+12a4​T32a2​T+6a3​T2+12a4​T3⟺3a1​+4a2​T+3a3​T2⟺a3​⟺a3​⟺a3​​=3dx1​=T∗ddx1​=3dx1​−T∗ddx1​=3T23dx1​−T∗ddx1​−3a1​−4a2​T​=3T23dx1​−T∗ddx1​−3dx0​−2ddx0​T​=3T23(dx1​−ddx0​T−dx0​)−T∗(ddx1​−ddx0​)​​\n公式2(1)-T(2)得：\n2a1+4a2T+6a3T2+8a4T3=2dx12a2T+6a3T2+12a4T3=T∗ddx1  ⟺  2a1+2a2T−4a4T3=2dx1−T∗ddx1  ⟺  a4=2a1+2a2T−2dx1+T∗ddx14T3  ⟺  a4=2dx0+ddx0T−2dx1+T∗ddx14T3  ⟺  a4=−2(dx1−ddx0T−dx0)+T∗(ddx1−ddx0)4T3\\begin{aligned}\n2a_1 + 4a_2T + 6a_3T^2 +8a_4T^3 &amp; = 2dx_1 \\\\\n2a_2T + 6a_3T^2 + 12a_4T^3&amp; = T*ddx_1 \\\\\n\\iff 2a_1 + 2a_2T - 4a_4T^3 &amp;= 2dx_1 - T*ddx_1 \\\\\n\\iff a_4 &amp; = \\frac{2a_1 + 2a_2T - 2dx_1 + T*ddx_1}{4T^3} \\\\\n\\iff a_4 &amp; = \\frac{2dx_0 + ddx_0T - 2dx_1 + T*ddx_1}{4T^3} \\\\\n\\iff a_4 &amp; = \\frac{-2(dx_1 - ddx_0T - dx_0) + T*(ddx_1 - ddx_0)}{4T^3} \n\\end{aligned}\n2a1​+4a2​T+6a3​T2+8a4​T32a2​T+6a3​T2+12a4​T3⟺2a1​+2a2​T−4a4​T3⟺a4​⟺a4​⟺a4​​=2dx1​=T∗ddx1​=2dx1​−T∗ddx1​=4T32a1​+2a2​T−2dx1​+T∗ddx1​​=4T32dx0​+ddx0​T−2dx1​+T∗ddx1​​=4T3−2(dx1​−ddx0​T−dx0​)+T∗(ddx1​−ddx0​)​​\nvoid QuarticPolynomialCurve1d::ComputeCoefficients(    const double x0, const double dx0, const double ddx0, const double dx1,    const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  double b0 = dx1 - ddx0 * p - dx0;  double b1 = ddx1 - ddx0;  double p2 = p * p;  double p3 = p2 * p;  coef_[3] = (3 * b0 - b1 * p) / (3 * p2);  coef_[4] = (-2 * b0 + b1 * p) / (4 * p3);&#125;\n 入参初始条件（二）: x0, dx0, ddx0, x1, dx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4=x1(3)s(T)=a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 = x_1 \\tag 3\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4=x1​(3)\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(4)s&#x27;(T) =a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 4\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(4)\n公式4*(3)-T(4)得：\n4a0+4a1T+4a2T2+4a3T3+4a4T4=4x1a1T+2a2T2+3a3T3+4a4T4=T∗dx1  ⟺  4a0+3a1T+2a2T2+a3T3=4x1−T∗dx1  ⟺  a3=4x1−T∗dx1−4a0−3a1T−2a2T2T3  ⟺  a3=4x1−T∗dx1−4x0−3dx0T−ddx0T2T3  ⟺  a3=4(x1−x0−dx0T−ddx02T2)−T∗(dx1−dx0−ddx0T)T3\\begin{aligned}\n4a_0 + 4a_1T + 4a_2T^2 + 4a_3T^3 + 4a_4T^4&amp; = 4x_1 \\\\\na_1T + 2a_2T^2 + 3a_3T^3 + 4a_4T^4&amp; = T*dx_1 \\\\\n\\iff 4a_0 + 3a_1T + 2a_2T^2 + a_3T^3 &amp;= 4x_1 - T*dx_1 \\\\\n\\iff a_3 &amp; = \\frac{4x_1 - T*dx_1-4a_0-3a_1T-2a_2T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{4x_1 - T*dx_1 - 4x_0 - 3dx_0T-ddx_0T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{4(x_1-x_0-dx_0T-\\frac{ddx_0}{2}T^2) - T*(dx_1-dx_0 - ddx_0T)}{T^3} \n\\end{aligned}\n4a0​+4a1​T+4a2​T2+4a3​T3+4a4​T4a1​T+2a2​T2+3a3​T3+4a4​T4⟺4a0​+3a1​T+2a2​T2+a3​T3⟺a3​⟺a3​⟺a3​​=4x1​=T∗dx1​=4x1​−T∗dx1​=T34x1​−T∗dx1​−4a0​−3a1​T−2a2​T2​=T34x1​−T∗dx1​−4x0​−3dx0​T−ddx0​T2​=T34(x1​−x0​−dx0​T−2ddx0​​T2)−T∗(dx1​−dx0​−ddx0​T)​​\n公式3*(3)-T(3)得：\n3a0+3a1T+3a2T2+3a3T3+3a4T4=3x1a1T+2a2T2+3a3T3+4a4T4=T∗dx1  ⟺  3a0+2a1T+a2T2−a4T4=3x1−T∗dx1  ⟺  a4=3a0+2a1T+a2T2−3x1+T∗dx1T4  ⟺  a4=3x0+2dx0T+ddx02T2−3x1+T∗dx1T4  ⟺  a4=T∗(dx1−dx0−ddx0T)−3(x1−x0−dx0T−ddx02T2)T4\\begin{aligned}\n3a_0 + 3a_1T + 3a_2T^2 + 3a_3T^3 + 3a_4T^4&amp; = 3x_1 \\\\\na_1T + 2a_2T^2 + 3a_3T^3 + 4a_4T^4&amp; = T*dx_1 \\\\\n\\iff 3a_0 + 2a_1T + a_2T^2 - a_4T^4 &amp;= 3x_1 - T*dx_1 \\\\\n\\iff a_4 &amp; = \\frac{3a_0 + 2a_1T + a_2T^2 - 3x_1 + T*dx_1}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{3x_0 + 2dx_0T + \\frac{ddx_0}{2}T^2 - 3x_1 + T*dx_1}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{T*(dx_1 - dx_0 - ddx_0T) - 3(x_1-x_0-dx_0T - \\frac{ddx_0}{2}T^2)}{T^4} \n\\end{aligned}\n3a0​+3a1​T+3a2​T2+3a3​T3+3a4​T4a1​T+2a2​T2+3a3​T3+4a4​T4⟺3a0​+2a1​T+a2​T2−a4​T4⟺a4​⟺a4​⟺a4​​=3x1​=T∗dx1​=3x1​−T∗dx1​=T43a0​+2a1​T+a2​T2−3x1​+T∗dx1​​=T43x0​+2dx0​T+2ddx0​​T2−3x1​+T∗dx1​​=T4T∗(dx1​−dx0​−ddx0​T)−3(x1​−x0​−dx0​T−2ddx0​​T2)​​\nQuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointFirstOrder(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double p) &#123;  CHECK_GT(p, 0.0);  param_ = p;  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = 0.5 * ddx0;  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double b0 = x1 - coef_[0] - coef_[1] * p - coef_[2] * p2;  double b1 = dx1 - dx0 - ddx0 * p;  coef_[4] = (b1 * p - 3 * b0) / p4;  coef_[3] = (4 * b0 - b1 * p) / p3;  return *this;&#125;\n 入参初始条件（三）: x0, dx0, x1, dx1, ddx1\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4=x1(5)s(T)=a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 = x_1 \\tag 5\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4=x1​(5)\ns′(T)=a1+2a2T+3a3T2+4a4T3=dx1(6)s&#x27;(T)=a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 = dx_1 \\tag 6\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3=dx1​(6)\ns′′(T)=2a2+6a3T+12a4T2=ddx1(7)s&#x27;&#x27;(T)=2a_2 + 6a_3T + 12a_4T^2 = ddx_1 \\tag 7\ns′′(T)=2a2​+6a3​T+12a4​T2=ddx1​(7)\n公式12*(5)-6*T*(6)+T*T*(7)得：\n12a0+12a1T+12a2T2+12a3T3+12a4T4=12x16a1T+12a2T2+18a3T3+24a4T4=6dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  12a0+6a1T+2a2T2=12x1−6dx1T+ddx1T2  ⟺  a2=12x1−6dx1T+ddx1T2−12a0−6a1T2T2  ⟺  a2=12x1−6dx1T+ddx1T2−12x0−6dx0T2T2  ⟺  a2=0.5ddx1T2−3(dx1−dx0)T+6(x1−x0−dx0T)T2\\begin{aligned}\n12a_0 + 12a_1T + 12a_2T^2 + 12a_3T^3 + 12a_4T^4 &amp; = 12x_1 \\\\\n6a_1T + 12a_2T^2 + 18a_3T^3 + 24a_4T^4 &amp; = 6dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 12a_0 + 6a_1T + 2a_2T^2 &amp; = 12x_1 - 6dx_1T + ddx_1T^2 \\\\\n\\iff a_2 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12a_0 -6a_1T}{2T^2} \\\\\n\\iff a_2 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12x_0 -6dx_0T}{2T^2} \\\\\n\\iff a_2 &amp; = \\frac{0.5ddx_1T^2 - 3(dx_1-dx_0)T + 6(x_1-x_0-dx_0T)}{T^2} \\\\\n\\end{aligned}\n12a0​+12a1​T+12a2​T2+12a3​T3+12a4​T46a1​T+12a2​T2+18a3​T3+24a4​T42a2​T2+6a3​T3+12a4​T4⟺12a0​+6a1​T+2a2​T2⟺a2​⟺a2​⟺a2​​=12x1​=6dx1​T=ddx1​T2=12x1​−6dx1​T+ddx1​T2=2T212x1​−6dx1​T+ddx1​T2−12a0​−6a1​T​=2T212x1​−6dx1​T+ddx1​T2−12x0​−6dx0​T​=T20.5ddx1​T2−3(dx1​−dx0​)T+6(x1​−x0​−dx0​T)​​\n公式8*(5)-5*T*(6)+T*T*(7)得：\n8a0+8a1T+8a2T2+8a3T3+8a4T4=8x15a1T+10a2T2+15a3T3+20a4T4=5dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  8a0+3a1T−a3T3=8x1−5dx1T+ddx1T2  ⟺  a3=8a0+3a1T−8x1+5dx1T−ddx1T2T3  ⟺  a3=8x0+3dx0T−8x1+5dx1T−ddx1T2T3  ⟺  a3=−ddx1T2+5(dx1−dx0)T−8(x1−x0−dx0T)T3\\begin{aligned}\n8a_0 + 8a_1T + 8a_2T^2 + 8a_3T^3 + 8a_4T^4 &amp; = 8x_1 \\\\\n5a_1T + 10a_2T^2 + 15a_3T^3 + 20a_4T^4 &amp; = 5dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 8a_0 + 3a_1T - a_3T^3 &amp; = 8x_1 - 5dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{8a_0 + 3a_1T - 8x_1 + 5dx_1T - ddx_1T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{8x_0 + 3dx_0T - 8x_1 + 5dx_1T - ddx_1T^2}{T^3} \\\\\n\\iff a_3 &amp; = \\frac{-ddx_1T^2 + 5(dx_1-dx_0)T - 8(x_1-x_0-dx_0T)}{T^3} \\\\\n\\end{aligned}\n8a0​+8a1​T+8a2​T2+8a3​T3+8a4​T45a1​T+10a2​T2+15a3​T3+20a4​T42a2​T2+6a3​T3+12a4​T4⟺8a0​+3a1​T−a3​T3⟺a3​⟺a3​⟺a3​​=8x1​=5dx1​T=ddx1​T2=8x1​−5dx1​T+ddx1​T2=T38a0​+3a1​T−8x1​+5dx1​T−ddx1​T2​=T38x0​+3dx0​T−8x1​+5dx1​T−ddx1​T2​=T3−ddx1​T2+5(dx1​−dx0​)T−8(x1​−x0​−dx0​T)​​\n公式6*(5)-4*T*(6)+T*T*(7)得：\n6a0+6a1T+6a2T2+6a3T3+6a4T4=6x14a1T+8a2T2+12a3T3+16a4T4=4dx1T2a2T2+6a3T3+12a4T4=ddx1T2  ⟺  6a0+2a1T+2a4T4=6x1−4dx1T+ddx1T2  ⟺  a3=3x1−2dx1T+0.5ddx1T2−3a0−a1TT4  ⟺  a3=3x1−2dx1T+0.5ddx1T2−3x0−dx0TT4  ⟺  a3=0.5ddx1T2−2(dx1−dx0)T+3(x1−x0−dx0T)T4\\begin{aligned}\n6a_0 + 6a_1T + 6a_2T^2 + 6a_3T^3 + 6a_4T^4 &amp; = 6x_1 \\\\\n4a_1T + 8a_2T^2 + 12a_3T^3 + 16a_4T^4 &amp; = 4dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 &amp; = ddx_1T^2 \\\\\n\\iff 6a_0 + 2a_1T + 2a_4T^4 &amp; = 6x_1 - 4dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{3x_1 - 2dx_1T + 0.5ddx_1T^2-3a_0 -a_1T}{T^4} \\\\\n\\iff a_3 &amp; = \\frac{3x_1 - 2dx_1T + 0.5ddx_1T^2-3x_0 -dx_0T}{T^4} \\\\\n\\iff a_3 &amp; = \\frac{0.5ddx_1T^2 - 2(dx_1-dx_0)T + 3(x_1-x_0-dx_0T)}{T^4} \\\\\n\\end{aligned}\n6a0​+6a1​T+6a2​T2+6a3​T3+6a4​T44a1​T+8a2​T2+12a3​T3+16a4​T42a2​T2+6a3​T3+12a4​T4⟺6a0​+2a1​T+2a4​T4⟺a3​⟺a3​⟺a3​​=6x1​=4dx1​T=ddx1​T2=6x1​−4dx1​T+ddx1​T2=T43x1​−2dx1​T+0.5ddx1​T2−3a0​−a1​T​=T43x1​−2dx1​T+0.5ddx1​T2−3x0​−dx0​T​=T40.5ddx1​T2−2(dx1​−dx0​)T+3(x1​−x0​−dx0​T)​​\nQuarticPolynomialCurve1d&amp; QuarticPolynomialCurve1d::FitWithEndPointSecondOrder(    const double x0, const double dx0, const double x1, const double dx1,    const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  param_ = p;  coef_[0] = x0;  coef_[1] = dx0;  double p2 = p * p;  double p3 = p2 * p;  double p4 = p3 * p;  double b0 = x1 - coef_[0] - coef_[1] * p;  double b1 = dx1 - coef_[1];  double c1 = b1 * p;  double c2 = ddx1 * p2;  coef_[2] = (0.5 * c2 - 3 * c1 + 6 * b0) / p2;  coef_[3] = (-c2 + 5 * c1 - 8 * b0) / p3;  coef_[4] = (0.5 * c2 - 2 * c1 + 3 * b0) / p4;  return *this;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble QuarticPolynomialCurve1d::Evaluate(const std::uint32_t order,                                          const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return (((coef_[4] * p + coef_[3]) * p + coef_[2]) * p + coef_[1]) * p +             coef_[0];    &#125;    case 1: &#123;      return ((4.0 * coef_[4] * p + 3.0 * coef_[3]) * p + 2.0 * coef_[2]) * p +             coef_[1];    &#125;    case 2: &#123;      return (12.0 * coef_[4] * p + 6.0 * coef_[3]) * p + 2.0 * coef_[2];    &#125;    case 3: &#123;      return 24.0 * coef_[4] * p + 6.0 * coef_[3];    &#125;    case 4: &#123;      return 24.0 * coef_[4];    &#125;    default:      return 0.0;  &#125;&#125;\n 五次曲线–&gt;quintic polynomial curve1d\nQuinticPolynomialCurve1d::QuinticPolynomialCurve1d(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double ddx1, const double param) &#123;  ComputeCoefficients(x0, dx0, ddx0, x1, dx1, ddx1, param);  start_condition_[0] = x0;  start_condition_[1] = dx0;  start_condition_[2] = ddx0;  end_condition_[0] = x1;  end_condition_[1] = dx1;  end_condition_[2] = ddx1;  param_ = param;&#125;\ns(t)=a0+a1t+a2t2+a3t3+a4t4+a5t5s(t)=a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4 + a_5t^5\ns(t)=a0​+a1​t+a2​t2+a3​t3+a4​t4+a5​t5\n{a0=x0a1=dx0a2=ddx02a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TTa5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{cases}{}\na_0 = x_0 \\\\ \na_1 = dx_0 \\\\\na_2 = \\frac{ddx_0}{2} \\\\\na_3 = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\na_4 =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\na_5 =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{cases}\n⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​a0​=x0​a1​=dx0​a2​=2ddx0​​a3​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)a4​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​a5​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n入参初始条件\ns(0)=a0=x0  ⟺  a0=x0s′(0)=a1=dx0  ⟺  a1=dx0s′′(0)=2a2=ddx0  ⟺  a2=ddx02\\begin{aligned}\ns(0) = a_0 = x_0 \\iff a_0 = x_0 \\\\ \ns&#x27;(0) = a_1 = dx_0 \\iff a_1 = dx_0 \\\\\ns&#x27;&#x27;(0) = 2a_2 = ddx_0 \\iff a_2 = \\frac{ddx_0}{2} \\\\\n\\end{aligned}\ns(0)=a0​=x0​⟺a0​=x0​s′(0)=a1​=dx0​⟺a1​=dx0​s′′(0)=2a2​=ddx0​⟺a2​=2ddx0​​​\ns(T)=a0+a1T+a2T2+a3T3+a4T4+a5T5=x1(8)s(T) = a_0 + a_1T + a_2T^2 + a_3T^3 + a_4T^4 + a_5T^5 = x_1\\tag 8\ns(T)=a0​+a1​T+a2​T2+a3​T3+a4​T4+a5​T5=x1​(8)\ns′(T)=a1+2a2T+3a3T2+4a4T3+5a5T4=dx1(9)s&#x27;(T) = a_1 + 2a_2T + 3a_3T^2 + 4a_4T^3 + 5a_5T^4 = dx_1 \\tag 9\ns′(T)=a1​+2a2​T+3a3​T2+4a4​T3+5a5​T4=dx1​(9)\ns′′(T)=2a2+6a3T+12a4T2+20a5T3=ddx1(10)s&#x27;&#x27;(T) = 2a_2 + 6a_3T + 12a_4T^2 + 20a_5T^3 = ddx_1 \\tag{10}\ns′′(T)=2a2​+6a3​T+12a4​T2+20a5​T3=ddx1​(10)\n公式20*(8)-5*T*(9)+T*T*(10)得：\n20a0+20a1T+20a2T2+20a3T3+20a4T4+20a5T5=20x18a1T+16a2T2+24a3T3+32a4T4+40a5T5=8dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  20a0+12a1T+6a2T2+2a3T3=20x1−8dx1T+ddx1T2  ⟺  a3=20x1−8dx1T+ddx1T2−20a0−12a1T−6a2T22T3  ⟺  a3=20x1−8dx1T+ddx1T2−20x0−12dx0T−3ddx0T22T3  ⟺  a3=0.5∗(20x1−0.5ddx0T2−dx0T−x0T3−8dx1−ddx0T−dx0T2+ddx1−ddx0T)\\begin{aligned}\n20a_0 + 20a_1T + 20a_2T^2 + 20a_3T^3 + 20a_4T^4 + 20a_5T^5 &amp; = 20x_1 \\\\\n8a_1T + 16a_2T^2 + 24a_3T^3 + 32a_4T^4 + 40a_5T^5 &amp; = 8dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 20a_0 + 12a_1T + 6a_2T^2 + 2a_3T^3&amp; = 20x_1 - 8dx_1T + ddx_1T^2 \\\\\n\\iff a_3 &amp; = \\frac{20x_1 - 8dx_1T + ddx_1T^2 - 20a_0 - 12a_1T - 6a_2T^2}{2T^3} \\\\\n\\iff a_3 &amp; = \\frac{20x_1 - 8dx_1T + ddx_1T^2 - 20x_0 - 12dx_0T - 3ddx_0T^2}{2T^3} \\\\\n\\iff a_3 &amp; = 0.5*(20\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} -8\\frac{dx_1-ddx_0T-dx_0}{T^2} + \\frac{ddx_1-ddx_0}{T}) \\\\\n\\end{aligned}\n20a0​+20a1​T+20a2​T2+20a3​T3+20a4​T4+20a5​T58a1​T+16a2​T2+24a3​T3+32a4​T4+40a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺20a0​+12a1​T+6a2​T2+2a3​T3⟺a3​⟺a3​⟺a3​​=20x1​=8dx1​T=ddx1​T2=20x1​−8dx1​T+ddx1​T2=2T320x1​−8dx1​T+ddx1​T2−20a0​−12a1​T−6a2​T2​=2T320x1​−8dx1​T+ddx1​T2−20x0​−12dx0​T−3ddx0​T2​=0.5∗(20T3x1​−0.5ddx0​T2−dx0​T−x0​​−8T2dx1​−ddx0​T−dx0​​+Tddx1​−ddx0​​)​\n提示：逆推一下得证。\n公式15*(8)-7*T*(9)+T*T*(10)得：\n15a0+15a1T+15a2T2+15a3T3+15a4T4+15a5T5=15x17a1T+14a2T2+21a3T3+28a4T4+35a5T5=7dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  15a0+8a1T+3a2T2−a4T4=15x1−7dx1T+ddx1T2  ⟺  a4=15a0+8a1T+3a2T2−15x1+7dx1T−ddx1T2T4  ⟺  a4=15x0+8dx0T+3ddx02T2−15x1+7dx1T−ddx1T2T4  ⟺  a4=−15x1−0.5ddx0T2−dx0T−x0T3+7dx1−ddx0T−dx0T2−ddx1−ddx0TT\\begin{aligned}\n15a_0 + 15a_1T + 15a_2T^2 + 15a_3T^3 + 15a_4T^4 + 15a_5T^5 &amp; = 15x_1 \\\\\n7a_1T + 14a_2T^2 + 21a_3T^3 + 28a_4T^4 + 35a_5T^5 &amp; = 7dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 15a_0 + 8a_1T + 3a_2T^2 - a_4T^4&amp; = 15x_1 - 7dx_1T + ddx_1T^2 \\\\\n\\iff a_4 &amp; = \\frac{15a_0 + 8a_1T + 3a_2T^2 - 15x_1 + 7dx_1T - ddx_1T^2}{T^4} \\\\\n\\iff a_4 &amp; = \\frac{15x_0 + 8dx_0T + 3\\frac{ddx_0}{2}T^2 - 15x_1 + 7dx_1T - ddx_1T^2}{T^4} \\\\\n\\iff a_4 &amp; =\\frac{-15\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} + 7\\frac{dx_1-ddx_0T-dx_0}{T^2} - \\frac{ddx_1-ddx_0}{T}}{T} \\\\\n\\end{aligned}\n15a0​+15a1​T+15a2​T2+15a3​T3+15a4​T4+15a5​T57a1​T+14a2​T2+21a3​T3+28a4​T4+35a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺15a0​+8a1​T+3a2​T2−a4​T4⟺a4​⟺a4​⟺a4​​=15x1​=7dx1​T=ddx1​T2=15x1​−7dx1​T+ddx1​T2=T415a0​+8a1​T+3a2​T2−15x1​+7dx1​T−ddx1​T2​=T415x0​+8dx0​T+32ddx0​​T2−15x1​+7dx1​T−ddx1​T2​=T−15T3x1​−0.5ddx0​T2−dx0​T−x0​​+7T2dx1​−ddx0​T−dx0​​−Tddx1​−ddx0​​​​\n提示：逆推一下得证。\n公式12*(8)-6*T*(9)+T*T*(10)得：\n12a0+12a1T+12a2T2+12a3T3+12a4T4+12a5T5=12x16a1T+12a2T2+18a3T3+24a4T4+30a5T5=6dx1T2a2T2+6a3T3+12a4T4+20a5T5=ddx1T2  ⟺  12a0+6a1T+2a2T2+2a5T5=12x1−6dx1T+ddx1T2  ⟺  a5=12x1−6dx1T+ddx1T2−12a0−6a1T−2a2T22T5  ⟺  a5=12x1−6dx1T+ddx1T2−12x0−6dx0T−ddx0T22T5  ⟺  a5=6x1−0.5ddx0T2−dx0T−x0T3−3dx1−ddx0T−dx0T2+0.5ddx1−ddx0TT2\\begin{aligned}\n12a_0 + 12a_1T + 12a_2T^2 + 12a_3T^3 + 12a_4T^4 + 12a_5T^5 &amp; = 12x_1 \\\\\n6a_1T + 12a_2T^2 + 18a_3T^3 + 24a_4T^4 + 30a_5T^5 &amp; = 6dx_1T \\\\\n2a_2T^2 + 6a_3T^3 + 12a_4T^4 + 20a_5T^5&amp; = ddx_1T^2 \\\\\n\\iff 12a_0 + 6a_1T + 2a_2T^2 + 2a_5T^5&amp; = 12x_1 - 6dx_1T + ddx_1T^2 \\\\\n\\iff a_5 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12a_0 - 6a_1T - 2a_2T^2}{2T^5} \\\\\n\\iff a_5 &amp; = \\frac{12x_1 - 6dx_1T + ddx_1T^2 - 12x_0 - 6dx_0T - ddx_0T^2}{2T^5} \\\\\n\\iff a_5 &amp; =\\frac{6\\frac{x_1-0.5ddx_0T^2-dx_0T-x_0}{T^3} - 3\\frac{dx_1-ddx_0T-dx_0}{T^2} + 0.5\\frac{ddx_1-ddx_0}{T}}{T^2} \\\\\n\\end{aligned}\n12a0​+12a1​T+12a2​T2+12a3​T3+12a4​T4+12a5​T56a1​T+12a2​T2+18a3​T3+24a4​T4+30a5​T52a2​T2+6a3​T3+12a4​T4+20a5​T5⟺12a0​+6a1​T+2a2​T2+2a5​T5⟺a5​⟺a5​⟺a5​​=12x1​=6dx1​T=ddx1​T2=12x1​−6dx1​T+ddx1​T2=2T512x1​−6dx1​T+ddx1​T2−12a0​−6a1​T−2a2​T2​=2T512x1​−6dx1​T+ddx1​T2−12x0​−6dx0​T−ddx0​T2​=T26T3x1​−0.5ddx0​T2−dx0​T−x0​​−3T2dx1​−ddx0​T−dx0​​+0.5Tddx1​−ddx0​​​​\n提示：逆推一下得证。\nvoid QuinticPolynomialCurve1d::ComputeCoefficients(    const double x0, const double dx0, const double ddx0, const double x1,    const double dx1, const double ddx1, const double p) &#123;  CHECK_GT(p, 0.0);  coef_[0] = x0;  coef_[1] = dx0;  coef_[2] = ddx0 / 2.0;  const double p2 = p * p;  const double p3 = p * p2;  // the direct analytical method is at least 6 times faster than using matrix  // inversion.  const double c0 = (x1 - 0.5 * p2 * ddx0 - dx0 * p - x0) / p3;  const double c1 = (dx1 - ddx0 * p - dx0) / p2;  const double c2 = (ddx1 - ddx0) / p;  coef_[3] = 0.5 * (20.0 * c0 - 8.0 * c1 + c2);  coef_[4] = (-15.0 * c0 + 7.0 * c1 - c2) / p;  coef_[5] = (6.0 * c0 - 3.0 * c1 + 0.5 * c2) / p2;&#125;\nCubicPolynomialCurve1d::Evaluate()是计算几阶导数的值。\ndouble QuinticPolynomialCurve1d::Evaluate(const uint32_t order,                                          const double p) const &#123;  switch (order) &#123;    case 0: &#123;      return ((((coef_[5] * p + coef_[4]) * p + coef_[3]) * p + coef_[2]) * p +              coef_[1]) *                 p +             coef_[0];    &#125;    case 1: &#123;      return (((5.0 * coef_[5] * p + 4.0 * coef_[4]) * p + 3.0 * coef_[3]) * p +              2.0 * coef_[2]) *                 p +             coef_[1];    &#125;    case 2: &#123;      return (((20.0 * coef_[5] * p + 12.0 * coef_[4]) * p) + 6.0 * coef_[3]) *                 p +             2.0 * coef_[2];    &#125;    case 3: &#123;      return (60.0 * coef_[5] * p + 24.0 * coef_[4]) * p + 6.0 * coef_[3];    &#125;    case 4: &#123;      return 120.0 * coef_[5] * p + 24.0 * coef_[4];    &#125;    case 5: &#123;      return 120.0 * coef_[5];    &#125;    default:      return 0.0;  &#125;&#125;\n","categories":["Apollo源码解读"]},{"title":"Apollo r5.5.0 代码解读之积分(Integral)","url":"/2022/09/26/Apollo%20r5.5.0%20%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E7%A7%AF%E5%88%86(Integral)/","content":"解读integral.h integral.cc文件。\n\n 简介\nI=∫abf(x)dxI=\\int_{a}^{b}f(x)dx \\quad\nI=∫ab​f(x)dx\n只要找到被积公式的原函数F(x)F(x)F(x)，利用牛顿-莱布尼兹公式有：\n∫abf(x)dx=F(b)−F(a)\\int_{a}^{b}f(x)dx=F(b)-F(a)\n∫ab​f(x)dx=F(b)−F(a)\n还可以使用分割法，分割成无穷多个小区间：\n∫abf(x)dx=lim⁡x→∞∑i=1nb−anf(a+b−ani)\\int_{a}^{b}f(x)dx=\\lim_{x \\to \\infty}\\sum_{i=1}^{n}\\frac{b-a}{n}f(a+\\frac{b-a}{n}i)\n∫ab​f(x)dx=x→∞lim​i=1∑n​nb−a​f(a+nb−a​i)\n此外，可以使用数值积分。\n 数值积分：\n 高斯勒让德积分公式(GaussLegendre)\n 理论\n∫abf(x)dx≈∑k=0nAkf(xk)\\int_{a}^{b}f(x)dx\\approx \\sum_{k=0}^{n}A_kf(x_k)\n∫ab​f(x)dx≈k=0∑n​Ak​f(xk​)\n高斯–勒让德求积公式是构造高精度差值积分的最好方法之一。他是通过让节点和积分系数待定让函数f(x)f(x)f(x)以此取i=0,1,2...ni=0,1,2 ...ni=0,1,2...n次多项式使其尽可能多的能够精确成立来求出积分节点和积分系数。高斯积分的代数精度是2n−12n-12n−1，而且是最高的。通常的运用的是(−1,1)(-1,1)(−1,1)的积分节点和积分系数，其他积分域是通过变换公式x=(b−a)∗t/2+(b+a)/2x=(b-a)*t/2+(b+a)/2x=(b−a)∗t/2+(b+a)/2变换到-1到1之间积分。t∈(−1,1)t \\in (-1,1)t∈(−1,1)\nf(x)x∈(a,b)f(x) \\quad x\\in(a,b) \nf(x)x∈(a,b)\nx=(b−a)∗t/2+(b+a)/2t∈(−1,1)x=(b-a)*t/2+(b+a)/2 \\quad t\\in(-1,1)\nx=(b−a)∗t/2+(b+a)/2t∈(−1,1)\n⇔f((b−a)∗t/2+(b+a)/2)t∈(−1,1)\\Leftrightarrow\nf((b-a)*t/2+(b+a)/2) \\quad t\\in(-1,1)\n⇔f((b−a)∗t/2+(b+a)/2)t∈(−1,1)\n⇔g(t)t∈(−1,1)\\Leftrightarrow\ng(t) \\quad t\\in(-1,1)\n⇔g(t)t∈(−1,1)\n∫abf(x)dx=b−a2∫−11f((b−a)∗t/2+(b+a)/2)dt=b−a2∫−11g(t)dt\\int_{a}^{b}f(x)dx= \\frac{b-a}{2}\\int_{-1}^{1}f((b-a)*t/2+(b+a)/2)dt = \\frac{b-a}{2}\\int_{-1}^{1}g(t)dt\n∫ab​f(x)dx=2b−a​∫−11​f((b−a)∗t/2+(b+a)/2)dt=2b−a​∫−11​g(t)dt\n最终使用的标准形式：\n∫−11f(x)dx≈∑k=0nAkf(xk)\\int_{-1}^{1}f(x)dx\\approx \\sum_{k=0}^{n}A_kf(x_k)\n∫−11​f(x)dx≈k=0∑n​Ak​f(xk​)\ne.g.n=4e.g. \\quad n=4\ne.g.n=4\n∫−11f(x)dx≈A0f(x0)+A1f(x1)+A2f(x2)+A3f(x3)+A4f(x4)\\int_{-1}^{1}f(x)dx\\approx A_0f(x_0) + A_1f(x_1) + A_2f(x_2) + A_3f(x_3) + A_4f(x_4) \n∫−11​f(x)dx≈A0​f(x0​)+A1​f(x1​)+A2​f(x2​)+A3​f(x3​)+A4​f(x4​)\n有五组(n+1)(n+1)(n+1)系数(xk,Ak)(x_k, A_k)(xk​,Ak​)\n下表列出高斯–勒让德求积公式的节点和系数\n\n\n\nn\nxkx_kxk​\nAkA_kAk​\n\n\n\n\n0\n0.00.00.0\n2.02.02.0\n\n\n1\n±0.577350269189625764507\\pm 0.577350269189625764507±0.577350269189625764507\n1.01.01.0\n\n\n2\n0.00.00.0±0.774596669241483377010\\pm 0.774596669241483377010±0.774596669241483377010\n0.8888888888888888888770.8888888888888888888770.8888888888888888888770.5555555555555555555620.5555555555555555555620.555555555555555555562\n\n\n3\n±0.339981043584856264792\\pm 0.339981043584856264792±0.339981043584856264792±0.861136311594052575248\\pm 0.861136311594052575248±0.861136311594052575248\n0.6521451548625461426440.6521451548625461426440.6521451548625461426440.3478548451374538573830.3478548451374538573830.347854845137453857383\n\n\n4\n0.00.00.0±0.538469310105683091018\\pm 0.538469310105683091018±0.538469310105683091018±0.906179845938663992811\\pm 0.906179845938663992811±0.906179845938663992811\n0.5688888888888888888830.5688888888888888888830.5688888888888888888830.4786286704993664680300.4786286704993664680300.4786286704993664680300.2369268850561890875150.2369268850561890875150.236926885056189087515\n\n\n5\n±0.661209386466264513688\\pm 0.661209386466264513688±0.661209386466264513688±0.238619186083196908630\\pm 0.238619186083196908630±0.238619186083196908630±0.932469514203152027832\\pm 0.932469514203152027832±0.932469514203152027832\n0.3607615730481386075690.3607615730481386075690.3607615730481386075690.4679139345726910473890.4679139345726910473890.4679139345726910473890.1713244923791703450430.1713244923791703450430.171324492379170345043\n\n\n6\n0.00.00.0±0.405845151377397166917\\pm 0.405845151377397166917±0.405845151377397166917±0.741531185599394439864\\pm 0.741531185599394439864±0.741531185599394439864±0.949107912342758524541\\pm 0.949107912342758524541±0.949107912342758524541\n0.4179591836734693877490.4179591836734693877490.4179591836734693877490.3818300505051189449610.3818300505051189449610.3818300505051189449610.2797053914892766678900.2797053914892766678900.2797053914892766678900.1294849661688696932740.1294849661688696932740.129484966168869693274\n\n\n7\n±0.183434642495649804936\\pm 0.183434642495649804936±0.183434642495649804936±0.525532409916328985830\\pm 0.525532409916328985830±0.525532409916328985830±0.796666477413626739567\\pm 0.796666477413626739567±0.796666477413626739567±0.960289856497536231661\\pm 0.960289856497536231661±0.960289856497536231661\n0.3626837833783619829760.3626837833783619829760.3626837833783619829760.3137066458778872873380.3137066458778872873380.3137066458778872873380.2223810344533744705460.2223810344533744705460.2223810344533744705460.1012285362903762591540.1012285362903762591540.101228536290376259154\n\n\n8\n0.00.00.0±0.836031107326635794313\\pm 0.836031107326635794313±0.836031107326635794313±0.968160239507626089810\\pm 0.968160239507626089810±0.968160239507626089810±0.324253423403808929042\\pm 0.324253423403808929042±0.324253423403808929042±0.613371432700590397285\\pm 0.613371432700590397285±0.613371432700590397285\n0.3302393550012597631540.3302393550012597631540.3302393550012597631540.1806481606948574040590.1806481606948574040590.1806481606948574040590.8127438836157441197370.8127438836157441197370.8127438836157441197370.3123470770400028400570.3123470770400028400570.3123470770400028400570.2606106964029354623130.2606106964029354623130.260610696402935462313\n\n\n9\n±0.148874338981631210881\\pm 0.148874338981631210881±0.148874338981631210881±0.433395394129247190794\\pm 0.433395394129247190794±0.433395394129247190794±0.679409568299024406207\\pm 0.679409568299024406207±0.679409568299024406207±0.865063366688984510759\\pm 0.865063366688984510759±0.865063366688984510759±0.973906528517171720066\\pm 0.973906528517171720066±0.973906528517171720066\n0.2955242247147528701870.2955242247147528701870.2955242247147528701870.2692667193099963551050.2692667193099963551050.2692667193099963551050.2190863625159820440000.2190863625159820440000.2190863625159820440000.1494513491505805931500.1494513491505805931500.1494513491505805931500.6667134430868813759200.6667134430868813759200.666713443086881375920\n\n\n\n 代码实现\n/** * @brief Compute the integral of a target single-variable function *        from a lower bound to an upper bound, by 5-th Gauss-Legendre method * Given a target function and integral lower and upper bound, * compute the integral approximation using 5th order Gauss-Legendre * integration. * The target function must be a smooth function. * Example: * target function: auto func = [](const double x) &#123;return x * x;&#125;; *                  double integral = gauss_legendre(func, -2, 3); * This gives you the approximated integral of function x^2 in bound [-2, 3] * * reference: https://en.wikipedia.org/wiki/Gaussian_quadrature *            http://www.mymathlib.com/quadrature/gauss_legendre.html * * @param func The target single-variable function * @param lower_bound The lower bound of the integral * @param upper_bound The upper bound of the integral * @return The integral result */template &lt;std::size_t N&gt;double IntegrateByGaussLegendre(const std::function&lt;double(double)&gt;&amp; func,                                const double lower_bound,                                const double upper_bound) &#123;  // 根据输入阶数，获取对应系数，这里N对应上表的n+1  // Apollo提供了N从2到10，也就是上表n从1到9  auto p = GetGaussLegendrePoints&lt;N&gt;();  std::array&lt;double, N&gt; x = p.first;  std::array&lt;double, N&gt; w = p.second;  // 复化系数  const double t = (upper_bound - lower_bound) * 0.5;  const double m = (upper_bound + lower_bound) * 0.5;  double integral = 0.0;  for (size_t i = 0; i &lt; N; ++i) &#123;    // 逐一累加各项和    integral += w[i] * func(t * x[i] + m);  &#125;  // 注意还乘t  return integral * t;&#125;/** * @brief Get the points and weights for different ordered Gauss-Legendre *        integration. Currently support order 2 - 10. Other input order will *        trigger compiling error. */template &lt;std::size_t N&gt;std::pair&lt;std::array&lt;double, N&gt;, std::array&lt;double, N&gt;&gt;GetGaussLegendrePoints();template &lt;&gt;inline std::pair&lt;std::array&lt;double, 2&gt;, std::array&lt;double, 2&gt;&gt;GetGaussLegendrePoints&lt;2&gt;() &#123;  std::array&lt;double, 2&gt; x;  x[0] = -5.77350269189625764507e-01;  x[1] = 5.77350269189625764507e-01;  std::array&lt;double, 2&gt; w;  w[0] = 1.0;  w[1] = 1.0;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 3&gt;, std::array&lt;double, 3&gt;&gt;GetGaussLegendrePoints&lt;3&gt;() &#123;  std::array&lt;double, 3&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 7.74596669241483377010e-01;  x[2] = -7.74596669241483377010e-01;  std::array&lt;double, 3&gt; w;  w[0] = 8.88888888888888888877e-01;  w[1] = 5.55555555555555555562e-01;  w[2] = 5.55555555555555555562e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 4&gt;, std::array&lt;double, 4&gt;&gt;GetGaussLegendrePoints&lt;4&gt;() &#123;  std::array&lt;double, 4&gt; x;  x[0] = 3.39981043584856264792e-01;  x[1] = -3.39981043584856264792e-01;  x[2] = 8.61136311594052575248e-01;  x[3] = -8.61136311594052575248e-01;  std::array&lt;double, 4&gt; w;  w[0] = 6.52145154862546142644e-01;  w[1] = 6.52145154862546142644e-01;  w[2] = 3.47854845137453857383e-01;  w[3] = 3.47854845137453857383e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 5&gt;, std::array&lt;double, 5&gt;&gt;GetGaussLegendrePoints&lt;5&gt;() &#123;  std::array&lt;double, 5&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 5.38469310105683091018e-01;  x[2] = -5.38469310105683091018e-01;  x[3] = 9.06179845938663992811e-01;  x[4] = -9.06179845938663992811e-01;  std::array&lt;double, 5&gt; w;  w[0] = 5.68888888888888888883e-01;  w[1] = 4.78628670499366468030e-01;  w[2] = 4.78628670499366468030e-01;  w[3] = 2.36926885056189087515e-01;  w[4] = 2.36926885056189087515e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 6&gt;, std::array&lt;double, 6&gt;&gt;GetGaussLegendrePoints&lt;6&gt;() &#123;  std::array&lt;double, 6&gt; x;  x[0] = 6.61209386466264513688e-01;  x[1] = -6.61209386466264513688e-01;  x[2] = 2.38619186083196908630e-01;  x[3] = -2.38619186083196908630e-01;  x[4] = 9.32469514203152027832e-01;  x[5] = -9.32469514203152027832e-01;  std::array&lt;double, 6&gt; w;  w[0] = 3.60761573048138607569e-01;  w[1] = 3.60761573048138607569e-01;  w[2] = 4.67913934572691047389e-01;  w[3] = 4.67913934572691047389e-01;  w[4] = 1.71324492379170345043e-01;  w[5] = 1.71324492379170345043e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 7&gt;, std::array&lt;double, 7&gt;&gt;GetGaussLegendrePoints&lt;7&gt;() &#123;  std::array&lt;double, 7&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 4.05845151377397166917e-01;  x[2] = -4.05845151377397166917e-01;  x[3] = 7.41531185599394439864e-01;  x[4] = -7.41531185599394439864e-01;  x[5] = 9.49107912342758524541e-01;  x[6] = -9.49107912342758524541e-01;  std::array&lt;double, 7&gt; w;  w[0] = 4.17959183673469387749e-01;  w[1] = 3.81830050505118944961e-01;  w[2] = 3.81830050505118944961e-01;  w[3] = 2.79705391489276667890e-01;  w[4] = 2.79705391489276667890e-01;  w[5] = 1.29484966168869693274e-01;  w[6] = 1.29484966168869693274e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 8&gt;, std::array&lt;double, 8&gt;&gt;GetGaussLegendrePoints&lt;8&gt;() &#123;  std::array&lt;double, 8&gt; x;  x[0] = 1.83434642495649804936e-01;  x[1] = -1.83434642495649804936e-01;  x[2] = 5.25532409916328985830e-01;  x[3] = -5.25532409916328985830e-01;  x[4] = 7.96666477413626739567e-01;  x[5] = -7.96666477413626739567e-01;  x[6] = 9.60289856497536231661e-01;  x[7] = -9.60289856497536231661e-01;  std::array&lt;double, 8&gt; w;  w[0] = 3.62683783378361982976e-01;  w[1] = 3.62683783378361982976e-01;  w[2] = 3.13706645877887287338e-01;  w[3] = 3.13706645877887287338e-01;  w[4] = 2.22381034453374470546e-01;  w[5] = 2.22381034453374470546e-01;  w[6] = 1.01228536290376259154e-01;  w[7] = 1.01228536290376259154e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 9&gt;, std::array&lt;double, 9&gt;&gt;GetGaussLegendrePoints&lt;9&gt;() &#123;  std::array&lt;double, 9&gt; x;  x[0] = 0.00000000000000000000e+00;  x[1] = 8.36031107326635794313e-01;  x[2] = -8.36031107326635794313e-01;  x[3] = 9.68160239507626089810e-01;  x[4] = -9.68160239507626089810e-01;  x[5] = 3.24253423403808929042e-01;  x[6] = -3.24253423403808929042e-01;  x[7] = 6.13371432700590397285e-01;  x[8] = -6.13371432700590397285e-01;  std::array&lt;double, 9&gt; w;  w[0] = 3.30239355001259763154e-01;  w[1] = 1.80648160694857404059e-01;  w[2] = 1.80648160694857404059e-01;  w[3] = 8.12743883615744119737e-02;  w[4] = 8.12743883615744119737e-02;  w[5] = 3.12347077040002840057e-01;  w[6] = 3.12347077040002840057e-01;  w[7] = 2.60610696402935462313e-01;  w[8] = 2.60610696402935462313e-01;  return std::make_pair(x, w);&#125;template &lt;&gt;inline std::pair&lt;std::array&lt;double, 10&gt;, std::array&lt;double, 10&gt;&gt;GetGaussLegendrePoints&lt;10&gt;() &#123;  std::array&lt;double, 10&gt; x;  x[0] = 1.48874338981631210881e-01;  x[1] = -1.48874338981631210881e-01;  x[2] = 4.33395394129247190794e-01;  x[3] = -4.33395394129247190794e-01;  x[4] = 6.79409568299024406207e-01;  x[5] = -6.79409568299024406207e-01;  x[6] = 8.65063366688984510759e-01;  x[7] = -8.65063366688984510759e-01;  x[8] = 9.73906528517171720066e-01;  x[9] = -9.73906528517171720066e-01;  std::array&lt;double, 10&gt; w;  w[0] = 2.95524224714752870187e-01;  w[1] = 2.95524224714752870187e-01;  w[2] = 2.69266719309996355105e-01;  w[3] = 2.69266719309996355105e-01;  w[4] = 2.19086362515982044000e-01;  w[5] = 2.19086362515982044000e-01;  w[6] = 1.49451349150580593150e-01;  w[7] = 1.49451349150580593150e-01;  w[8] = 6.66713443086881375920e-02;  w[9] = 6.66713443086881375920e-02;  return std::make_pair(x, w);&#125;\n 梯形(Trapezoidal)求积公式\n 理论\n要求f(x)f(x)f(x)在[a,b][ a , b ][a,b]上的积分，将积分区间等长分成nnn段，则每两个分段点之间的距离h=b−anh=\\frac{b-a}{n}h=nb−a​，然后如下图进行近似：\n\n则该区间上的积分值就近似等同于每个小梯形的面积之和。\n第一个梯形（最左边）的上底f(x0)f(x_0)f(x0​)，下底f(x1)f(x_1)f(x1​)，高为h=b−anh=\\frac{b-a}{n}h=nb−a​，因此对应的面积为S1=(f(x0)+f(x1))∗h/2S_1=(f(x_0)+f(x_1))*h/2S1​=(f(x0​)+f(x1​))∗h/2。\n以此类推，最后一个（最右边）的上底f(xn−1)f(x_{n-1})f(xn−1​)，下底f(xn)f(x_n)f(xn​)，高为h=b−anh=\\frac{b-a}{n}h=nb−a​，因此对应的面积为Sn=(f(xn−1)+f(xn))∗h/2S_n=(f(x_{n-1})+f(x_n))*h/2Sn​=(f(xn−1​)+f(xn​))∗h/2。\n因此，所有梯形的总面积为：\n∫abf(x)dx≈∑i=1nSi=S1+S2+...+Sn=h/2[f(x0)+f(x1)+f(x1)+f(x2)+...+f(xn−2)+f(xn−1)+f(xn−1)+f(xn)]=h2[f(x0)+2∑i=1n−1f(xi)+f(xn)]=h∗∑i=1n−1f(xi)+0.5∗h(f(x0)+f(xn))\\begin{aligned}\n\\int_{a}^{b}f(x)dx \\approx \\sum_{i=1}^{n}S_i = S_1+S_2+...+S_n\n= h/2[f(x_0)+f(x_1)+f(x_1)+f(x_2)+...+f(x_{n-2})+f(x_{n-1})+f(x_{n-1})+f(x_n)] \\\\ \n= \\frac{h}{2}[f(x_0)+2\\sum_{i=1}^{n-1}f(x_i)+f(x_n)] \\\\\n= h*\\sum_{i=1}^{n-1}f(x_i)+0.5*h(f(x_0)+f(x_n))\n\\end{aligned}\n∫ab​f(x)dx≈i=1∑n​Si​=S1​+S2​+...+Sn​=h/2[f(x0​)+f(x1​)+f(x1​)+f(x2​)+...+f(xn−2​)+f(xn−1​)+f(xn−1​)+f(xn​)]=2h​[f(x0​)+2i=1∑n−1​f(xi​)+f(xn​)]=h∗i=1∑n−1​f(xi​)+0.5∗h(f(x0​)+f(xn​))​\n 代码实现\ndouble IntegrateByTrapezoidal(const std::vector&lt;double&gt;&amp; func, const double dx,                              const std::size_t nsteps) &#123;  // nsteps表示func集合元素的个数，也就是下标从0到nsteps-1，也就是意味着有nsteps-1个梯形  // 如参func为f(x_0)到f(x_&#123;nsteps-1&#125;)的集合，有nsteps个数，有nsteps-1个梯形  // dx就是步长(b-a)/(nsteps-1)，也就是公式里面的h  double sum = 0;  for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) &#123;    // 从i=1到i=nsteps-2的累加和    sum += func[i];  &#125;  return dx * sum + 0.5 * dx * (func[0] + func[nsteps - 1]);&#125;\n 辛普森(Simpson)求积公式\n 理论\n要求将区间划分成偶数个。\n\n辛普森积分法是一种用抛物线近似函数曲线来求定积分数值解的方法。把积分区间等分成若干段，对被积函数在每一段上使用辛普森公式，根据其在每一段的两端和中点处的值近似为抛物线，逐段积分后加起来，即得到原定积分的数值解。\n基本思想就是把复杂的函数f(x)f(x)f(x)近似成二次函数。\n∫abf(x)dx≈∫ab(Ax2+Bx+C)dx=A3(b3−a3)+B2(b2−a2)+C(b−a)=2A(b3−a3)+3B(b2−a2)+6C(b−a)6=(b−a)[2A(b2+ab+a2)+3B(b+a)+6C]6=(b−a)(Aa2+Ba+C+Ab2+Bb+C+Aa2+2Aab+Ab2+2Bb+2Ba+4C)6=(b−a)[f(a)+f(b)+A(a+b)2+2B(a+b)+4C]6=(b−a)[f(a)+f(b)+4(A(a+b2)2+Ba+b2+C)]6=(b−a)[f(a)+f(b)+4f(a+b2)]6\\begin{aligned}\n&amp;\\int_a^bf(x)dx \\approx \\int_a^b(Ax^2+Bx+C)dx \\\\\n&amp;=\\frac{A}{3}(b^3-a^3)+\\frac{B}{2}(b^2-a^2)+C(b-a) \\\\\n&amp;=\\frac{2A(b^3-a^3)+3B(b^2-a^2)+6C(b-a)}{6} \\\\\n&amp;=\\frac{(b-a)[2A(b^2+ab+a^2)+3B(b+a)+6C]}{6} \\\\\n&amp;=\\frac{(b-a)(Aa^2+Ba+C+Ab^2+Bb+C+Aa^2+2Aab+Ab^2+2Bb+2Ba+4C)}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+A(a+b)^2+2B(a+b)+4C]}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+4(A(\\frac{a+b}{2})^2+B\\frac{a+b}{2}+C)]}{6} \\\\\n&amp;=\\frac{(b-a)[f(a)+f(b)+4f(\\frac{a+b}{2})]}{6}\n\\end{aligned}\n​∫ab​f(x)dx≈∫ab​(Ax2+Bx+C)dx=3A​(b3−a3)+2B​(b2−a2)+C(b−a)=62A(b3−a3)+3B(b2−a2)+6C(b−a)​=6(b−a)[2A(b2+ab+a2)+3B(b+a)+6C]​=6(b−a)(Aa2+Ba+C+Ab2+Bb+C+Aa2+2Aab+Ab2+2Bb+2Ba+4C)​=6(b−a)[f(a)+f(b)+A(a+b)2+2B(a+b)+4C]​=6(b−a)[f(a)+f(b)+4(A(2a+b​)2+B2a+b​+C)]​=6(b−a)[f(a)+f(b)+4f(2a+b​)]​​\n先求定积分∫abf(x)dx(a&lt;b)\\int_a^bf(x)dx \\quad (a&lt;b)∫ab​f(x)dx(a&lt;b)\n将闭区间等分成2n2n2n，即偶数个小区间[xi,xi+1](xi&lt;xi+1,x0=a,x2n=b,i∈[0,2n])[x_i, x_{i+1}] \\quad (x_i&lt;x_{i+1},x_0=a,x_{2n}=b,i\\in[0,2n])[xi​,xi+1​](xi​&lt;xi+1​,x0​=a,x2n​=b,i∈[0,2n])。在每个小区间上，用抛物线近似函数f(x)f(x)f(x)的曲线。每个区间长度为b−a2n\\frac{b-a}{2n}2nb−a​。\n以两个区间为基本单位，基本单位长度为b−an\\frac{b-a}{n}nb−a​，使用辛普森公式近似求积分：\ne.g.∫x0x2f(x)dx≈(x2−x0)[f(x0)+f(x2)+4f(x1)]6=(b−a)6n[f(x0)+4f(x1)+f(x2)]e.g. \\quad \\int_{x_0}^{x_2} f(x)dx\\approx \\frac{(x_2-x_0)[f(x_0)+f(x_2)+4f(x_1)]}{6} \\\\\n= \\frac{(b-a)}{6n} [f(x_0)+4f(x_1)+f(x_2)]\\\\\ne.g.∫x0​x2​​f(x)dx≈6(x2​−x0​)[f(x0​)+f(x2​)+4f(x1​)]​=6n(b−a)​[f(x0​)+4f(x1​)+f(x2​)]\ne.g.∫x2n−2x2nf(x)dx≈(x2n−x2n−2)[f(x2n−2)+f(x2n)+4f(x2n−1)]6=(b−a)6n[f(x2n−2)+4f(x2n−1)+f(x2n)]e.g. \\quad \\int_{x_{2n-2}}^{x_{2n}} f(x)dx\\approx \\frac{(x_{2n}-x_{2n-2})[f(x_{2n-2})+f(x_{2n})+4f(x_{2n-1})]}{6} \\\\\n= \\frac{(b-a)}{6n} [f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n})]\\\\\ne.g.∫x2n−2​x2n​​f(x)dx≈6(x2n​−x2n−2​)[f(x2n−2​)+f(x2n​)+4f(x2n−1​)]​=6n(b−a)​[f(x2n−2​)+4f(x2n−1​)+f(x2n​)]\n所以累加全部基本单位，可得：\n∫abf(x)dx≈∫x0x2f(x)dx+∫x2x4f(x)dx+...+∫x2n−2x2nf(x)dx=b−a6n[f(x0)+4f(x1)+f(x2)+f(x2)+4f(x3)+f(x4)+...+f(x2n−2)+4f(x2n−1)+f(x2n)]=b−a3∗2n[f(x0)+f(x2n)+4[f(x1)+f(x3)+...+f(x2n−1)]+2[f(x2)+f(x4)+...+f(x2n−2)]]\\begin{aligned}\n\\int_a^bf(x)dx \\approx \\int_{x_0}^{x_2} f(x)dx+\\int_{x_2}^{x_4} f(x)dx+...+\\int_{x_{2n-2}}^{x_{2n}} f(x)dx \\\\\n=\\frac{b-a}{6n}[f(x_0)+4f(x_1)+f(x_2) + f(x_2)+4f(x_3)+f(x_4) + ... + f(x_{2n-2})+4f(x_{2n-1})+f(x_{2n})] \\\\\n=\\frac{b-a}{3*2n}[f(x_0)+f(x_{2n}) + 4[f(x_1)+f(x_3)+...+f(x_{2n-1})] + 2[f(x_2)+f(x_4)+...+f(x_{2n-2})]] \\\\\n\\end{aligned}\n∫ab​f(x)dx≈∫x0​x2​​f(x)dx+∫x2​x4​​f(x)dx+...+∫x2n−2​x2n​​f(x)dx=6nb−a​[f(x0​)+4f(x1​)+f(x2​)+f(x2​)+4f(x3​)+f(x4​)+...+f(x2n−2​)+4f(x2n−1​)+f(x2n​)]=3∗2nb−a​[f(x0​)+f(x2n​)+4[f(x1​)+f(x3​)+...+f(x2n−1​)]+2[f(x2​)+f(x4​)+...+f(x2n−2​)]]​\n 代码实现\ndouble IntegrateBySimpson(const std::vector&lt;double&gt;&amp; func, const double dx,                          const std::size_t nsteps) &#123;  // nsteps表示func集合元素的个数，也就是下标从0到nsteps-1，也就是意味着有nsteps-1个梯形  // 要求nsteps为奇数，也就是平分成偶数个梯形，nsteps-1个区间  // 如参func为f(x_0)到f(x_&#123;nsteps-1&#125;)的集合，有nsteps个数，有nsteps-1个梯形，即偶数个梯形  // dx就是步长(b-a)/(nsteps-1)，也就是每个区间的长度  CHECK_EQ(1, nsteps &amp; 1);  double sum1 = 0.0;  double sum2 = 0.0;  for (std::size_t i = 1; i + 1 &lt; nsteps; ++i) &#123;    if ((i &amp; 1) != 0) &#123;      // 奇数求和      sum1 += func[i];    &#125; else &#123;      // 偶数求和      sum2 += func[i];    &#125;  &#125;  return dx / 3.0 * (4.0 * sum1 + 2.0 * sum2 + func[0] + func[nsteps - 1]);&#125;\n 参考文献\n[1]https://blog.csdn.net/xyz32768/article/details/81392369\n[2]https://baike.baidu.com/item/辛普森积分法/23337870?fr=aladdin\n[3]https://blog.csdn.net/justidle/article/details/112839920\n[4]https://wenku.baidu.com/view/b3fc62d74b7302768e9951e79b89680203d86bb7.html\n[5]https://max.book118.com/html/2019/0414/7142125161002020.shtm\n","categories":["Apollo源码解读"]},{"title":"CyberRT自定义部署流程 之 从零搭建交叉编译Docker镜像","url":"/2025/07/08/CyberRT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E4%B9%8B%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91Docker%E9%95%9C%E5%83%8F/","content":"本文章主要提供思路，许多地方都可以根据自定义修改以适配自己的实际情况。\n\n 准备好目标平台的交叉编译工具\n存放在toolchains/文件夹下。\n这个根据自己项目需求，网上或者找厂家获取交叉编译工具。\n比如：\n\n 准备好依赖库\n 依赖库是二进制库\n存放在sysroot/文件夹下。\n最好一份是x86，一份是目标平台。\n\n 依赖库是源码\n以压缩包形式存放在thirdparty/tarball/文件夹下。\n\n CyberRT v9.0.0版本依赖库\n\n本人梳理了CyberRT v9.0.0版本的依赖库，并从下载地址以压缩包形式下载下来：\n\nfast-rtps-1.5.0\nFast-CDR源码地址\nFast-DDS/Fast-rtps源码地址\nncurses-6.4（源码压缩包）\nncurses源码地址\nutil-linux-2.39（源码压缩包）\nutil-linux源码地址\nglog（通过git拉取源码）源码地址\nnlohmann_json（通过git拉取源码）源码地址\npython源码压缩包地址\n\n 搭建Docker镜像\n 创建docker_release_xcyber.sh脚本\n该脚本用于一键创建镜像，bash docker_release_xcyber.sh。\n#!/usr/bin/env bash# 自定义镜像名字DOCKER_REGISTRY=i-nogIMAGE_REPO=nog-cyber-kitIMAGE_TAG=$&#123;1:-&quot;1.1.0&quot;&#125;PLATFORM_X86=x86PLATFORM_ORIN=orin# 镜像名称ORIN_IMAGE_REPO=$&#123;DOCKER_REGISTRY&#125;/$&#123;IMAGE_REPO&#125;/plat_$&#123;PLATFORM_ORIN&#125;_devTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;# 指定dockerfile文件DOCKERFILE_ORIN_XCYBER=$&#123;TOP_DIR&#125;/dockerfile/Dockerfile.orin.xcyber# 创建一个文件夹，专门用于docker镜像构建的上下文CYBER_KIT=$&#123;TOP_DIR&#125;/cyber-kitORIN_IMAGE_CONTEXT=$&#123;CYBER_KIT&#125;-$&#123;PLATFORM_ORIN&#125;# 在上下文中创建所需文件夹，用于存放库和工具链mkdir -p $&#123;ORIN_IMAGE_CONTEXT&#125;/&#123;sysroot,toolchains&#125;echo &quot;=== prepare cyber-kit files for x86 ... ===&quot;# 压缩已有的 x86 版本的系统库，并拷贝到上下文中cd $&#123;TOP_DIR&#125;/sysroottar czf $&#123;PLATFORM_X86&#125;.tar.gz $&#123;PLATFORM_X86&#125;cp $&#123;PLATFORM_X86&#125;.tar.gz $&#123;ORIN_IMAGE_CONTEXT&#125;/sysrootecho &quot;=== prepare cyber-kit files for x86 done ===&quot;echo &quot;=== prepare cyber-kit files for ORIN ... ===&quot;# 压缩已有的 orin 版本的系统库，并拷贝到上下文中cd $&#123;TOP_DIR&#125;/sysroottar czf $&#123;PLATFORM_ORIN&#125;.tar.gz $&#123;PLATFORM_ORIN&#125;mv $&#123;PLATFORM_ORIN&#125;.tar.gz $&#123;ORIN_IMAGE_CONTEXT&#125;/sysroot# 拷贝交叉编译工具链cp -r $&#123;TOP_DIR&#125;/&#123;cmake,scripts&#125; $&#123;ORIN_IMAGE_CONTEXT&#125;cp -r $&#123;TOP_DIR&#125;/toolchains/$&#123;PLATFORM_ORIN&#125; $&#123;ORIN_IMAGE_CONTEXT&#125;/toolchainsecho &quot;=== prepare cyber-kit files for ORIN done ===&quot;# 删除压缩包cd $&#123;TOP_DIR&#125;/sysrootrm *.gzecho &quot;=== build platform orin docker images ... ===&quot;# 基于dockerfile文件创建镜像docker build --network=host \\    --build-arg platform=$&#123;PLATFORM_ORIN&#125; \\    --build-arg plat_version_value=$&#123;IMAGE_TAG&#125; \\    # 同时打两个标签（版本号和latest）    -t $&#123;ORIN_IMAGE_REPO&#125;:$&#123;IMAGE_TAG&#125; -t $&#123;ORIN_IMAGE_REPO&#125;:latest \\    -f $DOCKERFILE_ORIN_XCYBER $ORIN_IMAGE_CONTEXTecho &quot;=== build platform orin docker images done ===&quot;# 创建镜像成功，删除上下文rm -rf $ORIN_IMAGE_CONTEXT\n 创建Dockerfile.orin.xcyber\n操作的内容都是在上下文里面。\nFROM ubuntu:20.04# 传入参数ARG platformARG plat_version_valueARG DEBIAN_FRONTEND=noninteractiveUSER root # 以下指令使用root权限# stage 1: install dev and debug tools# 安装必备的基础工具，根据实际需求需要RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends build-essential cmake \\    pkg-config flex bison autoconf m4 gdb sudo file ca-certificates lsb-release git vim \\    bash-completion &amp;&amp; update-ca-certificates &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libpng-dev libjpeg-dev \\    libopenblas-dev libeigen3-dev libtbb-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libavcodec-dev \\    libavformat-dev libswscale-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgstreamer1.0-dev \\    libgstreamer-plugins-base1.0-dev &amp;&amp; apt-get cleanRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgtk-3-0 librsvg2-2 libgvc6 \\    openscenegraph &amp;&amp; apt-get clean## Set a passwordless sudoer user# 创建一个无密码用户RUN adduser --disabled-password --gecos &quot;&quot; autometa &amp;&amp; usermod -aG sudo autometa &amp;&amp; \\    mkdir -p /etc/sudoers.d &amp;&amp; touch /etc/sudoers.d/nopasswd &amp;&amp; \\    echo &quot;autometa ALL=(ALL) NOPASSWD: ALL&quot; &gt; /etc/sudoers.d/nopasswd# fix LANG for displaying Chinese textRUN echo &quot;export LANG=C.UTF-8&quot; &gt;&gt; $&#123;HOME&#125;/.bashrc# stage 2: add cyber-kitRUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;mkdir -p /opt/cyber-kit/&#123;cmake,scripts,sysroot,toolchains&#125;&quot;]# 拷贝目标平台的工具链COPY toolchains /opt/cyber-kit/toolchains# 这里其实只拷贝 x86 的系统库ADD sysroot/$&#123;x86&#125;.tar.gz /opt/cyber-kit/sysrootADD sysroot/$&#123;platform&#125;.tar.gz /opt/cyber-kit/sysroot# setup toolchains# 拷贝工具链环境配置脚本，并执行，这里使用root权限COPY scripts/setup.sh /opt/cyber-kit/scripts# 主要就是配置环境变量，及解压目标平台的交叉编译工具链RUN /opt/cyber-kit/scripts/setup.sh# update cmake files &amp; scriptsCOPY cmake /opt/cyber-kit/cmakeCOPY scripts /opt/cyber-kit/scripts# setup env for user autometaUSER autometa# 使用用户权限，再执行一遍工具链环境配置脚本RUN /opt/cyber-kit/scripts/setup.sh# git config settings# 配置git命令简写RUN git config --global alias.ci commit &amp;&amp; \\    git config --global alias.co checkout &amp;&amp; \\    git config --global alias.br branch &amp;&amp; \\    git config --global alias.st status &amp;&amp; \\    git config --global alias.au add -u &amp;&amp; \\    git config --global alias.ca commit --amend &amp;&amp; \\    git config --global core.editor vim# set plat versionENV PLAT_VERSION &quot;$&#123;plat_version_value&#125;&quot;# docker start command or argsCMD [&quot;bash&quot;]\n\n\n由于拉取基础镜像要联网，有时不好拉取，所以可以把基础镜像先保存起来：\n  docker save -o ubuntu-20.04-base.tar ubuntu:20.04\n\n\n载入镜像\n  docker load -i ubuntu-20.04-base.tar\n\n\n 创建环境配置脚本setup.sh\n#!/usr/bin/env bashplatform_array=(all xavier rk356x orin cv22)usage()&#123;cat &lt;&lt; EOFUsage: $1 &lt;platform&gt;platform: [$&#123;platform_array[*]&#125;]EOF&#125;platform=$&#123;1:-&quot;all&quot;&#125;echo &quot;platform: $platform&quot;platform_valid=falsefor target in $&#123;platform_array[@]&#125;do    if [ x$target = x$platform ]; then        platform_valid=true    fidoneif ! $&#123;platform_valid&#125;; then    echo &quot;platform is not valid&quot;    usage $&#123;BASH_SOURCE[0]&#125;        if [ $0 = $&#123;BASH_SOURCE[0]&#125; ]; then        exit -1    else        return -1    fifiKIT_PATH=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;/ORIGIN_KIT_PATH=$CYBER_KIT_PATHecho &quot;New cyber kit path is : $&#123;KIT_PATH&#125;&quot;echo &quot;Origin cyber kit path is : $&#123;ORIGIN_KIT_PATH&#125;&quot;HOST_ARCH=$(arch)if [[ $&#123;KIT_PATH&#125; != $&#123;ORIGIN_KIT_PATH&#125; ]]; then    echo &quot;*** The Cyber Kit Path is not set or changed!, Now setting...&quot;    BASH_RC=$&#123;HOME&#125;/.bashrc    touch $BASH_RC    sed -i &#x27;/CYBER_KIT_PATH/d&#x27; $&#123;BASH_RC&#125;    echo &quot;export CYBER_KIT_PATH=$&#123;KIT_PATH&#125;&quot; &gt;&gt; $BASH_RC    if [ $&#123;HOST_ARCH&#125; = &quot;x86&quot; ]; then        echo &#x27;export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/bin&#x27; &gt;&gt; $BASH_RC        echo &#x27;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib&#x27; &gt;&gt; $BASH_RC        if [ $platform = &quot;orin&quot; ]; then            echo &#x27;export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/orin/bin&#x27; &gt;&gt; $BASH_RC            echo &#x27;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/orin/lib&#x27; &gt;&gt; $BASH_RC        fi    fi    source $BASH_RC    echo &quot;*** The Poseidon Kit Path env setting done&quot;fi# unpack and install different platform cross toolchains# check whether the tar file need to be unpackif [ $&#123;HOST_ARCH&#125; = &quot;aarch64&quot; ]; then    echo &quot;The host arch is : $&#123;HOST_ARCH&#125;, do not need to unpack cross compile toolchains.&quot;        if [ $0 = $&#123;BASH_SOURCE[0]&#125; ]; then        exit 0    else        return 0    fifiecho &quot;The host arch is : $&#123;HOST_ARCH&#125;, need to unpack cross compile toolchains.&quot;# orinORIN_GCC_NAME=aarch64--glibc--stable-finalORIN_TOOLCHAIN_FILE=$&#123;KIT_PATH&#125;/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;.tar.gzif [ -f $ORIN_TOOLCHAIN_FILE ] &amp;&amp; [[ $platform = &quot;all&quot; || $platform = &quot;orin&quot; ]]; then    if [ ! -d  /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125; ]; then        echo -e &quot;\\e[33m############### orin: unpack ###############\\e[0m&quot;        sudo mkdir -p /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;        sudo tar -xvf $ORIN_TOOLCHAIN_FILE -C /opt/toolchains/orin/$&#123;ORIN_GCC_NAME&#125;        echo -e &quot;\\e[33m############### orin: unpack done ###############\\e[0m&quot;    else        echo &quot;The orin platform cross compile toolchains is already exists.&quot;    fifi\n整个流程里首次配置环境变量 CYBER_KIT_PATH。\n# docker 容器里 $&#123;HOME&#125;/.bashrcexport CYBER_KIT_PATH=/opt/cyber-kit/export PATH=$&#123;PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/binexport LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib\n （交叉）编译依赖库\n创建build_thirdparty.sh用于编译所需依赖库。\n# 编译安装指定版本的依赖库bash build_thirdparty.sh x86bash build_thirdparty.sh orin\n#!/usr/bin/env bashset -o errexit# 这里是这两个依赖库为例GLOG_SOURCE=glog-0.4.0NLOHMANN_JSON_SOURCE=json-3.12.0target_array=(x86 rk356x orin)BUILD_TARGET=x86if [ $# -gt 0 ]; then    BUILD_TARGET=$1else    echo -e &quot;\\e[33m* target arch not given ($&#123;target_array[*]&#125;), use x86 as default!\\e[0m&quot;fitarget_valid=falsefor target in $&#123;target_array[@]&#125;do    if [ x$&#123;BUILD_TARGET&#125; = x$target ]; then        target_valid=true    fidoneif ! $&#123;target_valid&#125;; then    echo -e &quot;\\e[33m* target arch should be in ($&#123;target_array[*]&#125;)\\e[0m&quot;    exit -1fiecho &quot;* BUILD_TARGET=$&#123;BUILD_TARGET&#125;&quot;# 1 setup toolchainecho -e &quot;\\e[33m=== setup toolchain ===\\e[0m&quot;if $&#123;BUILD_TARGET&#125; = &quot;orin&quot; ]; then    COMPILER_PATH=/opt/toolchains/orin/aarch64--glibc--stable-final/bin    TARGET_HOST=aarch64-buildroot-linux-gnu    COMPILER_PREFIX=aarch64-linux-fiexport PATH=$&#123;COMPILER_PATH&#125;:$&#123;PATH&#125;export CROSS_COMPILE=$&#123;COMPILER_PREFIX&#125;# 2 build packagesecho -e &quot;\\e[33m=== build packages ===\\e[0m&quot;TOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;## 指定安装目录和目标平台的cmake文件export CYBER_KIT_PATH=/opt/cyber-kit/INSTALL_PREFIX=$&#123;CYBER_KIT_PATH&#125;sysroot/$BUILD_TARGETTOOLCHAIN_FILE=$&#123;CYBER_KIT_PATH&#125;cmake/sysroot/$&#123;BUILD_TARGET&#125;.cmakeexport PKG_CONFIG_PATH=$&#123;INSTALL_PREFIX&#125;/share/pkgconfig:$&#123;INSTALL_PREFIX&#125;/lib/pkgconfigTHIRDPARTY_DIR=$&#123;TOP_DIR&#125;/thirdpartyPROGRESS_FILE=$&#123;THIRDPARTY_DIR&#125;/build-log.conftouch $PROGRESS_FILEcd $THIRDPARTY_DIR## glogif [[ $(cat $&#123;PROGRESS_FILE&#125; | grep $&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125;) ]]; then    echo &quot;$&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125; already build&quot;else    rm -rf $GLOG_SOURCE    tar xf tarball/$&#123;GLOG_SOURCE&#125;.tar.gz &amp;&amp; cd $GLOG_SOURCE    mkdir -p build-$&#123;BUILD_TARGET&#125; &amp;&amp; cd build-$&#123;BUILD_TARGET&#125;        # 使用新的 C++11 ABI（默认 GCC 5+ 的行为）    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\    -DCMAKE_POSITION_INDEPENDENT_CODE=ON \\    -DBUILD_SHARED_LIBS=ON \\    -DCMAKE_CXX_FLAGS=-D_GLIBCXX_USE_CXX11_ABI=1 \\    -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; ..    make -j$(nproc) install &amp;&amp; echo $&#123;GLOG_SOURCE&#125;-$&#123;BUILD_TARGET&#125; &gt;&gt; $PROGRESS_FILE        cd ../..fi## nlohmann jsonif [[ $(cat $&#123;PROGRESS_FILE&#125; | grep $&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125;) ]]; then    echo &quot;$&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125; already build&quot;else    rm -rf $NLOHMANN_JSON_SOURCE    tar xf tarball/$&#123;NLOHMANN_JSON_SOURCE&#125;.tar.gz &amp;&amp; cd $NLOHMANN_JSON_SOURCE    mkdir -p build-$&#123;BUILD_TARGET&#125; &amp;&amp; cd build-$&#123;BUILD_TARGET&#125;        # 使用新的 C++11 ABI（默认 GCC 5+ 的行为）    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\    -DBUILD_SHARED_LIBS=ON \\    -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; ..    make -j$(nproc) install &amp;&amp; echo $&#123;NLOHMANN_JSON_SOURCE&#125;-$&#123;BUILD_TARGET&#125; &gt;&gt; $PROGRESS_FILE        cd ../..firm -rf $GLOG_SOURCErm -rf $NLOHMANN_JSON_SOURCEecho &quot;all done !&quot;\n orin.cmake文件分析\n交叉编译使用到该脚本，主要用于指定编译器以及编译根目录。\nif(NOT DEFINED ENV&#123;CYBER_KIT_PATH&#125;)    message(FATAL_ERROR &quot;Environment \\&quot;CYBER_KIT_PATH\\&quot; not set!&quot;)endif()set(TARGET_ARCH aarch64)set(TARGET_PLATFORM orin)set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR aarch64)set(HOST_PROCESSOR $&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125;)set(TOOLCHAIN_ROOT /usr)if($&#123;HOST_PROCESSOR&#125; STREQUAL &quot;x86_64&quot;)    set(TOOLCHAIN_ROOT /opt/toolchains/orin/aarch64--glibc--stable-final)    set(CROSS_COMPILE aarch64-linux-)endif()set(CMAKE_C_COMPILER $&#123;TOOLCHAIN_ROOT&#125;/bin/$&#123;CROSS_COMPILE&#125;gcc)set(CMAKE_CXX_COMPILER $&#123;TOOLCHAIN_ROOT&#125;/bin/$&#123;CROSS_COMPILE&#125;g++)set(CMAKE_FIND_ROOT_PATH $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin)if($&#123;HOST_PROCESSOR&#125; STREQUAL &quot;x86_64&quot;)    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)else()    set(CMAKE_SYSROOT /)    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE BOTH)    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)endif()set(CYBER_SYSROOT_LIB_DIR $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin/lib)set(CYBER_SYSROOT_INCLUDE_DIR $ENV&#123;CYBER_KIT_PATH&#125;sysroot/orin/include)\n 重新保存镜像\ndocker commit d063a8a6bdd5 i-nog/nog-cyber-kit/plat_orin_dev:v1.1.0\n工作区的改动会被保存进新镜像，前提是这些改动是在容器的文件系统内进行的。\n\n\n✅ 情况 1：改动在容器内部\n如果你在容器中运行了如下操作：\n  cd /workspaceapt install ...touch somefile.txtpip install ...\n然后执行：\n  docker commit &lt;容器名&gt; &lt;镜像名&gt;\n这些文件、安装的软件、代码改动 都会被保存进新镜像 ✅。\n\n\n❌ 情况 2：挂载的目录（如-v $&#123;WORK_DIR&#125;:/workspace）\n如果启动容器时使用了：\n  -v $&#123;WORK_DIR&#125;:/workspace\n则：\n\n/workspace实际是宿主机的目录；\n改动发生在宿主机，不属于容器文件系统；\ndocker commit不会保存这些改动 ❌。\n\n\n\n📌 举例说明\n\n有挂载：  docker run -v /home/lxp/code:/workspace ...\n你在容器内/workspace修改的所有内容，其实是修改的宿主机/home/lxp/code，不属于容器，docker commit不会打包它。\n无挂载（纯容器内）：  docker run ...# 没有 -v /workspace\n创建或修改/workspace的文件，commit后会保存在镜像里。\n\n","categories":["CyberRT中间件"]},{"title":"CyberRT自定义部署流程 之 部署cyber Cmake工程","url":"/2025/07/11/CyberRT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E4%B9%8B%E9%83%A8%E7%BD%B2cyber%20Cmake%E5%B7%A5%E7%A8%8B/","content":"CyberRT编译原本是基于Bazel，但入行以来都是基于Cmake搭建编译工程，所以更习惯用Cmake搭建工程。\nCmake工程搭建可以参考Baidu Apollo CyberRT Framework CMake Build。不过个人项目操作逻辑不一致，所以对其进行了魔改。\n\n CyberRT工程创建\n将CyberRT源码拷贝到自定义目录下，比如nog-cyber-kit。\n 进入构建好的镜像\n在工程目录下创建进入镜像脚本enter_docker.sh，脚本如下：\n#!/bin/bashplatform_array=(rk356x orin orin_cuda all all_cuda)usage()&#123;cat &lt;&lt; EOFUsage: $1 &lt;platform&gt; [docker_image_tag]platform: [$&#123;platform_array[*]&#125;]docker_image_tag: default is latestEOF&#125;log_highlight()&#123;    echo -e &quot;\\e[30;31m&quot;$1&quot;$(tput sgr0)&quot;&#125;if [[ $# -lt 1 || $1 == &quot;-h&quot; || $1 == &quot;--help&quot; ]]; then    usage $0    exit 0fiplatform=$&#123;1-&quot;xavier&quot;&#125;echo &quot;platform: $platform&quot;platform_valid=falsefor target in $&#123;platform_array[@]&#125;do    if [ x$platform = x$target ]; then        platform_valid=true    fidoneif ! $&#123;platform_valid&#125;; then    echo &quot;platform is not valid&quot;    usage $0    exit -1fi# sudo apt install x11-xserver-utilsxhost +docker_image_tag=$&#123;2-&quot;latest&quot;&#125;docker_image_repo=&quot;i-nog/nog-cyber-kit/plat_$&#123;platform&#125;_dev&quot;machine_name=plat-$&#123;platform&#125;-$&#123;docker_image_tag&#125;machine_id=`docker ps -a -q -f name=$&#123;machine_name&#125;`if [[ $&#123;machine_id&#125; != &#x27;&#x27; ]]; then    log_highlight &quot;Enter docker: $&#123;machine_name&#125;/$&#123;machine_id&#125; ...&quot;    docker start $&#123;machine_id&#125;    docker exec -it $&#123;machine_id&#125; /bin/bashelse    WORK_DIR=$PWD    docker_image_url=$&#123;docker_image_repo&#125;:$&#123;docker_image_tag&#125;    log_highlight &quot;Run docker from $&#123;docker_image_url&#125;&quot;    docker run  -it --privileged \\      --name $&#123;machine_name&#125; --net=host -v /dev:/dev \\      -v $&#123;WORK_DIR&#125;:/workspace -w /workspace \\      -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY \\      -v /media:/media \\      --gpus all \\      $&#123;docker_image_url&#125;fi\nbash enter_docker.sh orin v1.1.0进入容器。\n 顶层CMakeLists.txt\n根据自己项目修改：\ncmake_minimum_required(VERSION 3.5.1)project(cyber VERSION 9.0.0)set(TARGET_NAME $&#123;PROJECT_NAME&#125;)include(&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../cmake/nog.cmake&quot;)if(NOT CMAKE_BUILD_TYPE)  set(CMAKE_BUILD_TYPE Debug)endif()enable_language(ASM)# Use ccache if availablefind_program(CCACHE_FOUND ccache)if(CCACHE_FOUND)  message(STATUS &quot;### use ccache&quot;)  set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)  set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)endif()# PIC flagsset(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -fPIC&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -fPIC&quot;)# Architecture-specific assembly fileif(CMAKE_SYSTEM_PROCESSOR STREQUAL &quot;x86_64&quot;)  set(CROUTINE_FILE &quot;cyber/croutine/detail/swap_x86_64.S&quot;)else()  set(CROUTINE_FILE &quot;cyber/croutine/detail/swap_aarch64.S&quot;)endif()message(&quot;### SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125; $&#123;CROUTINE_FILE&#125;&quot;)set(CYBER_PYTHON_PATH &quot;lib/python$&#123;Python_VERSION&#125;/site-packages/cyber/python&quot;)set(CYBER_PYTHON_INTERNAL_PATH &quot;$&#123;CYBER_PYTHON_PATH&#125;/internal&quot;)set(CYBER_PYTHON_PROTOBUF_PATH &quot;lib/python$&#123;Python_VERSION&#125;/site-packages/cyber/proto&quot;)# Add include directoriesinclude_directories(  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;  $&#123;CMAKE_BINARY_DIR&#125;)file(GLOB CYBER_PROTO_FILES  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/proto/*.proto&quot;  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/examples/proto/*.proto&quot;)# Only generate proto files onceset(CYBER_MSGS_CACHE ON CACHE BOOL &quot;generate cyber proto msgs flag.&quot; FORCE)if(CYBER_MSGS_CACHE)  message(STATUS &quot;Generating proto files...&quot;)  foreach(FIL $&#123;CYBER_PROTO_FILES&#125;)    message(&quot;### generate proto file: $&#123;FIL&#125;&quot;)    execute_process(      COMMAND $&#123;PROTOBUF_PROTOC_EXECUTABLE&#125;      -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;      --cpp_out=$&#123;CMAKE_BINARY_DIR&#125;      --python_out=$&#123;CMAKE_BINARY_DIR&#125;      $&#123;FIL&#125;    )  endforeach()  # Avoid regenerating in subsequent runs  set(CYBER_MSGS_CACHE OFF CACHE BOOL &quot;generate cyber proto msgs flag.&quot; FORCE)endif()file(GLOB CYBER_PROTO_SRCS  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/*.pb.cc&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/*.pb.h&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/*.pb.cc&quot;  &quot;$&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/*.pb.h&quot;)file(GLOB CYBER_SRCS  &quot;cyber/base/*.cc&quot;  &quot;cyber/blocker/*.cc&quot;  &quot;cyber/class_loader/*.cc&quot;  &quot;cyber/class_loader/*/*.cc&quot;  &quot;cyber/common/*.cc&quot;  &quot;cyber/component/*.cc&quot;  &quot;cyber/croutine/*.cc&quot;  &quot;cyber/croutine/*/*.cc&quot;  &quot;cyber/data/*.cc&quot;  &quot;cyber/event/*.cc&quot;  &quot;cyber/io/*.cc&quot;  &quot;cyber/logger/*.cc&quot;  &quot;cyber/message/*.cc&quot;  &quot;cyber/node/*.cc&quot;  &quot;cyber/parameter/*.cc&quot;  &quot;cyber/plugin_manager/*.cc&quot;  &quot;cyber/record/*.cc&quot;  &quot;cyber/record/*/*.cc&quot;  &quot;cyber/scheduler/*.cc&quot;  &quot;cyber/scheduler/*/*.cc&quot;  &quot;cyber/service/*.cc&quot;  &quot;cyber/service_discovery/*.cc&quot;  &quot;cyber/service_discovery/*/*.cc&quot;  &quot;cyber/task/*.cc&quot;  &quot;cyber/time/*.cc&quot;  &quot;cyber/timer/*.cc&quot;  &quot;cyber/transport/*.cc&quot;  &quot;cyber/transport/*/*.cc&quot;  &quot;cyber/*.cc&quot;  &quot;cyber/sysmo/*.cc&quot;  $&#123;CROUTINE_FILE&#125;)# Exclude test files robustlylist(FILTER CYBER_SRCS EXCLUDE REGEX &quot;.*test[.]cc&quot;)list(FILTER CYBER_SRCS EXCLUDE REGEX &quot;.*/cyber/class_loader/test/.*&quot;)list(REMOVE_ITEM CYBER_SRCS &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cyber/class_loader/shared_library/sample.cc&quot;)add_library($&#123;TARGET_NAME&#125; SHARED  $&#123;CYBER_PROTO_SRCS&#125;  $&#123;CYBER_SRCS&#125;)target_link_libraries($&#123;TARGET_NAME&#125;  fastcdr   fastrtps  $&#123;Protobuf_LIBRARIES&#125;  z  glog  atomic  dl  rt  pthread  gflags  tinyxml2  uuid)add_subdirectory(cyber/mainboard)add_subdirectory(cyber/examples)add_subdirectory(cyber/tools)add_subdirectory(cyber/python)install(DIRECTORY cyber/  DESTINATION include/cyber/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/  DESTINATION include/cyber/proto/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/cyber/examples/proto/  DESTINATION include/cyber/examples/proto/  FILES_MATCHING PATTERN &quot;*.h&quot;)install(DIRECTORY cyber/conf/ DESTINATION share/conf/)configure_file(&quot;setup.bash.in&quot; &quot;$&#123;CMAKE_BINARY_DIR&#125;/setup.bash&quot; @ONLY)install(FILES $&#123;CMAKE_BINARY_DIR&#125;/setup.bash DESTINATION .)install(DIRECTORY cyber/python/  DESTINATION $&#123;CYBER_PYTHON_PATH&#125;  FILES_MATCHING PATTERN &quot;*.py&quot;)file(WRITE $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;/__init__.py   &quot;import os\\nimport sys\\nsys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))\\n&quot;)file(COPY $&#123;CMAKE_BINARY_DIR&#125;/cyber/proto/  DESTINATION $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;  FILES_MATCHING PATTERN &quot;*.py&quot;)install(DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;/  DESTINATION $&#123;CYBER_PYTHON_PROTOBUF_PATH&#125;)install(TARGETS $&#123;TARGET_NAME&#125;  EXPORT $&#123;TARGET_NAME&#125;-targets  ARCHIVE DESTINATION lib  LIBRARY DESTINATION lib  RUNTIME DESTINATION bin)\n 构建编译脚本build.sh\nbash build.sh -t x86 -i -r\n#!/usr/bin/env bashset -eTOP_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;0&#125;&quot;)&quot; &amp;&amp; pwd -P)&quot;# script usageusage()&#123;    echo &quot;Usage: $&#123;0&#125; [-t &lt;x86|xavier|rk356x&gt;] [-r (cmake reconfig)] [-i (install)] [-d (Debug)]&quot; 1&gt;&amp;2;    exit 0;&#125;# default settings: target architecture, build type, if reconfig, if installTARGET_ARCH=&quot;x86&quot;BUILD_TYPE=&quot;Release&quot;RECONFIG=falseMAKE_INSTALL=false# parse command line argswhile getopts &#x27;t:rid&#x27; OPTION; do    case &quot;$OPTION&quot; in        t)            TARGET_ARCH=&quot;$&#123;OPTARG&#125;&quot;            ;;        r)            RECONFIG=true            ;;        i)            MAKE_INSTALL=true            ;;        d)            BUILD_TYPE=&quot;Debug&quot;            ;;        *)            usage            ;;    esacdoneshift &quot;$(($&#123;OPTIND&#125; - 1))&quot; # delete option argsecho &quot;* build taget arch: $&#123;TARGET_ARCH&#125;&quot;echo &quot;* build type: $&#123;BUILD_TYPE&#125;&quot;# check if the environment variable POSEIDON_KIT_PATH existsif [ ! -v CYBER_KIT_PATH ]; then    echo -e &quot;\\e[31m[ERROR]The environment variable CYBER_KIT_PATH was not set, please &quot;\\            &quot;run &#x27;source &lt;path/to/dvpn-cyber-kit&gt;/scripts/setup.sh&#x27; first!\\e[0m&quot;    exit 1fiecho &quot;CYBER_KIT_PATH=$&#123;CYBER_KIT_PATH&#125;&quot;export PATH=$&#123;CYBER_KIT_PATH&#125;sysroot/x86/bin:$PATHexport LD_LIBRARY_PATH=$&#123;CYBER_KIT_PATH&#125;sysroot/x86/lib:$LD_LIBRARY_PATHPROJECT_DIR=$&#123;TOP_DIR&#125;export OUTPUT_DIR=$&#123;TOP_DIR&#125;/../output/$&#123;TARGET_ARCH&#125;INSTALL_PREFIX=$&#123;OUTPUT_DIR&#125;/cyberBUILD_DIR=$&#123;TOP_DIR&#125;/../build/$&#123;TARGET_ARCH&#125;/cyberTOOLCHAIN_FILE=$&#123;CYBER_KIT_PATH&#125;cmake/sysroot/$&#123;TARGET_ARCH&#125;.cmake# if reconfig delete the build cache filesif $&#123;RECONFIG&#125;; then    rm -rf $&#123;BUILD_DIR&#125;/*fimkdir -pv $&#123;BUILD_DIR&#125; &amp;&amp; cd $&#123;BUILD_DIR&#125;if [ ! -f &quot;CMakeCache.txt&quot; ] || [ ! -f &quot;Makefile&quot; ]; then    cmake -DCMAKE_TOOLCHAIN_FILE=$&#123;TOOLCHAIN_FILE&#125; \\          -DCMAKE_BUILD_TYPE=$&#123;BUILD_TYPE&#125; \\          -DCMAKE_INSTALL_PREFIX=$&#123;INSTALL_PREFIX&#125; \\          $&#123;PROJECT_DIR&#125;fimake -j$(nproc)# installif $&#123;MAKE_INSTALL&#125;; then    make installfi","categories":["CyberRT中间件"]},{"title":"Latex数学公式测试","url":"/2025/07/03/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95/","content":"测试博客 markdown 相关语法书写。\n\n 列表\n\n文本：\n\n[ ] 你好[x] 你好\n\n效果：\n\n你好\n你好\n 行内公式\n\n文本：\n\n$E = mc^2$\n\n效果：E=mc2E = mc^2E=mc2\n\n 块级公式\n\n文本：\n\n$$i\\hbar \\frac&#123;\\partial \\psi&#125;&#123;\\partial t&#125; = -\\frac&#123;\\hbar^2&#125;&#123;2m&#125; \\nabla^2 \\psi + V \\psi$$\n\n效果：\n\niℏ∂ψ∂t=−ℏ22m∇2ψ+Vψi\\hbar \\frac{\\partial \\psi}{\\partial t} = -\\frac{\\hbar^2}{2m} \\nabla^2 \\psi + V \\psi\niℏ∂t∂ψ​=−2mℏ2​∇2ψ+Vψ\n 字体颜色\n\n文本：\n\n1. ==高亮文本==2. &lt;span style=&quot;color: green;&quot;&gt;绿色文本&lt;/span&gt;3. **&lt;span style=&quot;color: green;&quot;&gt;绿色文本加粗&lt;/span&gt;**4. &lt;code style=&quot;color: green;&quot;&gt;green Codes: abcdef&lt;/code&gt;5. **&lt;code style=&quot;color: green;&quot;&gt;blod green Codes: abcdef&lt;/code&gt;**# 老式写法，需要打开# markdown_it_plus:#    html: true                 # 允许原始 HTML 标签6. &lt;font color=green&gt;文本&lt;/font&gt;7. &lt;font color=red size=5&gt;文本&lt;/font&gt;\n\n效果：\n\n\n高亮文本\n绿色文本\n绿色文本加粗\ngreen Codes: abcdef\nblod green Codes: abcdef\n文本\n文本\n\n 字体大小\n\n文本：\n\n&lt;span style=&quot;font-size: 18px;&quot;&gt;这是 18px 大小的文字&lt;/span&gt;\n\n效果：\n这是 18px 大小的文字\n\n 公式换行\n\n文本：\n\n$$\\begin&#123;aligned&#125;\\theta(s)=\\theta_&#123;start&#125;+s(\\theta_&#123;end&#125;-\\theta_&#123;start&#125;),s\\in[0,1] \\\\s=s(t),t\\in[0,T]\\end&#123;aligned&#125;$$# 带对齐符号$$\\begin&#123;aligned&#125;\\theta(s)&amp;=\\theta_&#123;start&#125;+s(\\theta_&#123;end&#125;-\\theta_&#123;start&#125;),s\\in[0,1] \\\\s&amp;=s(t),t\\in[0,T]\\end&#123;aligned&#125;$$# 不带aligned$$a = b+c \\\\d = e+f$$\n\n效果：\n\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns=s(t),t\\in[0,T]\n\\end{aligned}\nθ(s)=θstart​+s(θend​−θstart​),s∈[0,1]s=s(t),t∈[0,T]​\nθ(s)=θstart+s(θend−θstart),s∈[0,1]s=s(t),t∈[0,T]\\begin{aligned}\n\\theta(s)&amp;=\\theta_{start}+s(\\theta_{end}-\\theta_{start}),s\\in[0,1] \\\\\ns&amp;=s(t),t\\in[0,T]\n\\end{aligned}\nθ(s)s​=θstart​+s(θend​−θstart​),s∈[0,1]=s(t),t∈[0,T]​\na=b+cd=e+fa = b+c \\\\\nd = e+f\na=b+cd=e+f\n 矩阵\nxT⋅wxI4×4⋅x=(x1x2x3x4)1×4⋅wx(1000010000100001)4×4⋅(x1x2x3x4)4×1=wxx12+wxx22+wxx32+wxx42=wx∑i=14xi2\\begin{aligned}\nx^T\\cdot w_{x}\\textbf{I}_{4\\times4} \\cdot x &amp; =\\begin{pmatrix} x_1 &amp; x_2 &amp; x_3 &amp; x_4 \\end{pmatrix}_{1\\times4} \n\\cdot w_{x}\n\\begin{pmatrix} \n1 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\end{pmatrix}_{4\\times4}\n\\cdot\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1} \\\\\n&amp; = w_{x}x_1^2+w_{x}x_2^2+w_{x}x_3^2+w_{x}x_4^2 \\\\\n&amp; = w_{x} \\sum_{i=1}^{4}x_i^2\n\\end{aligned}\nxT⋅wx​I4×4​⋅x​=(x1​​x2​​x3​​x4​​)1×4​⋅wx​⎝⎜⎜⎜⎛​1000​0100​0010​0001​⎠⎟⎟⎟⎞​4×4​⋅⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​=wx​x12​+wx​x22​+wx​x32​+wx​x42​=wx​i=1∑4​xi2​​\n","categories":["博客搭建"]},{"title":"个人博客网站搭建","url":"/2025/07/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/","content":"Ubuntu18.04 + GitHub + Hexo免费配置个人博客\n\n 必要环境安装\n git\nsudo apt install git\n一般问题不大\n npm\n\nnpm (Node Package Manager)是一个用于JavaScript和Node.js的包管理器。它不仅是Node.js的默认包管理器，还提供了发布和共享代码、管理依赖、版本控制等功能。npm允许开发者从全球的代码库中获取并安装Node.js模块，这些模块可以用于构建应用程序、工具和包等。\n简单来说，npm就像一个巨大的软件仓库，里面存放了各种JavaScript和Node.js的模块（也叫包）。\n\nsudo apt-get install npm\n\nChatGPT建议使用nvm安装Node.js + npm（更干净灵活）。\n Node.js\n不想让系统包干扰，可以用nvm（Node Version Manager）来安装Node.js + npm：\n# 安装 nvmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash# 激活 nvm（或者重启终端）export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;# 安装 Node.js 最新 LTS 版本（或指定版本）nvm install --lts# 检查版本node -vnpm -v\n如果报以下错误：\n\n说明当前系统的GLIBC版本太低，而你安装的Node.js二进制文件依赖于更高版本的GLIBC（2.28）。\n\n🧠 原因分析\nUbuntu 18.04 的默认 glibc 是 2.27。\nNode.js 官方预构建二进制从某个版本开始依赖 glibc &gt;= 2.28（通常从 Node.js 18 或更高版本开始）。\n所以如果在 Ubuntu 18.04 或老系统上安装了较新的 Node.js，就会出这个错。\n\n\n\n彻底删除旧版本Node.js，以防系统中残留了之前的node安装路径或链接。\n执行以下命令清理旧的node/npm：\n sudo apt purge -y nodejs npmsudo rm -rf /usr/local/bin/node /usr/local/bin/npmsudo rm -rf /usr/bin/node /usr/bin/npmsudo rm -rf ~/.npm ~/.nvm ~/.node*hash -r\n\n\n安装 nvm（Node Version Manager）\n # 下载并安装 nvmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash# 加载 nvm（也可以重启终端）export NVM_DIR=&quot;$HOME/.nvm&quot;source &quot;$NVM_DIR/nvm.sh&quot;\n\n\n使用nvm安装Node.js 16\n nvm install 16nvm use 16nvm alias default 16\n\n\n验证：\n node -v      # 应输出 v16.x.xnpm -v       # 应输出 8.x.x\n\n\n\n 🚀 总结\n使用 nvm 方式安装Node.js是：\n\n✅ 最兼容的\n✅ 不依赖系统 glibc\n✅ 不需要 root 权限\n✅ 可随时切换 Node.js 版本\n\n nvm使用\n\n\n查看已安装的Node.js版本\n  nvm ls\n\n\n\n版本切换\n  # 切换使用 Node.js 14nvm use 14# 切回 Node.js 16nvm use 16\n\n\n设置默认版本（打开终端自动使用）\n  # 以后打开终端就会自动使用 Node.js 16。nvm alias default 16\n\n\n如果没有安装目标版本\n  # 先安装再切换：nvm install 14nvm use 14\n\n\n 基于Hexo框架搭建\n\nHexo项目中，源代码（markdown、主题等） 和生成后的网页是分开的\n\n一个仓库存放Hexo源码（如hexo-iNog-blog）（可选）\n一个仓库存放部署页面（如i-nog.github.io）\n\n\n\n\n下载 Hexo\n  npm install hexo-cli -g\n\n安装hexo插件  # 按需选择安装npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --save # 本人只安装这个npm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save\n\n\n\n\n创建框架\n  (base) lxp@lxp-os:~/projects$ mkdir hexo-iNog-blog(base) lxp@lxp-os:~/projects$ cd hexo-iNog-blog/(base) lxp@lxp-os:~/projects/hexo-iNog-blog$ hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesINFO  Start blogging with Hexo!(base) lxp@lxp-os:~/projects/hexo-iNog-blog$ ls_config.landscape.yml  _config.yml  node_modules  package.json  package-lock.json  scaffolds  source  themes\nhexo的文件结构：\n\npublic最终所见网页的所有内容\nnode_modules插件以及hexo所需node.js模块\n_config.yml站点配置文件，设定一些公开信息等\npackage.json应用程序信息，配置hexo运行所需js包\nscaffolds模板文件夹，新建文章，会默认包含对应模板内容\nthemes存放主题文件，hexo根据主题生成静态网页（速度贼快）\nsource用于存放用户资源（除posts文件夹，其余命名方式为 “ + 文件名”的文件被忽略）\n\n注意：hexo-iNog-blog/文件夹无需配置git仓库，除非个人想进行版本管理，方便长期开发。\n\n\n下载自己喜欢的主题\n在Themes查找自己喜欢的主题，比如Keep主题\n  # 在 hexo-iNog-blog/ 下，Keep主题git clone https://github.com/XPoet/hexo-theme-keep themes/keep# 或Fengye主题git clone https://github.com/chen-yingfa/hexo-theme-fengye.git themes/fengye# 或Fluid主题git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid\n\n\n配置主题\n在Hexo配置文件_config.yml中将theme设置为keep。\n\n\n\n自定义主题内容\n需要修改themes/keep/_config.yml文件\n\n\n\n本地预览\n  hexo clean //执行此命令后继续下一条hexo g // 生成博客目录，hexo generate 的缩写hexo s // 本地预览，hexo server 的缩写\n\n\n\n 创建及配置Gitbub Pages\n\n\n创建同用户名仓库，且是公共(Public)仓库\n\nGitHub Pages只支持公共仓库免费部署。如果仓库是私有的：\n\n地址不会生成；\n或者会提示升级为付费账户。\n\n\n\n设置仓库Pages信息\n\n\n\n本地关联github，需配置_config.yml文件中将deploy\n注意，是用户名.github.io那个仓库 。\n\n同时还需要配置git参数，如下：\n git config --global user.name &quot;用户名&quot;git config --global user.email &quot;******@gmail.com&quot;\n注意：是要配置全局的name和email。\n\n\n上传\n # 在自己的博客目录下，比如 hexo-iNog-blog/ 目录下# 清除缓存hexo clean# 生成hexo目录hexo generate# 可以先本地预览hexo server# 部署到远程仓库hexo deploy # 缩写 hexo d，如果失败，需要先安装 npm install hexo-deployer-git --save\ndeploy过程会生成.deploy_git/文件夹（内容同public/目录），自动关联到用户名.github.io仓库，将文件夹的内容推送到该仓库。\n\n\n❌ 不推荐直接把Hexo项目源码上传到.github.io仓库\n因为GitHub Pages无法直接解析source/里的.md文件，它只支持静态HTML页面。\n\n\n 资源压缩\n\n\n在 Hexo 项目根目录下安装 hexo-all-minifier\n cd your-hexonpm install hexo-all-minifier\n\n\n在 Hexo 配置文件 _config.yml 文件中，添加以下配置项\n all_minifier: true\n\n\n注意：Node.js需要升级到 18 或更高版本。\n 图片压缩工具\n网上搜索一大堆推荐，个人使用uTools工具里面的插件TinyJpg，不是通过API，插件自带压缩算法，压缩速度很快，感觉蛮好用，大家觉得好用的话，记得好评给作者一点动力（鞭策下作者这头牛马，继续优化，提高下压缩效率）。\n\n 图片生成\n\n本地部署\nMac本地安装部署Stable diffusion最全教程，AI绘画无痛入门指南\n在线生成\n\nBing Image Creator\n即梦AI\n\n\n\n Latex渲染\n 介绍\nLaTeX公式渲染引擎：\n\nMathJax\nKaTex\n\nmarkdown渲染器：\n\nhexo-renderer-pandoc\nhexo-renderer-markdown-it\nhexo-renderer-markdown-it-plus\n\n 使用\n因为Katex能使用\\\\换行，之前文档块公式都是采用\\\\换行，所以采用katex；\n本人采用markdown_it_plus（自带katex）。\n\n\n安装markdown-it-plus\n  npm i hexo-renderer-markdown-it-plus --save# --save 是 npm 的一个命令参数，用来表示：# 安装这个依赖，并将它写入 package.json 的 dependencies 字段中。# 但注意：从 npm v5（Node 8+）开始，默认就会自动写入 dependenciesnpm install hexo-renderer-markdown-it-plus# 效果是一样的，--save 可写可不写，它只是 早期版本需要显式加上。# 基于 package.json，使用 npm install 可以直接安装全部依赖\nmarkdown_it_plus默认启用的插件：\n\nmarkdown-it-emoji # 支持表情符号\nmarkdown-it-sub # 支持下标\nmarkdown-it-sup # 支持上标\nmarkdown-it-deflist # 支持定义列表\nmarkdown-it-abbr # 支持缩略词\nmarkdown-it-footnote # 支持脚注\nmarkdown-it-ins # 支持插入文本\nmarkdown-it-mark # 支持高亮文本\n@iktakahiro/markdown-it-katex # 公式渲染引擎\nmarkdown-it-toc-and-anchor # 目录\n\n\n\n安装额外插件\n  npm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n\nmarkdown-it-checkbox # 支持复选框\nmarkdown-it-imsize # 自定义图片宽高\nmarkdown-it-expandable # 折叠/展开内容\n\n\n\n# hexo项目的_config.yml文件markdown_it_plus:    highlight: true  # 是否启用代码高亮（内置 Prism.js）    html: true       # 允许原始 HTML 标签（&lt;font&gt;...&lt;/font&gt;）    xhtmlOut: true   # 输出 XHTML 格式标签（如 &lt;br/&gt; 而不是 &lt;br&gt;）    breaks: true     # 自动将换行符转换为 &lt;br&gt;    langPrefix:      # 代码块的语言 class 前缀，例如 language-python    linkify: true    # 自动识别链接并转为 &lt;a&gt;    typographer:     # 使用智能标点（如自动替换 -- 为 —）    quotes: “”‘’     # 引号样式（中英文分别）    plugins:        - plugin:            name: markdown-it-mark            enable: false # 关闭        - plugin:            name: markdown-it-checkbox            enable: true # 开启\n 双重渲染问题\n\n在使用 hexo-renderer-markdown-it-plus 时，它通常会生成如下结构：\n&lt;span class=&quot;katex&quot;&gt;  &lt;span class=&quot;katex-mathml&quot;&gt;...&lt;/span&gt;  &lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;...&lt;/span&gt; &lt;!-- 这个是你要隐藏的 --&gt;&lt;/span&gt;\n\n其中：\n\nkatex-mathml 是给屏幕阅读器（辅助功能）用的。\nkatex-html 是用来实际显示公式的。\n有时 Keep 主题或 MathJax 会再渲染一次，导致重复。\n\n解决方式：\n使用 可注入的 CSS 样式 来隐藏 katex-html 元素，避免公式重复显示。\n\n\nkeep主题配置\n  # _config.keep.ymlinject:  enable: true  # Option values: true | false  css:\t- /css/custom-1.css\t# e.g.\t# - /css/custom-1.css\t# - /css/custom-2.css\t# - ...  js:\t-\t# e.g.\t# - /js/custom-1.js\t# - /js/custom-2.js\t# - ...\n\n\n增加source/css/custom-1.css文件\n  .katex-html &#123;\tdisplay: none !important;&#125;\n\n\n 评论系统搭建\n\ngiscus\n\n目前 Keep 主题支持该插件，所以本人直接使用该插件，按照说明配置就行；主要就是创建一个 public 的仓库，然后安装 giscus app，在打开 Discussions 功能；\nKeep 主题暴露了 Giscus 评论插件五个配置项：repo、repo_id、category、category_id、reactions_enabled，根据生成的配置项填写就行\n\n\n\nutterances\n\n与上者类似，目前 Keep 主题不支持，所以没深入研究。\n\n\n\n两者都会生成&lt;script src=...&lt;/script&gt;，在哪个位置添加该标签，评论就出现在哪个位置。\n 与JopLin笔记本配合（无很好适配）\nJoplin Publisher插件教程\n\n配置仓库的读写权限\n\n\n\n结果：\n\n\n 参考文献\nKeep 主题使用手册\nUbuntu20.04 +GitHub+Hexo 0基础0成本免费配置个人博客\n快速搭建个人博客 —— 保姆级教程\n","categories":["博客搭建"]},{"title":"sysroot目录的作用","url":"/2025/04/14/sysroot%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"在软件开发和交叉编译中，sysroot（System Root）是一个关键概念，它定义了目标系统根目录的路径，帮助开发工具链（如编译器、链接器）在构建过程中正确找到目标平台的头文件、库和其他依赖资源。以下是其核心作用的详细说明：\n\n 1. sysroot 的核心作用\n\n隔离开发环境：\n在交叉编译（例如在 x86 主机上编译 ARM 程序）时，sysroot 会指定目标设备的根文件系统路径，确保编译工具链不会误用宿主机的头文件和库。\n路径重定向：\n当工具链访问标准路径（如 /usr/include、/lib）时，实际会从 sysroot 指定的目录下查找文件（即 sysroot/usr/include、sysroot/lib）。\n\n 2. 典型使用场景\n (1) 交叉编译（Cross-Compilation）\n假设你在 x86_64 主机上编译一个运行在 ARM 嵌入式设备的程序：\n\n目标设备的根文件系统可能存放在主机的 /opt/arm-sysroot 目录下。\n通过指定 --sysroot=/opt/arm-sysroot，编译器会从该目录下查找 ARM 架构的头文件和库，而非宿主机的 x86 资源。\n\n示例命令：\narm-linux-gnueabihf-gcc --sysroot=/opt/arm-sysroot -o myapp myapp.c\n (2) 嵌入式开发\n嵌入式设备的文件系统通常通过工具（如 Buildroot、Yocto）生成，并导出为 sysroot，供开发工具链使用。\n (3) 容器化构建\n在 Docker 容器中构建应用时，sysroot 可指向容器内的根文件系统，避免依赖宿主机环境。\n 3. sysroot 的目录结构\n一个典型的 sysroot 目录结构如下：\n/opt/arm-sysroot├── lib         # 目标系统的库文件（如 libc.so）├── usr│   ├── include # 目标系统的头文件（如 stdio.h）│   └── lib     # 目标系统的其他库└── ...\n 4. 如何配置 sysroot\n (1) 编译器参数\n在编译时通过 --sysroot 指定路径：\ngcc --sysroot=/path/to/sysroot -o output input.c\n (2) 工具链配置\n交叉编译工具链（如 arm-linux-gnueabihf-gcc）通常预置了默认的 sysroot。可通过 -print-sysroot 查看：\narm-linux-gnueabihf-gcc -print-sysroot\n (3) 构建系统配置\n在 CMake 中设置 CMAKE_SYSROOT：\nset(CMAKE_SYSROOT &quot;/opt/arm-sysroot&quot;)\n在 Autotools 中通过 --with-sysroot：\n./configure --with-sysroot=/opt/arm-sysroot\n 5. 常见问题与解决\n (1) 错误：头文件或库找不到\n\n原因：sysroot 路径未正确配置，或目标文件系统中缺失依赖。\n解决：\n\n检查 sysroot 路径是否存在且包含目标系统的 include 和 lib 目录。\n使用 find 命令验证文件是否存在：find /opt/arm-sysroot -name &quot;stdio.h&quot;\n\n\n\n\n (2) 错误：链接到宿主机库\n\n原因：未正确隔离环境，工具链仍使用宿主机默认路径。\n解决：\n\n确保编译命令包含 --sysroot。\n使用 -nostdinc 和 -nostdlib 强制禁用宿主机默认路径。\n\n\n\n 6. 对比 sysroot 与 chroot\n\nsysroot：仅影响编译工具链的路径查找，用于构建阶段。\nchroot：改变进程的根目录视图，用于运行时环境隔离。\n\n 总结\n\nsysroot 是目标系统根目录的镜像，确保编译工具链使用正确的资源。\n在交叉编译、嵌入式开发和容器化构建中必不可少，避免环境污染和兼容性问题。\n配置时需确保目标系统的头文件、库和工具链架构（如 ARM、x86）一致。\n\n","categories":["CyberRT中间件","Linux软件开发"]},{"title":"（二）分段加加速度算法（PiecewiseJerk）之 路径规划代码实现","url":"/2021/09/14/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"基于Apollo r5.5.0 版本代码，其实后续版本算法代码基本没有差变。\n\n 代码实现\n/* * @brief: * This class solve an optimization problem: * x * | * |                       P(s1, x1)  P(s2, x2) * |            P(s0, x0)                       ... P(s(k-1), x(k-1)) * |P(start) * | * |________________________________________________________ s * * we suppose s(k+1) - s(k) == s(k) - s(k-1) * * Given the x, x&#x27;, x&#x27;&#x27; at P(start),  The goal is to find x0, x1, ... x(k-1) * which makes the line P(start), P0, P(1) ... P(k-1) &quot;smooth&quot;. */\n Class PiecewiseJerkProblem\n先定义一个父类\n// piecewise_jerk_problem.hclass PiecewiseJerkProblem &#123;  ... protected:  // naming convention follows osqp solver.  // 纯虚函数，必须由子类实现  virtual void CalculateKernel(std::vector&lt;c_float&gt;* P_data,                               std::vector&lt;c_int&gt;* P_indices,                               std::vector&lt;c_int&gt;* P_indptr) = 0;  // 纯虚函数，必须由子类实现  virtual void CalculateOffset(std::vector&lt;c_float&gt;* q) = 0;  // 虚函数，子类可改写  virtual void CalculateAffineConstraint(std::vector&lt;c_float&gt;* A_data,                                         std::vector&lt;c_int&gt;* A_indices,                                         std::vector&lt;c_int&gt;* A_indptr,                                         std::vector&lt;c_float&gt;* lower_bounds,                                         std::vector&lt;c_float&gt;* upper_bounds);  // 虚函数，子类可改写  virtual OSQPSettings* SolverDefaultSettings();  ...&#125;// piecewise_jerk_problem.ccPiecewiseJerkProblem::PiecewiseJerkProblem(    const size_t num_of_knots, const double delta_s,    const std::array&lt;double, 3&gt;&amp; x_init) &#123;  CHECK_GE(num_of_knots, 2);  // 设定优化点的个数  num_of_knots_ = num_of_knots;  // 初始值设定  x_init_ = x_init;  // 设定ds  delta_s_ = delta_s;  // 初始化x边界  x_bounds_.resize(num_of_knots_,                   std::make_pair(-kMaxVariableRange, kMaxVariableRange));  // 初始化dx边界  dx_bounds_.resize(num_of_knots_,                    std::make_pair(-kMaxVariableRange, kMaxVariableRange));  // 初始化ddx边界  ddx_bounds_.resize(num_of_knots_,                     std::make_pair(-kMaxVariableRange, kMaxVariableRange));&#125;\n PiecewiseJerkProblem::FormulateProblem()\n构造用OSQP解决器解决的问题，需要知道优化变量总数n、约束条件数量m、矩阵P、q、A以及边界条件l和u。\nOSQPData* PiecewiseJerkProblem::FormulateProblem() &#123;  // calculate kernel  std::vector&lt;c_float&gt; P_data;  std::vector&lt;c_int&gt; P_indices;  std::vector&lt;c_int&gt; P_indptr;  CalculateKernel(&amp;P_data, &amp;P_indices, &amp;P_indptr);  // calculate affine constraints  std::vector&lt;c_float&gt; A_data;  std::vector&lt;c_int&gt; A_indices;  std::vector&lt;c_int&gt; A_indptr;  std::vector&lt;c_float&gt; lower_bounds;  std::vector&lt;c_float&gt; upper_bounds;  CalculateAffineConstraint(&amp;A_data, &amp;A_indices, &amp;A_indptr, &amp;lower_bounds,                            &amp;upper_bounds);  // calculate offset  std::vector&lt;c_float&gt; q;  CalculateOffset(&amp;q);  OSQPData* data = reinterpret_cast&lt;OSQPData*&gt;(c_malloc(sizeof(OSQPData)));  CHECK_EQ(lower_bounds.size(), upper_bounds.size());    size_t kernel_dim = 3 * num_of_knots_;  size_t num_affine_constraint = lower_bounds.size();  // 设定优化变量的个数 3n  data-&gt;n = kernel_dim;  // 设定限制条件的维度  data-&gt;m = num_affine_constraint;  // 矩阵P kernel_dim行，kernel_dim列  data-&gt;P = csc_matrix(kernel_dim, kernel_dim, P_data.size(), CopyData(P_data),                       CopyData(P_indices), CopyData(P_indptr));  data-&gt;q = CopyData(q);  // 矩阵A num_affine_constraint行，kernel_dim列  data-&gt;A =      csc_matrix(num_affine_constraint, kernel_dim, A_data.size(),                 CopyData(A_data), CopyData(A_indices), CopyData(A_indptr));  data-&gt;l = CopyData(lower_bounds);  data-&gt;u = CopyData(upper_bounds);  return data;&#125;\n PiecewiseJerkProblem::Optimize()\nbool PiecewiseJerkProblem::Optimize(const int max_iter) &#123;  // 构建问题  OSQPData* data = FormulateProblem();  // 配置OSQP解决器参数  OSQPSettings* settings = SolverDefaultSettings();  settings-&gt;max_iter = max_iter;  // 构建osqp解决器  OSQPWorkspace* osqp_work = osqp_setup(data, settings);  // 使用解决器处理问题  osqp_solve(osqp_work);  // 解的状态及返回值  auto status = osqp_work-&gt;info-&gt;status_val;  if (status &lt; 0 || (status != 1 &amp;&amp; status != 2)) &#123;    AERROR &lt;&lt; &quot;failed optimization status:\\t&quot; &lt;&lt; osqp_work-&gt;info-&gt;status;    osqp_cleanup(osqp_work);    FreeData(data);    c_free(settings);    return false;  &#125; else if (osqp_work-&gt;solution == nullptr) &#123;    AERROR &lt;&lt; &quot;The solution from OSQP is nullptr&quot;;    osqp_cleanup(osqp_work);    FreeData(data);    c_free(settings);    return false;  &#125;  // extract primal results  x_.resize(num_of_knots_);  dx_.resize(num_of_knots_);  ddx_.resize(num_of_knots_);  // 输出结果，以及还原比例缩放  for (size_t i = 0; i &lt; num_of_knots_; ++i) &#123;    x_.at(i) = osqp_work-&gt;solution-&gt;x[i] / scale_factor_[0];    dx_.at(i) = osqp_work-&gt;solution-&gt;x[i + num_of_knots_] / scale_factor_[1];    ddx_.at(i) =        osqp_work-&gt;solution-&gt;x[i + 2 * num_of_knots_] / scale_factor_[2];  &#125;  // Cleanup  osqp_cleanup(osqp_work);  FreeData(data);  c_free(settings);  return true;&#125;\n OSQP解决器其解的状态及返回值\n\n\n\n状态\n常量\n返回值\n\n\n\n\n求解成功solved\nOSQP_SOLVED\n1\n\n\n求解错误solved inaccurate\nOSQP_SOLVED_INACCURATE\n2\n\n\n达到最大迭代次数maximum iterations reached\nOSQP_MAX_ITER_REACHED\n-2\n\n\n原始不可行primal infeasible\nOSQP_PRIMAL_INFEASIBLE\n-3\n\n\n原始不可行错误primal infeasible inaccurate\nOSQP_PRIMAL_INFEASIBLE_INACCURATE\n3\n\n\n双重不可行dual infeasible\nOSQP_DUAL_INFEASIBLE\n-4\n\n\n双重不可行错误dual infeasible inaccurate\nOSQP_DUAL_INFEASIBLE_INACCURATE\n4\n\n\n被用户打断interrupted by user\nOSQP_SIGINT\n-5\n\n\n运行时间超时run time limit reached\nOSQP_TIME_LIMIT_REACHED\n-6\n\n\n未解决unsolved\nOSQP_UNSOLVED\n-10\n\n\n问题非凸problem non convex\nOSQP_NON_CVX\n-7\n\n\n\n注意：OSQP求解的是二次型cost凸优化问题，如果当一个或多个特征值“明显”为负，即问题不是半正定，此时OSQP能检查出错误（问题非凸），但是当特征值负的“不明显”时，可能检测不出来非凸性，需要用户执行判断。\n PiecewiseJerkProblem::SolverDefaultSettings()\nOSQPSettings* PiecewiseJerkProblem::SolverDefaultSettings() &#123;  // Define Solver default settings  OSQPSettings* settings =      reinterpret_cast&lt;OSQPSettings*&gt;(c_malloc(sizeof(OSQPSettings)));  osqp_set_default_settings(settings);  settings-&gt;polish = true;  settings-&gt;verbose = FLAGS_enable_osqp_debug;  settings-&gt;scaled_termination = true;  return settings;&#125;\n PiecewiseJerkProblem::CalculateAffineConstraint()\n在父类已经构造了计算矩阵A\\textbf{A}A函数。\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\n其中\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×nA5=(10⋯0)1×n\\begin{aligned}\n\\textbf{A}_1 &amp; = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n} \\\\\n\\textbf{A}_2 &amp; = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n} \\\\\n\\textbf{A}_3 &amp; = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 &amp; = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n} \\\\\n\\textbf{A}_5 &amp; =\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\n\\end{aligned}\nA1​A2​A3​A4​A5​​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​=−ds⋅In−1×n​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​=(1​0​⋯​0​)1×n​​\nvoid PiecewiseJerkProblem::CalculateAffineConstraint(    std::vector&lt;c_float&gt;* A_data, std::vector&lt;c_int&gt;* A_indices,    std::vector&lt;c_int&gt;* A_indptr, std::vector&lt;c_float&gt;* lower_bounds,    std::vector&lt;c_float&gt;* upper_bounds) &#123;  // 3N params bounds on x, x&#x27;, x&#x27;&#x27;  // 3(N-1) constraints on x, x&#x27;, x&#x27;&#x27;  // 3 constraints on x_init_  // n表示优化的点数  const int n = static_cast&lt;int&gt;(num_of_knots_);  // 优化变量数量为3n  const int num_of_variables = 3 * n;  // 由理论推导，限制条件数量为6n  const int num_of_constraints = num_of_variables + 3 * (n - 1) + 3;  lower_bounds-&gt;resize(num_of_constraints);  upper_bounds-&gt;resize(num_of_constraints);  // 设定为3n列，variables对应矩阵A  std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; variables(      num_of_variables);  int constraint_index = 0;  // set x, x&#x27;, x&#x27;&#x27; bounds  for (int i = 0; i &lt; num_of_variables; ++i) &#123;    if (i &lt; n) &#123;      // 设定矩阵A关于x的系数，以及对应的边界      variables[i].emplace_back(constraint_index, 1.0);      lower_bounds-&gt;at(constraint_index) =          x_bounds_[i].first * scale_factor_[0];      upper_bounds-&gt;at(constraint_index) =          x_bounds_[i].second * scale_factor_[0];    &#125; else if (i &lt; 2 * n) &#123;      // 设定矩阵A关于x&#x27;的系数，以及对应的边界      variables[i].emplace_back(constraint_index, 1.0);      lower_bounds-&gt;at(constraint_index) =          dx_bounds_[i - n].first * scale_factor_[1];      upper_bounds-&gt;at(constraint_index) =          dx_bounds_[i - n].second * scale_factor_[1];    &#125; else &#123;      // 设定矩阵A关于x&#x27;&#x27;的系数，以及对应的边界      variables[i].emplace_back(constraint_index, 1.0);      lower_bounds-&gt;at(constraint_index) =          ddx_bounds_[i - 2 * n].first * scale_factor_[2];      upper_bounds-&gt;at(constraint_index) =          ddx_bounds_[i - 2 * n].second * scale_factor_[2];    &#125;    ++constraint_index;  &#125;  // 数量检查  CHECK_EQ(constraint_index, num_of_variables);  // x(i-&gt;i+1)&#x27;&#x27;&#x27; = (x(i+1)&#x27;&#x27; - x(i)&#x27;&#x27;) / delta_s  // 设定矩阵A关于加加速度的限制条件，转化为关于加速度的限制条件，及其对应边界，也就是A1  // n-1行  for (int i = 0; i + 1 &lt; n; ++i) &#123;    variables[2 * n + i].emplace_back(constraint_index, -1.0);    variables[2 * n + i + 1].emplace_back(constraint_index, 1.0);    lower_bounds-&gt;at(constraint_index) =        dddx_bound_.first * delta_s_ * scale_factor_[2];    upper_bounds-&gt;at(constraint_index) =        dddx_bound_.second * delta_s_ * scale_factor_[2];    ++constraint_index;  &#125;  // x(i+1)&#x27; - x(i)&#x27; - 0.5 * delta_s * x(i)&#x27;&#x27; - 0.5 * delta_s * x(i+1)&#x27;&#x27; = 0  // 设定矩阵A关于速度的连续性，即速度等式约束，A1 A2，注意交叉乘对应的缩放比例  // n-1行  for (int i = 0; i + 1 &lt; n; ++i) &#123;    variables[n + i].emplace_back(constraint_index, -1.0 * scale_factor_[2]);    variables[n + i + 1].emplace_back(constraint_index, 1.0 * scale_factor_[2]);    variables[2 * n + i].emplace_back(constraint_index,                                      -0.5 * delta_s_ * scale_factor_[1]);    variables[2 * n + i + 1].emplace_back(constraint_index,                                          -0.5 * delta_s_ * scale_factor_[1]);    lower_bounds-&gt;at(constraint_index) = 0.0;    upper_bounds-&gt;at(constraint_index) = 0.0;    ++constraint_index;  &#125;  // x(i+1) - x(i) - delta_s * x(i)&#x27;  // - 1/3 * delta_s^2 * x(i)&#x27;&#x27; - 1/6 * delta_s^2 * x(i+1)&#x27;&#x27;  // 设定矩阵A关于距离的连续性，即距离等式约束，A1 A3 A4，注意交叉乘对应的缩放比例  // n-1行  auto delta_s_sq_ = delta_s_ * delta_s_;  for (int i = 0; i + 1 &lt; n; ++i) &#123;    variables[i].emplace_back(constraint_index,                              -1.0 * scale_factor_[1] * scale_factor_[2]);    variables[i + 1].emplace_back(constraint_index,                                  1.0 * scale_factor_[1] * scale_factor_[2]);    variables[n + i].emplace_back(        constraint_index, -delta_s_ * scale_factor_[0] * scale_factor_[2]);    variables[2 * n + i].emplace_back(        constraint_index,        -delta_s_sq_ / 3.0 * scale_factor_[0] * scale_factor_[1]);    variables[2 * n + i + 1].emplace_back(        constraint_index,        -delta_s_sq_ / 6.0 * scale_factor_[0] * scale_factor_[1]);    lower_bounds-&gt;at(constraint_index) = 0.0;    upper_bounds-&gt;at(constraint_index) = 0.0;    ++constraint_index;  &#125;  // constrain on x_init  // 矩阵A5  // 第1列  variables[0].emplace_back(constraint_index, 1.0);  lower_bounds-&gt;at(constraint_index) = x_init_[0] * scale_factor_[0];  upper_bounds-&gt;at(constraint_index) = x_init_[0] * scale_factor_[0];  ++constraint_index;  // 第n+1列  variables[n].emplace_back(constraint_index, 1.0);  lower_bounds-&gt;at(constraint_index) = x_init_[1] * scale_factor_[1];  upper_bounds-&gt;at(constraint_index) = x_init_[1] * scale_factor_[1];  ++constraint_index;  // 第2n+1列  variables[2 * n].emplace_back(constraint_index, 1.0);  lower_bounds-&gt;at(constraint_index) = x_init_[2] * scale_factor_[2];  upper_bounds-&gt;at(constraint_index) = x_init_[2] * scale_factor_[2];  ++constraint_index;  CHECK_EQ(constraint_index, num_of_constraints);  // 提取数据及其下标  int ind_p = 0;  // 总共有 num_of_variables=3n 列  for (int i = 0; i &lt; num_of_variables; ++i) &#123;    // A_indptr储存每一列开始第一个数据的下标位置    A_indptr-&gt;push_back(ind_p);    for (const auto&amp; variable_nz : variables[i]) &#123;      // coefficient      // 存放数据，即系数      A_data-&gt;push_back(variable_nz.second);      // constraint index      // 存放数据所在列的第几行，即第几个限制条件      A_indices-&gt;push_back(variable_nz.first);      ++ind_p;    &#125;  &#125;  // We indeed need this line because of  // https://github.com/oxfordcontrol/osqp/blob/master/src/cs.c#L255  A_indptr-&gt;push_back(ind_p);&#125;\n\n 路径规划代码实现\n Class PiecewiseJerkPathProblem\n/* * @brief: * FEM stands for finite element method. * This class solve an optimization problem: * x * | * |                       P(s1, x1)  P(s2, x2) * |            P(s0, x0)                       ... P(s(k-1), x(k-1)) * |P(start) * | * |________________________________________________________ s * * we suppose s(k+1) - s(k) == s(k) - s(k-1) * * Given the x, x&#x27;, x&#x27;&#x27; at P(start),  The goal is to find x0, x1, ... x(k-1) * which makes the line P(start), P0, P(1) ... P(k-1) &quot;smooth&quot;. */class PiecewiseJerkPathProblem : public PiecewiseJerkProblem &#123;  ... protected:  // 实现两个纯虚函数  void CalculateKernel(std::vector&lt;c_float&gt;* P_data,                       std::vector&lt;c_int&gt;* P_indices,                       std::vector&lt;c_int&gt;* P_indptr) override;  void CalculateOffset(std::vector&lt;c_float&gt;* q) override;&#125;;\n PiecewiseJerkPathProblem::CalculateKernel()\nP=(P1P2P3)3n×3nP1=((wx+wx_ref)In−1×n−10n−1×101×n−1wx+wx_ref+wx_end)n×nP2=(wx′In−1×n−10n−1×101×n−1wx′+wx′_end)n×nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2+wx′′_end)n×n\\begin{aligned}\n\\textbf{P}=\\begin{pmatrix} \n\\textbf{P}_1 &amp; &amp; \\\\ \n&amp; \\textbf{P}_2 &amp; \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n} \\\\\n\n\\textbf{P}_1 = \\begin{pmatrix} \n(w_{x} + w_{x\\_ref})\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x} + w_{x\\_ref} + w_{x\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_2 = \\begin{pmatrix} \nw_{x&#x27;}\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x&#x27;} + w_{x&#x27;\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}+ w_{x&#x27;&#x27;\\_end}\\\\\n\\end{pmatrix}_{n\\times n}\n\\end{aligned}\nP=⎝⎛​P1​​P2​​P3​​⎠⎞​3n×3n​P1​=((wx​+wx_ref​)In−1×n−1​01×n−1​​0n−1×1​wx​+wx_ref​+wx_end​​)n×n​P2​=(wx′​In−1×n−1​01×n−1​​0n−1×1​wx′​+wx′_end​​)n×n​P3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​+wx′′_end​​⎠⎞​n×n​​\nvoid PiecewiseJerkPathProblem::CalculateKernel(std::vector&lt;c_float&gt;* P_data,                                               std::vector&lt;c_int&gt;* P_indices,                                               std::vector&lt;c_int&gt;* P_indptr) &#123;  const int n = static_cast&lt;int&gt;(num_of_knots_);  const int num_of_variables = 3 * n;  // 矩阵P有效数据的个数  const int num_of_nonzeros = num_of_variables + (n - 1);  // 表示矩阵P，有num_of_variables列  std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; columns(num_of_variables);  int value_index = 0;  // x(i)^2 * (w_x + w_x_ref)  // 对应P1矩阵，注意增加了位置比重  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[i].emplace_back(        i, (weight_x_ + weight_x_ref_) / (scale_factor_[0] * scale_factor_[0]));    ++value_index;  &#125;  // x(n-1)^2 * (w_x + w_x_ref + w_end_x)  columns[n - 1].emplace_back(      n - 1, (weight_x_ + weight_x_ref_ + weight_end_state_[0]) /                 (scale_factor_[0] * scale_factor_[0]));  ++value_index;  // x(i)&#x27;^2 * w_dx  // 对应P2矩阵  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[n + i].emplace_back(        n + i, weight_dx_ / (scale_factor_[1] * scale_factor_[1]));    ++value_index;  &#125;  // x(n-1)&#x27;^2 * (w_dx + w_end_dx)  columns[2 * n - 1].emplace_back(2 * n - 1,                                  (weight_dx_ + weight_end_state_[1]) /                                      (scale_factor_[1] * scale_factor_[1]));  ++value_index;  auto delta_s_square = delta_s_ * delta_s_;  // x(i)&#x27;&#x27;^2 * (w_ddx + 2 * w_dddx / delta_s^2)  // 对应P3矩阵，右边项  columns[2 * n].emplace_back(2 * n,                              (weight_ddx_ + weight_dddx_ / delta_s_square) /                                  (scale_factor_[2] * scale_factor_[2]));  ++value_index;  for (int i = 1; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(        2 * n + i, (weight_ddx_ + 2.0 * weight_dddx_ / delta_s_square) /                       (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  columns[3 * n - 1].emplace_back(      3 * n - 1,      (weight_ddx_ + weight_dddx_ / delta_s_square + weight_end_state_[2]) /          (scale_factor_[2] * scale_factor_[2]));  ++value_index;  // -2 * w_dddx / delta_s^2 * x(i)&#x27;&#x27; * x(i + 1)&#x27;&#x27;  // 对应P3矩阵，左边项  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(2 * n + i + 1,                                    (-2.0 * weight_dddx_ / delta_s_square) /                                        (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  CHECK_EQ(value_index, num_of_nonzeros);  int ind_p = 0;  for (int i = 0; i &lt; num_of_variables; ++i) &#123;    P_indptr-&gt;push_back(ind_p);    for (const auto&amp; row_data_pair : columns[i]) &#123;      P_data-&gt;push_back(row_data_pair.second * 2.0);      P_indices-&gt;push_back(row_data_pair.first);      ++ind_p;    &#125;  &#125;  P_indptr-&gt;push_back(ind_p);&#125;\n PiecewiseJerkPathProblem::CalculateOffset()\nq=(q1q2q3)3n×1q1=(−2wx_refxref⋮−2wx_refxref−2wx_endxend−2wx_refxref)n×1，q2=(0⋮0)n×1，q3=(0⋮0−2wx′′_endxend′′)n×1\\begin{aligned}\n\\textbf{q} = \\begin{pmatrix} \n\\textbf{q}_1 \\\\ \n\\textbf{q}_2 \\\\ \n\\textbf{q}_3 \\\\ \n\\end{pmatrix}_{3n \\times 1} \\\\\n\n\\textbf{q}_1 = \\begin{pmatrix}\n-2w_{x\\_ref}x_{ref} \\\\\n\\vdots \\\\\n-2w_{x\\_ref}x_{ref} \\\\\n-2w_{x\\_end}x_{end} - 2w_{x\\_ref}x_{ref}\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_2 = \\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_3 = \\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;\\_end}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{aligned}\nq=⎝⎛​q1​q2​q3​​⎠⎞​3n×1​q1​=⎝⎜⎜⎜⎜⎛​−2wx_ref​xref​⋮−2wx_ref​xref​−2wx_end​xend​−2wx_ref​xref​​⎠⎟⎟⎟⎟⎞​n×1​，q2​=⎝⎜⎜⎛​0⋮0​⎠⎟⎟⎞​n×1​，q3​=⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′_end​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​\nvoid PiecewiseJerkPathProblem::CalculateOffset(std::vector&lt;c_float&gt;* q) &#123;  CHECK_NOTNULL(q);  const int n = static_cast&lt;int&gt;(num_of_knots_);  const int kNumParam = 3 * n;  q-&gt;resize(kNumParam, 0.0);  if (has_x_ref_) &#123;    for (int i = 0; i &lt; n; ++i) &#123;      q-&gt;at(i) += -2.0 * weight_x_ref_ * x_ref_[i] / scale_factor_[0];    &#125;  &#125;  if (has_end_state_ref_) &#123;    q-&gt;at(n - 1) +=        -2.0 * weight_end_state_[0] * end_state_ref_[0] / scale_factor_[0];    q-&gt;at(2 * n - 1) +=        -2.0 * weight_end_state_[1] * end_state_ref_[1] / scale_factor_[1];    q-&gt;at(3 * n - 1) +=        -2.0 * weight_end_state_[2] * end_state_ref_[2] / scale_factor_[2];  &#125;&#125;\n 工程使用\n 路径规划Task–PiecewiseJerkPathOptimizer\n PiecewiseJerkPathOptimizer::Process()\ncommon::Status PiecewiseJerkPathOptimizer::Process(    const SpeedData&amp; speed_data, const ReferenceLine&amp; reference_line,    const common::TrajectoryPoint&amp; init_point, const bool path_reusable,    PathData* const final_path_data) &#123;  // skip piecewise_jerk_path_optimizer if reused path  if (FLAGS_enable_skip_path_tasks &amp;&amp; path_reusable) &#123;    return Status::OK();  &#125;  ADEBUG &lt;&lt; &quot;Plan at the starting point: x = &quot; &lt;&lt; init_point.path_point().x()         &lt;&lt; &quot;, y = &quot; &lt;&lt; init_point.path_point().y()         &lt;&lt; &quot;, and angle = &quot; &lt;&lt; init_point.path_point().theta();  common::TrajectoryPoint planning_start_point = init_point;  if (FLAGS_use_front_axe_center_in_path_planning) &#123;    // 根据设定平移规划起点    planning_start_point =        InferFrontAxeCenterFromRearAxeCenter(planning_start_point);  &#125;  // 将规划起点转化到基于参考线的SL坐标系下  const auto init_frenet_state =      reference_line.ToFrenetFrame(planning_start_point);  // Choose lane_change_path_config for lane-change cases  // Otherwise, choose default_path_config for normal path planning  // 根据情景选择对应的配置文件  const auto&amp; piecewise_jerk_path_config =      reference_line_info_-&gt;IsChangeLanePath()          ? config_.piecewise_jerk_path_config().lane_change_path_config()          : config_.piecewise_jerk_path_config().default_path_config();  // 根据配置参数，设定l, l&#x27;, l&#x27;&#x27;, l&#x27;&#x27;&#x27;的比重  // 注意l&#x27;的比重和初始速度相关  std::array&lt;double, 5&gt; w = &#123;      piecewise_jerk_path_config.l_weight(),      piecewise_jerk_path_config.dl_weight() *          std::fmax(init_frenet_state.first[1] * init_frenet_state.first[1],                    5.0),      piecewise_jerk_path_config.ddl_weight(),      piecewise_jerk_path_config.dddl_weight(), 0.0&#125;;  // 提取出前面Task得到的边界条件，基于SL坐标系  const auto&amp; path_boundaries =      reference_line_info_-&gt;GetCandidatePathBoundaries();  ADEBUG &lt;&lt; &quot;There are &quot; &lt;&lt; path_boundaries.size() &lt;&lt; &quot; path boundaries.&quot;;  std::vector&lt;PathData&gt; candidate_path_data;  for (const auto&amp; path_boundary : path_boundaries) &#123;    // if the path_boundary is normal, it is possible to have less than 2 points    // skip path boundary of this kind    if (path_boundary.label().find(&quot;regular&quot;) != std::string::npos &amp;&amp;        path_boundary.boundary().size() &lt; 2) &#123;      continue;    &#125;    int max_iter = 4000;    // lower max_iter for regular/self/    if (path_boundary.label().find(&quot;self&quot;) != std::string::npos) &#123;      max_iter = 4000;    &#125;    CHECK_GT(path_boundary.boundary().size(), 1);    std::vector&lt;double&gt; opt_l;    std::vector&lt;double&gt; opt_dl;    std::vector&lt;double&gt; opt_ddl;\t// 设定终点边界条件    std::array&lt;double, 3&gt; end_state = &#123;0.0, 0.0, 0.0&#125;;    if (!FLAGS_enable_force_pull_over_open_space_parking_test) &#123;      // 如果是pull over场景，调整终点边界条件      // pull over scenario      // set end lateral to be at the desired pull over destination      const auto&amp; pull_over_status =          PlanningContext::Instance()-&gt;planning_status().pull_over();      if (pull_over_status.has_position() &amp;&amp;          pull_over_status.position().has_x() &amp;&amp;          pull_over_status.position().has_y() &amp;&amp;          path_boundary.label().find(&quot;pullover&quot;) != std::string::npos) &#123;        common::SLPoint pull_over_sl;        reference_line.XYToSL(pull_over_status.position(), &amp;pull_over_sl);        end_state[0] = pull_over_sl.l();      &#125;    &#125;    // 根据车辆最大曲率，以及车道曲率，求出l&#x27;&#x27;的边界条件    const auto&amp; veh_param =        common::VehicleConfigHelper::GetConfig().vehicle_param();    const double lat_acc_bound =        std::tan(veh_param.max_steer_angle() / veh_param.steer_ratio()) /        veh_param.wheel_base();    std::vector&lt;std::pair&lt;double, double&gt;&gt; ddl_bounds;    for (size_t i = 0; i &lt; path_boundary.boundary().size(); ++i) &#123;      double s = static_cast&lt;double&gt;(i) * path_boundary.delta_s() +                 path_boundary.start_s();      double kappa = reference_line.GetNearestReferencePoint(s).kappa();      ddl_bounds.emplace_back(-lat_acc_bound - kappa, lat_acc_bound - kappa);    &#125;    // 关键步骤，得出结果    bool res_opt =        OptimizePath(init_frenet_state.second, end_state,                     path_boundary.delta_s(), path_boundary.boundary(),                     ddl_bounds, w, &amp;opt_l, &amp;opt_dl, &amp;opt_ddl, max_iter);    if (res_opt) &#123;      // ADEBUG输出，用于数据分析      for (size_t i = 0; i &lt; path_boundary.boundary().size(); i += 4) &#123;        ADEBUG &lt;&lt; &quot;for s[&quot; &lt;&lt; static_cast&lt;double&gt;(i) * path_boundary.delta_s()               &lt;&lt; &quot;], l = &quot; &lt;&lt; opt_l[i] &lt;&lt; &quot;, dl = &quot; &lt;&lt; opt_dl[i];      &#125;      // 将计算结果转化为SL坐标系下的规划路径      auto frenet_frame_path =          ToPiecewiseJerkPath(opt_l, opt_dl, opt_ddl, path_boundary.delta_s(),                              path_boundary.start_s());      // TODO(all): double-check this;      // final_path_data might carry info from upper stream      PathData path_data = *final_path_data;      path_data.SetReferenceLine(&amp;reference_line);      path_data.SetFrenetPath(std::move(frenet_frame_path));      if (FLAGS_use_front_axe_center_in_path_planning) &#123;        // 规划点平移        auto discretized_path = DiscretizedPath(            ConvertPathPointRefFromFrontAxeToRearAxe(path_data));        path_data = *final_path_data;        path_data.SetReferenceLine(&amp;reference_line);        path_data.SetDiscretizedPath(discretized_path);      &#125;      // 计算结果输出，存放在candidate_path_data      path_data.set_path_label(path_boundary.label());      path_data.set_blocking_obstacle_id(path_boundary.blocking_obstacle_id());      candidate_path_data.push_back(std::move(path_data));    &#125;  &#125;  if (candidate_path_data.empty()) &#123;    return Status(ErrorCode::PLANNING_ERROR,                  &quot;Path Optimizer failed to generate path&quot;);  &#125;  // 输出总的计算结果  reference_line_info_-&gt;SetCandidatePathData(std::move(candidate_path_data));  return Status::OK();&#125;\n PiecewiseJerkPathOptimizer::OptimizePath()\nbool PiecewiseJerkPathOptimizer::OptimizePath(    const std::array&lt;double, 3&gt;&amp; init_state,    const std::array&lt;double, 3&gt;&amp; end_state, const double delta_s,    const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; lat_boundaries,    const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; ddl_bounds,    const std::array&lt;double, 5&gt;&amp; w, std::vector&lt;double&gt;* x,    std::vector&lt;double&gt;* dx, std::vector&lt;double&gt;* ddx, const int max_iter) &#123;  // 构造用于OSQP解决器的问题，输入规划的点数，间隔，初始条件  PiecewiseJerkPathProblem piecewise_jerk_problem(lat_boundaries.size(),                                                  delta_s, init_state);  // TODO(Hongyi): update end_state settings  // 设定终点值以及比重  piecewise_jerk_problem.set_end_state_ref(&#123;1000.0, 0.0, 0.0&#125;, end_state);  if (end_state[0] != 0) &#123;    // 根据实际情况设定l的参考值，以及对应比重    // l参考值为终点位置的横向偏差    std::vector&lt;double&gt; x_ref(lat_boundaries.size(), end_state[0]);    const auto&amp; pull_over_type = PlanningContext::Instance()                                     -&gt;planning_status()                                     .pull_over()                                     .pull_over_type();    const double weight_x_ref =        pull_over_type == PullOverStatus::EMERGENCY_PULL_OVER ? 200.0 : 10.0;    piecewise_jerk_problem.set_x_ref(weight_x_ref, x_ref);  &#125;  // 设定l, l&#x27;, l&#x27;&#x27;, l&#x27;&#x27;&#x27;的比重  piecewise_jerk_problem.set_weight_x(w[0]);  piecewise_jerk_problem.set_weight_dx(w[1]);  piecewise_jerk_problem.set_weight_ddx(w[2]);  piecewise_jerk_problem.set_weight_dddx(w[3]);  // 设定比例因子  piecewise_jerk_problem.set_scale_factor(&#123;1.0, 10.0, 100.0&#125;);  // 解决问题开始时间  auto start_time = std::chrono::system_clock::now();  // 设定l, l&#x27;, l&#x27;&#x27;, l&#x27;&#x27;&#x27;的边界条件  piecewise_jerk_problem.set_x_bounds(lat_boundaries);  piecewise_jerk_problem.set_dx_bounds(-FLAGS_lateral_derivative_bound_default,                                       FLAGS_lateral_derivative_bound_default);  piecewise_jerk_problem.set_ddx_bounds(ddl_bounds);  piecewise_jerk_problem.set_dddx_bound(FLAGS_lateral_jerk_bound);  // Estimate lat_acc and jerk boundary from vehicle_params  // 根据车辆参数，设定l&#x27;&#x27;&#x27;，即横向加加速度边界  const auto&amp; veh_param =      common::VehicleConfigHelper::GetConfig().vehicle_param();  const double axis_distance = veh_param.wheel_base();  const double max_yaw_rate =      veh_param.max_steer_angle_rate() / veh_param.steer_ratio() / 2.0;  const double jerk_bound = EstimateJerkBoundary(std::fmax(init_state[1], 1.0),                                                 axis_distance, max_yaw_rate);  piecewise_jerk_problem.set_dddx_bound(jerk_bound);  // 关键步骤，求解问题  bool success = piecewise_jerk_problem.Optimize(max_iter);  // 解决问题结束时间  auto end_time = std::chrono::system_clock::now();  std::chrono::duration&lt;double&gt; diff = end_time - start_time;  ADEBUG &lt;&lt; &quot;Path Optimizer used time: &quot; &lt;&lt; diff.count() * 1000 &lt;&lt; &quot; ms.&quot;;  if (!success) &#123;    AERROR &lt;&lt; &quot;piecewise jerk path optimizer failed&quot;;    return false;  &#125;  // 结果输出  *x = piecewise_jerk_problem.opt_x();  *dx = piecewise_jerk_problem.opt_dx();  *ddx = piecewise_jerk_problem.opt_ddx();  return true;&#125;\n OSQP配置\n使用0.5.0版本。\n-----------------------------------------------------------------           OSQP v0.5.0  -  Operator Splitting QP Solver              (c) Bartolomeo Stellato,  Goran Banjac        University of Oxford  -  Stanford University 2018-----------------------------------------------------------------\n solver settings\n\n\n\nArgument\nDescription\nAllowed values\nDefault value\n\n\n\n\nrho *\nADMM rho step\n0 &lt; rho\n0.1\n\n\nsigma\nADMM sigma step\n0 &lt; sigma\n1e-06\n\n\nmax_iter *\nMaximum number of iterations\n0 &lt; max_iter (integer)\n4000\n\n\neps_abs *\nAbsolute tolerance\n0 &lt;= eps_abs\n1e-03\n\n\neps_rel *\nRelative tolerance\n0 &lt;= eps_rel\n1e-03\n\n\neps_prim_inf *\nPrimal infeasibility tolerance\n0 &lt;= eps_prim_inf\n1e-04\n\n\neps_dual_inf *\nDual infeasibility tolerance\n0 &lt;= eps_dual_inf\n1e-04\n\n\nalpha *\nADMM overrelaxation parameter\n0 &lt; alpha &lt; 2\n1.6\n\n\nlinsys_solver\nLinear systems solver type\nSee Linear Systems Solvers\nqdldl\n\n\ndelta *\nPolishing regularization parameter\n0 &lt; delta\n1e-06\n\n\npolish *\nPerform polishing\nTrue/False\nFalse\n\n\npolish_refine_iter *\nRefinement iterations in polish\n0 &lt; polish_refine_iter (integer)\n3\n\n\nverbose *\nPrint output\nTrue/False\nTrue\n\n\nscaled_termination *\nScaled termination conditions\nTrue/False\nFalse\n\n\ncheck_termination *\nCheck termination interval\n0 (disabled) or 0 &lt; check_termination (integer)\n25\n\n\nwarm_start *\nPerform warm starting\nTrue/False\nTrue\n\n\nscaling\nNumber of scaling iterations\n0 (disabled) or 0 &lt; scaling (integer)\n10\n\n\nadaptive_rho\nAdaptive rho\nTrue/False\nTrue\n\n\nadaptive_rho_interval\nAdaptive rho interval\n0 (automatic) or 0 &lt; adaptive_rho_interval (integer)\n0\n\n\nadaptive_rho_tolerance\nTolerance for adapting rho\n1 &lt;= adaptive_rho_tolerance\n5\n\n\nadaptive_rho_fraction\nAdaptive rho interval as fraction of setup time (auto mode)\n0 &lt; adaptive_rho_fraction\n0.4\n\n\ntime_limit *\nRun time limit in seconds\n0 (disabled) or 0 &lt;= time_limit\n0\n\n\n\n linear systems solvers\n\n\n\nSolver\nString option\nC Constant\nInteger value\n\n\n\n\nQDLDL\n“qdldl”\nQDLDL_SOLVER\n0\n\n\nMKL Pardiso\n“mkl pardiso”\nMKL_PARDISO_SOLVER\n1\n\n\n\n slover errors\n\n\n\nErrors\nConstant\nValue\n\n\n\n\nData validation\nOSQP_DATA_VALIDATION_ERROR\n1\n\n\nSettings validation\nOSQP_SETTINGS_VALIDATION_ERROR\n2\n\n\nLinear system solver loading\nOSQP_LINSYS_SOLVER_LOAD_ERROR\n3\n\n\nLinear system solver initialization\nOSQP_LINSYS_SOLVER_INIT_ERROR\n4\n\n\nNon convex problem\nOSQP_NONCVX_ERROR\n5\n\n\nMemory allocation\nOSQP_MEM_ALLOC_ERROR\n6\n\n\nWorkspace not initialized\nOSQP_WORKSPACE_NOT_INIT\n7\n\n\n\n result\nThe problem can be solved by\nresults = m.solve()\nThe results object contains the primal solution x, the dual solution y, certificate of primal infeasibility prim_inf_cert, certificate of dual infeasibility dual_inf_cert and the info object containing the solver statistics defined in the following table\n\n\n\nMember\nDescription\n\n\n\n\niter\nNumber of iterations\n\n\nstatus\nSolver status\n\n\nstatus_val\nSolver status value as in Status values and errors\n\n\nstatus_polish\nPolishing status\n\n\nobj_val\nObjective value\n\n\npri_res\nPrimal residual\n\n\ndua_res\nDual residual\n\n\nsetup_time\nSetup time\n\n\nsolve_time\nSolve time\n\n\nupdate_time\nUpdate time\n\n\npolish_time\nPolish time\n\n\nrun_time\nTotal run time: setup/update + solve + polish\n\n\nrho_estimate\nOptimal rho estimate\n\n\nrho_updates\nNumber of rho updates\n\n\n\nNote that if multiple solves are executed from single setup, then after the first one run_time includes update_time + solve_time + polish_time.\n","categories":["算法","Apollo源码解读"]},{"title":"（一）分段加加速度算法（PiecewiseJerk）之 路径规划理论推演","url":"/2021/09/14/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E6%8E%A8%E6%BC%94/","content":"这篇文章系统推导了分段加加速度（Piecewise Jerk）算法在路径规划中的数学模型，通过构建包含横向位置、一阶导、二阶导与三阶导的优化目标函数及约束条件，将其转化为标准的二次规划问题（QP），便于使用 OSQP 求解器实现轨迹优化。文中详细推导了每一项对 Kernel Matrix 和 Offset Vector 的贡献，并分析了初值约束、速度约束、距离约束等关键因素，为实际路径平滑提供了坚实的理论基础。\n\n 矩阵基本运算\nx=(x1x2x3x4)4×1x = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1}\nx=⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​\n则：\nxT⋅wxI4×4⋅x=(x1x2x3x4)1×4⋅wx(1000010000100001)4×4⋅(x1x2x3x4)4×1=wxx12+wxx22+wxx32+wxx42=wx∑i=14xi2\\begin{aligned}\nx^T\\cdot w_{x}\\textbf{I}_{4\\times4} \\cdot x &amp; =\\begin{pmatrix} x_1 &amp; x_2 &amp; x_3 &amp; x_4 \\end{pmatrix}_{1\\times4} \n\\cdot w_{x}\n\\begin{pmatrix} \n1 &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; 1 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1 \\\\\n\\end{pmatrix}_{4\\times4}\n\\cdot\n\\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\x_4 \\end{pmatrix}_{4\\times1} \\\\\n&amp; = w_{x}x_1^2+w_{x}x_2^2+w_{x}x_3^2+w_{x}x_4^2 \\\\\n&amp; = w_{x} \\sum_{i=1}^{4}x_i^2\n\\end{aligned}\nxT⋅wx​I4×4​⋅x​=(x1​​x2​​x3​​x4​​)1×4​⋅wx​⎝⎜⎜⎜⎛​1000​0100​0010​0001​⎠⎟⎟⎟⎞​4×4​⋅⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​4×1​=wx​x12​+wx​x22​+wx​x32​+wx​x42​=wx​i=1∑4​xi2​​\n 理论推演\n优化目标函数，以路径规划(基于SL坐标系)为例：\nf=(wl+wl_ref)∑i=0n−1(li−lref_i)2+wl′∑i=0n−1li′2+wl′′∑i=0n−1li′′2+wl′′′∑i=0n−2li→i+1′′′2f = (w_l +w_{l\\_ref})\\sum_{i=0}^{n-1}(l_i-l_{ref\\_i})^2 + \n   w_{l&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;2} + \n   w_{l&#x27;&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;&#x27;2} + \n   w_{l&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}l_{i \\rightarrow i+1}^{&#x27;&#x27;&#x27;2}\nf=(wl​+wl_ref​)i=0∑n−1​(li​−lref_i​)2+wl′​i=0∑n−1​li′2​+wl′′​i=0∑n−1​li′′2​+wl′′′​i=0∑n−2​li→i+1′′′2​\nsubjectto:(l0l0′l0′′)=(linitlinit′linit′′)l(k)′′′=l′′(k+1)−l′′(k)dsl′(k+1)−l′(k)=l′′(k+1)+l′′(k)2dsl(k+1)=l(k)+l′(k)ds+l′′(k)2ds2+l′′′(k)6ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative\\begin{aligned}\nsubject \\quad to:\\quad \n\\begin{pmatrix} l_0 \\\\ l&#x27;_0 \\\\ l&#x27;&#x27;_0\\end{pmatrix} = \\begin{pmatrix} l_{init} \\\\ l&#x27;_{init} \\\\ l&#x27;&#x27;_ {init} \\end{pmatrix} \\\\\nl(k)&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1)-l&#x27;&#x27;(k)}{ds} \\\\\nl&#x27;(k+1)-l&#x27;(k)=\\frac{l&#x27;&#x27;(k+1)+l&#x27;&#x27;(k)}{2}ds \\\\\nl(k+1)=l(k)+l&#x27;(k)ds+\\frac{l&#x27;&#x27;(k)}{2}ds^2+\\frac{l&#x27;&#x27;&#x27;(k)}{6}ds^3 \\\\\nl\\_bounds\\_.first\\leq l \\leq l\\_bounds\\_.second \\\\\ndl\\_bounds\\_.first\\leq l&#x27; \\leq dl\\_bounds\\_.second \\\\\nddl\\_bounds\\_.first\\leq l&#x27;&#x27; \\leq ddl\\_bounds\\_.second \\\\\n-max\\_l\\_third\\_order\\_derivative \\leq l&#x27;&#x27;&#x27; \\leq max\\_l\\_third\\_order\\_derivative\n\\end{aligned}\nsubjectto:⎝⎛​l0​l0′​l0′′​​⎠⎞​=⎝⎛​linit​linit′​linit′′​​⎠⎞​l(k)′′′=dsl′′(k+1)−l′′(k)​l′(k+1)−l′(k)=2l′′(k+1)+l′′(k)​dsl(k+1)=l(k)+l′(k)ds+2l′′(k)​ds2+6l′′′(k)​ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative​\n为了使用OSQP解决器，需要将问题转化为以下形式，即，OSQP（Operator Splitting Quadratic Program）二次规划求解器用于求解如下非线性优化问题：\nminimize12xTPx+qTxsubjectto:l≤Ax≤u\\begin{aligned}\nminimize \\quad \\frac{1}{2}x^T\\textbf{P}x+\\textbf{q}^Tx \\\\\nsubject \\quad to: \\quad \\textbf{l}\\leq \\textbf{A}x\\leq \\textbf{u}\n\\end{aligned}\nminimize21​xTPx+qTxsubjectto:l≤Ax≤u​\n其中：xxx是优化变量，P∈S+n\\textbf{P}\\in\\textbf{S}_+^nP∈S+n​是半正定Hessian矩阵，称为Kernel matrix；q∈Rn\\textbf{q}\\in\\textbf{R}^nq∈Rn是梯度向量，称为Offset matrix；线性约束矩阵A∈Rm×n\\textbf{A}\\in\\textbf{R}^{m \\times n}A∈Rm×n，称为Affine constraint matrix。\n比重系数有：wx、wx′、wx′′、wx′′′以及wx_ref、wx′_ref和Penalityx′w_x、w_{x&#x27;}、w_{x&#x27;&#x27;}、w_{x&#x27;&#x27;&#x27;}以及w_{x\\_ref}、w_{x&#x27;\\_ref}和Penality_{x&#x27;}wx​、wx′​、wx′′​、wx′′′​以及wx_ref​、wx′_ref​和Penalityx′​ \n 路径规划目标函数转化\nf=(wl+wl_ref)∑i=0n−1(li−lref_i)2+wl′∑i=0n−1li′2+wl′′∑i=0n−1li′′2+wl′′′∑i=0n−2li→i+1′′′2(1)f = (w_l +w_{l\\_ref})\\sum_{i=0}^{n-1}(l_i-l_{ref\\_i})^2 + \n    w_{l&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;2} + \n    w_{l&#x27;&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;&#x27;2} + \n    w_{l&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}l_{i \\rightarrow i+1}^{&#x27;&#x27;&#x27;2}  \\tag 1\nf=(wl​+wl_ref​)i=0∑n−1​(li​−lref_i​)2+wl′​i=0∑n−1​li′2​+wl′′​i=0∑n−1​li′′2​+wl′′′​i=0∑n−2​li→i+1′′′2​(1)\nf=wl∑i=0n−1li2+wl′∑i=0n−1li′2+wl′′∑i=0n−1li′′2+wl′′′∑i=0n−2li→i+1′′′2+wobs∑i=0n−1(li−limin+limax2)2(2)f = w_l\\sum_{i=0}^{n-1}l_i^2 + \n    w_{l&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;2} + \n    w_{l&#x27;&#x27;} \\sum_{i=0}^{n-1}l_i^{&#x27;&#x27;2} + \n    w_{l&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}l_{i \\rightarrow i+1}^{&#x27;&#x27;&#x27;2} + \n    w_{obs}\\sum_{i=0}^{n-1}(l_i - \\frac{l_i^{min} + l_i^{max}}{2})^2  \\tag 2\nf=wl​i=0∑n−1​li2​+wl′​i=0∑n−1​li′2​+wl′′​i=0∑n−1​li′′2​+wl′′′​i=0∑n−2​li→i+1′′′2​+wobs​i=0∑n−1​(li​−2limin​+limax​​)2(2)\n方程(1)与方程(2)其实是一致的，可以认为lref_i为limin+limax2l_{ref\\_i}为\\frac{l_i^{min}+l_i^{max}}{2}lref_i​为2limin​+limax​​。\n以下推导以方程(1)为例：\nsubjectto:(l0l0′l0′′)=(linitlinit′linit′′)l(k)′′′=l′′(k+1)−l′′(k)dsl′(k+1)−l′(k)=l′′(k+1)+l′′(k)2dsl(k+1)=l(k)+l′(k)ds+l′′(k)2ds2+l′′′(k)6ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative\\begin{aligned}\nsubject \\quad to:\\quad \n\\begin{pmatrix} l_0 \\\\ l&#x27;_0 \\\\ l&#x27;&#x27;_0\\end{pmatrix} = \\begin{pmatrix} l_{init} \\\\ l&#x27;_{init} \\\\ l&#x27;&#x27;_ {init} \\end{pmatrix} \\\\\nl(k)&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1)-l&#x27;&#x27;(k)}{ds} \\\\\nl&#x27;(k+1)-l&#x27;(k)=\\frac{l&#x27;&#x27;(k+1)+l&#x27;&#x27;(k)}{2}ds \\\\\nl(k+1)=l(k)+l&#x27;(k)ds+\\frac{l&#x27;&#x27;(k)}{2}ds^2+\\frac{l&#x27;&#x27;&#x27;(k)}{6}ds^3 \\\\\nl\\_bounds\\_.first\\leq l \\leq l\\_bounds\\_.second \\\\\ndl\\_bounds\\_.first\\leq l&#x27; \\leq dl\\_bounds\\_.second \\\\\nddl\\_bounds\\_.first\\leq l&#x27;&#x27; \\leq ddl\\_bounds\\_.second \\\\\n-max\\_l\\_third\\_order\\_derivative \\leq l&#x27;&#x27;&#x27; \\leq max\\_l\\_third\\_order\\_derivative\n\\end{aligned}\nsubjectto:⎝⎛​l0​l0′​l0′′​​⎠⎞​=⎝⎛​linit​linit′​linit′′​​⎠⎞​l(k)′′′=dsl′′(k+1)−l′′(k)​l′(k+1)−l′(k)=2l′′(k+1)+l′′(k)​dsl(k+1)=l(k)+l′(k)ds+2l′′(k)​ds2+6l′′′(k)​ds3l_bounds_.first≤l≤l_bounds_.seconddl_bounds_.first≤l′≤dl_bounds_.secondddl_bounds_.first≤l′′≤ddl_bounds_.second−max_l_third_order_derivative≤l′′′≤max_l_third_order_derivative​\n优化变量\nx=((x)n×1(x′)n×1(x′′)n×1)3n×1\\textbf{x} = \\begin{pmatrix} (x)_{n\\times1} \\\\ (x&#x27;)_{n\\times1} \\\\(x&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\nx=⎝⎛​(x)n×1​(x′)n×1​(x′′)n×1​​⎠⎞​3n×1​\n分别表示l,dl,ddll,dl,ddll,dl,ddl，也就是l,l′,l′′l,l&#x27;,l&#x27;&#x27;l,l′,l′′​\nl=((l)n×1(l′)n×1(l′′)n×1)3n×1\\textbf{l} =\\begin{pmatrix} (l)_{n\\times1} \\\\ (l&#x27;)_{n\\times1} \\\\(l&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\nl=⎝⎛​(l)n×1​(l′)n×1​(l′′)n×1​​⎠⎞​3n×1​\n有3n个优化变量，n-1个优化点，加上初始位置，总共有n个点。\n 优化变量-横向位置\n(l)n×1(l)_{n\\times1}(l)n×1​​\n平滑lll距离lrefl_{ref}lref​越近越好，目标函数：\nminimize(wl+wl_ref)(l−lref)2=(wl+wl_ref)(l2−2llref+lref2)minimize \\quad (w_l + w_{l\\_ref})(l - l_{ref})^2 = (w_l + w_{l\\_ref})(l^2-2ll_{ref} + l_{ref}^2)\nminimize(wl​+wl_ref​)(l−lref​)2=(wl​+wl_ref​)(l2−2llref​+lref2​)\n其中lref2l_{ref}^2lref2​为常数，可以省略，因此化简得到：\nminimize(wl+wl_ref)(l2−2llref)minimize \\quad (w_l + w_{l\\_ref})(l^2-2ll_{ref})\nminimize(wl​+wl_ref​)(l2−2llref​)\n前一项(wl+wl_ref)l2(w_l+ w_{l\\_ref})l^2(wl​+wl_ref​)l2​​​​中的系数(wl+wl_ref)(w_l + w_{l\\_ref})(wl​+wl_ref​)​​​​放入矩阵P\\textbf{P}P​​​​的第一块\nP=((wl+wl_ref)In×n)3n×3n\\textbf{P}=\\begin{pmatrix} (w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\  \\\\ \\end{pmatrix}_{3n \\times 3n}\nP=((wl​+wl_ref​)In×n​​)3n×3n​\n后一项−2(wl+wl_ref)lrefl-2(w_l+w_{l\\_ref})l_{ref}l−2(wl​+wl_ref​)lref​l中的系数−2(wl+wl_ref)lref-2(w_l+w_{l\\_ref})l_{ref}−2(wl​+wl_ref​)lref​放入矩阵q\\textbf{q}q的第一块\nq=((−2(wl+wl_ref)lref)n×1)3n×1\\textbf{q} = \\begin{pmatrix} (-2(w_l+w_{l\\_ref})l_{ref})_{n\\times 1} \\\\  \\\\ \\end{pmatrix}_{3n \\times 1}\nq=((−2(wl​+wl_ref​)lref​)n×1​​)3n×1​\n其中lref=(lmin+lmax)/2l_{ref}=(l_{min} + l_{max})/2lref​=(lmin​+lmax​)/2​​​，由边界决定；或者由决策路径决定。\n 不等约束\nlmin≤l≤lmaxl_{min}\\leq l\\leq l_{max}lmin​≤l≤lmax​​得到\nA=(In×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\  \n\\quad\n\\end{pmatrix}\nA=(In×n​​)\nl=((lmin)n×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=((lmin​)n×1​​)\nu=((lmax)n×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=((lmax​)n×1​​)\n 优化变量-横向一阶导\n(l′)n×1(l&#x27;)_{n\\times1}\n(l′)n×1​\n越小越好，目标函数：\nminimizewl′l′2minimize \\quad w_{l&#x27;}l&#x27;^2\nminimizewl′​l′2\n系数wl′w_{l&#x27;}wl′​放入矩阵P\\textbf{P}P的第二块\nP=((wl+wl_ref)In×nwl′In×n)3n×3n\\textbf{P} =\n\\begin{pmatrix} \n(w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; w_{l&#x27;}\\textbf{I}_{n\\times n} &amp;  \\\\ \n\\end{pmatrix}_{3n \\times 3n}\nP=((wl​+wl_ref​)In×n​​wl′​In×n​​​)3n×3n​\n没有一次项，则矩阵q\\textbf{q}q的第二块\nq=((−2(wl+wl_ref)lref)n×1(0)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2(w_l+w_{l\\_ref})l_{ref})_{n\\times 1} \\\\ \n(0)_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎛​(−2(wl​+wl_ref​)lref​)n×1​(0)n×1​​⎠⎞​3n×1​\n 不等约束\nlmin′≤l′≤lmax′l&#x27;_{min}\\leq l&#x27; \\leq l&#x27;_{max}lmin′​≤l′≤lmax′​​得到\nA=(In×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n\\quad\n\\end{pmatrix}\nA=⎝⎛​In×n​​In×n​​​⎠⎞​\nl=((lmin)n×1(lmin′)n×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎛​(lmin​)n×1​(lmin′​)n×1​​⎠⎞​\nu=((lmax)n×1(lmax′)n×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎛​(lmax​)n×1​(lmax′​)n×1​​⎠⎞​\n 优化变量-横向二阶导\n(l′′)n×1(l&#x27;&#x27;)_{n\\times 1}\n(l′′)n×1​\n越小越好，目标函数：\nminimizewl′′l′′2minimize \\quad w_{l&#x27;&#x27;}l&#x27;&#x27;^2\nminimizewl′′​l′′2\n前一项wl′′l′′2w_{l&#x27;&#x27;}l&#x27;&#x27;^2wl′′​l′′2​​​中的系数wl′′w_{l&#x27;&#x27;}wl′′​​​​放入矩阵P\\textbf{P}P​​​的第三块\nP=((wl+wl_ref)In×nwl′In×nwl′′In×n)3n×3n\\textbf{P}=\\begin{pmatrix} \n(w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; w_{l&#x27;}\\textbf{I}_{n\\times n} &amp;  \\\\  \n&amp; &amp; w_{l&#x27;&#x27;}\\textbf{I}_{n\\times n}\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​(wl​+wl_ref​)In×n​​wl′​In×n​​wl′′​In×n​​⎠⎞​3n×3n​\n这里矩阵q\\textbf{q}q的第三块只在最后一行，即，终点加速度有一个约束−2wx′′xend′′-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}−2wx′′​xend′′​，因此有：\nq=((−2(wl+wl_ref)lref)n×1(0)n×1(0⋮0−2wl′′lend′′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2(w_l+w_{l\\_ref})l_{ref})_{n\\times 1} \\\\ \n(0)_{n\\times 1} \\\\\n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{l&#x27;&#x27;}l&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​(−2(wl​+wl_ref​)lref​)n×1​(0)n×1​⎝⎜⎜⎜⎜⎛​0⋮0−2wl′′​lend′′​​⎠⎟⎟⎟⎟⎞​n×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​3n×1​\n由此得到Offset matrix。\n 不等约束\nlmin′′≤l′′≤lmax′′l&#x27;&#x27;_{min}\\leq l&#x27;&#x27; \\leq l&#x27;&#x27;_{max}lmin′′​≤l′′≤lmax′′​​得到\nA=(In×nIn×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n\\quad\n\\end{pmatrix}\nA=⎝⎜⎜⎜⎛​In×n​​In×n​​In×n​​⎠⎟⎟⎟⎞​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​​⎠⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​​⎠⎟⎟⎟⎞​\n 优化变量-加加速度\n(l′′′)n×1(l&#x27;&#x27;&#x27;)_{n \\times 1}\n(l′′′)n×1​\n加加速度越小越好，目标函数：\nminimizewl′′′l′′′2=wl′′′(l′′(k+1)−l′′(k)ds)2=wl′′′ds2(l′′(k+1)2−2l′′(k+1)l′′(k)+l′′(k)2)\\begin{aligned}\nminimize \\quad w_{l&#x27;&#x27;&#x27;}l&#x27;&#x27;&#x27;^2 = w_{l&#x27;&#x27;&#x27;}(\\frac{l&#x27;&#x27;(k+1) - l&#x27;&#x27;(k)}{ds})^2\\\\\n= \\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(k+1)^2 - 2l&#x27;&#x27;(k+1)l&#x27;&#x27;(k) + l&#x27;&#x27;(k)^2)\n\\end{aligned}\nminimizewl′′′​l′′′2=wl′′′​(dsl′′(k+1)−l′′(k)​)2=ds2wl′′′​​(l′′(k+1)2−2l′′(k+1)l′′(k)+l′′(k)2)​\n这样变换以后相当于目标函数降低了一阶，记矩阵P\\textbf{P}P的第三块子矩阵为P3\\textbf{P}_3P3​，则目前\nP3=wl′′In×n\\textbf{P}_3=w_{l&#x27;&#x27;}\\textbf{I}_{n\\times n}\nP3​=wl′′​In×n​\n要将上述的目标函数转换成矩阵形式并添加到矩阵P3\\textbf{P}_3P3​中去，以n=5为例进行推演。\nwl′′′ds2(l′′(2)2−2l′′(2)l′′(1)+l′′(1)2)+wl′′′ds2(l′′(3)2−2l′′(3)l′′(2)+l′′(2)2)+wl′′′ds2(l′′(4)2−2l′′(4)l′′(3)+l′′(3)2)+wl′′′ds2(l′′(5)2−2l′′(5)l′′(4)+l′′(4)2)=l′′(1)(wl′′′ds2l′′(1)−2wl′′′ds2l′′(2))+l′′(2)(2wl′′′ds2l′′(2)−2wl′′′ds2l′′(3))+l′′(3)(2wl′′′ds2l′′(3)−2wl′′′ds2l′′(4))+l′′(4)(2wl′′′ds2l′′(4)−2wl′′′ds2l′′(5))+l′′(5)wl′′′ds2l′′(5)=(wl′′′ds2l′′(1)−2wl′′′ds2l′′(2)2wl′′′ds2l′′(2)−2wl′′′ds2l′′(3)2wl′′′ds2l′′(3)−2wl′′′ds2l′′(4)2wl′′′ds2l′′(4)−2wl′′′ds2l′′(5)wl′′′ds2l′′(5))T(l′′(1)l′′(2)l′′(3)l′′(4)l′′(5))=(l′′(1)l′′(2)l′′(3)l′′(4)l′′(5))T(wl′′′ds20000−2wl′′′ds22wl′′′ds20000−2wl′′′ds22wl′′′ds20000−2wl′′′ds22wl′′′ds20000−2wl′′′ds2wl′′′ds2)(l′′(1)l′′(2)l′′(3)l′′(4)l′′(5))\\begin{aligned}\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(2)^2 - 2l&#x27;&#x27;(2)l&#x27;&#x27;(1) + l&#x27;&#x27;(1)^2) + \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(3)^2 - 2l&#x27;&#x27;(3)l&#x27;&#x27;(2) + l&#x27;&#x27;(2)^2) \\\\ +\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(4)^2 - 2l&#x27;&#x27;(4)l&#x27;&#x27;(3) + l&#x27;&#x27;(3)^2) +\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}(l&#x27;&#x27;(5)^2 - 2l&#x27;&#x27;(5)l&#x27;&#x27;(4) + l&#x27;&#x27;(4)^2) \\\\\n= \nl&#x27;&#x27;(1)(\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(1) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2)) + \nl&#x27;&#x27;(2)(2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2)- 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3)) \\\\ +\nl&#x27;&#x27;(3)(2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3)- 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4)) + \nl&#x27;&#x27;(4)(2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4)- 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5)) + \nl&#x27;&#x27;(5)\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5) \\\\ \n= \\begin{pmatrix} \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(1) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2) \\\\ \n2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(2) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3) \\\\ \n2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(3) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4) \\\\\n2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(4) - 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5) \\\\\n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2}l&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \nl&#x27;&#x27;(1) \\\\ \nl&#x27;&#x27;(2) \\\\ \nl&#x27;&#x27;(3) \\\\\nl&#x27;&#x27;(4) \\\\\nl&#x27;&#x27;(5) \\\\\n\\end{pmatrix} \\\\\n= \\begin{pmatrix} \nl&#x27;&#x27;(1) \\\\ \nl&#x27;&#x27;(2) \\\\ \nl&#x27;&#x27;(3) \\\\\nl&#x27;&#x27;(4) \\\\\nl&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \n-2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; -2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; -2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; -2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; \\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}\n\\begin{pmatrix} \nl&#x27;&#x27;(1) \\\\ \nl&#x27;&#x27;(2) \\\\ \nl&#x27;&#x27;(3) \\\\\nl&#x27;&#x27;(4) \\\\\nl&#x27;&#x27;(5) \\\\\n\\end{pmatrix}\n\\end{aligned}\nds2wl′′′​​(l′′(2)2−2l′′(2)l′′(1)+l′′(1)2)+ds2wl′′′​​(l′′(3)2−2l′′(3)l′′(2)+l′′(2)2)+ds2wl′′′​​(l′′(4)2−2l′′(4)l′′(3)+l′′(3)2)+ds2wl′′′​​(l′′(5)2−2l′′(5)l′′(4)+l′′(4)2)=l′′(1)(ds2wl′′′​​l′′(1)−2ds2wl′′′​​l′′(2))+l′′(2)(2ds2wl′′′​​l′′(2)−2ds2wl′′′​​l′′(3))+l′′(3)(2ds2wl′′′​​l′′(3)−2ds2wl′′′​​l′′(4))+l′′(4)(2ds2wl′′′​​l′′(4)−2ds2wl′′′​​l′′(5))+l′′(5)ds2wl′′′​​l′′(5)=⎝⎜⎜⎜⎜⎜⎛​ds2wl′′′​​l′′(1)−2ds2wl′′′​​l′′(2)2ds2wl′′′​​l′′(2)−2ds2wl′′′​​l′′(3)2ds2wl′′′​​l′′(3)−2ds2wl′′′​​l′′(4)2ds2wl′′′​​l′′(4)−2ds2wl′′′​​l′′(5)ds2wl′′′​​l′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​l′′(1)l′′(2)l′′(3)l′′(4)l′′(5)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​l′′(1)l′′(2)l′′(3)l′′(4)l′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​ds2wl′′′​​−2ds2wl′′′​​000​02ds2wl′′′​​−2ds2wl′′′​​00​002ds2wl′′′​​−2ds2wl′′′​​0​0002ds2wl′′′​​−2ds2wl′′′​​​0000ds2wl′′′​​​⎠⎟⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎜⎛​l′′(1)l′′(2)l′′(3)l′′(4)l′′(5)​⎠⎟⎟⎟⎟⎟⎞​​\n因此，P3\\textbf{P}_3P3​中需要附加上以下矩阵\n(01×n−10(−2wl′′′ds2)In−1×n−10n−1×1)n×n+(wl′′′ds201×n−200n−2×1(2wl′′′ds2)In−2×n−20n−2×1001×n−2wl′′′ds2)n×n\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \n\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; \\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\n(01×n−1​(−2ds2wl′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​ds2wl′′′​​0n−2×1​0​01×n−2​(2ds2wl′′′​​)In−2×n−2​01×n−2​​00n−2×1​ds2wl′′′​​​⎠⎞​n×n​\n加上该矩阵后，矩阵P3\\textbf{P}_3P3​变换为\nP3=(01×n−10(−2wl′′′ds2)In−1×n−10n−1×1)n×n+(wl′′+wl′′′ds201×n−200n−2×1(wl′′+2wl′′′ds2)In−2×n−20n−2×1001×n−2wl′′+wl′′′ds2)n×n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{l&#x27;&#x27;}+\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{l&#x27;&#x27;}+2\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{l&#x27;&#x27;}+\\frac{w_{l&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\nP3​=(01×n−1​(−2ds2wl′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wl′′​+ds2wl′′′​​0n−2×1​0​01×n−2​(wl′′​+2ds2wl′′′​​)In−2×n−2​01×n−2​​00n−2×1​wl′′​+ds2wl′′′​​​⎠⎞​n×n​\n由此得到Kernel matrix\nP=((wl+wl_ref)In×nwl′In×nP3)3n×3n\\textbf{P}=\\begin{pmatrix} \n(w_l + w_{l\\_ref})\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; w_{l&#x27;}\\textbf{I}_{n\\times n} &amp;  \\\\  \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​(wl​+wl_ref​)In×n​​wl′​In×n​​P3​​⎠⎞​3n×3n​\n 不等约束\nlmin′′′≤l′′′≤lmax′′′l&#x27;&#x27;&#x27;_{min} \\leq l&#x27;&#x27;&#x27; \\leq l&#x27;&#x27;&#x27;_{max}lmin′′′​≤l′′′≤lmax′′′​​\n因为\nl′′′=l′′(k+1)−l′′(k)dsl&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1) - l&#x27;&#x27;(k)}{ds}\nl′′′=dsl′′(k+1)−l′′(k)​\n所以加加速度约束转化为加速度约束\nlmin′′′⋅ds≤−l′′(k)+l′′(k+1)≤lmax′′′⋅dsl&#x27;&#x27;&#x27;_{min}\\cdot ds \\leq -l&#x27;&#x27;(k) + l&#x27;&#x27;(k+1) \\leq l&#x27;&#x27;&#x27;_{max}\\cdot ds\nlmin′′′​⋅ds≤−l′′(k)+l′′(k+1)≤lmax′′′​⋅ds\n因此得到\nA=(In×nIn×nIn×nA1)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎛​In×n​​In×n​​In×n​A1​​⎠⎟⎟⎟⎟⎟⎞​×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\n其中\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×n\\textbf{A}_1 = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA1​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 等式约束\n最终我们将会得到这样一个Affine constraint matrix\n 速度等式约束\nl′l&#x27;l′​在前后两个点之间的变化要满足等式约束：\ndl′ds=l′′,存在ξ∈(k,k+1)，使得l′(k+1)−l′(k)=l′′(ξ)⋅ds\\frac{dl&#x27;}{ds}=l&#x27;&#x27;,存在\\xi \\in(k,k+1)，使得l&#x27;(k+1) - l&#x27;(k) = l&#x27;&#x27;(\\xi)\\cdot ds\ndsdl′​=l′′,存在ξ∈(k,k+1)，使得l′(k+1)−l′(k)=l′′(ξ)⋅ds\n假设l′′(ξ)=l′′(k+1)+l′′(k)2l&#x27;&#x27;(\\xi)=\\frac{l&#x27;&#x27;(k+1) + l&#x27;&#x27;(k)}{2}l′′(ξ)=2l′′(k+1)+l′′(k)​​​​，则\nl′(k+1)−l′(k)=l′′(k+1)+l′′(k)2⋅ds  ⟺  [−l′(k)+l′(k+1)]−ds2[l′′(k)+l′′(k+1)]=0l&#x27;(k+1) - l&#x27;(k) = \\frac{l&#x27;&#x27;(k+1) + l&#x27;&#x27;(k)}{2}\\cdot ds \\\\\n\\iff \n[ - l&#x27;(k) + l&#x27;(k+1) ] - \\frac{ds}{2}[l&#x27;&#x27;(k) + l&#x27;&#x27;(k+1)]=0\nl′(k+1)−l′(k)=2l′′(k+1)+l′′(k)​⋅ds⟺[−l′(k)+l′(k+1)]−2ds​[l′′(k)+l′′(k+1)]=0\n得到\nA=(In×nIn×nIn×nA1A1A2)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1&amp; \\textbf{A}_2 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎛​In×n​​In×n​A1​​In×n​A1​A2​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×n\\textbf{A}_2 = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA2​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 距离等式约束\nlll在前后两个点之间的变化要满足等式约束：\nl(k+1)=l(k)+l′(k)⋅ds+l′′(k)2⋅ds2+l′′′(k)6⋅ds3l′′′=l′′(k+1)−l′′(k)ds  ⟺  l(k+1)=l(k)+l′(k)⋅ds+l′′(k)3⋅ds2+l′′(k+1)6⋅ds2\\begin{aligned}\nl(k+1) = l(k) + l&#x27;(k)\\cdot ds + \\frac{l&#x27;&#x27;(k)}{2}\\cdot ds^2 + \\frac{l&#x27;&#x27;&#x27;(k)}{6}\\cdot ds^3 \\\\\nl&#x27;&#x27;&#x27;=\\frac{l&#x27;&#x27;(k+1) - l&#x27;&#x27;(k)}{ds} \\\\\n\\iff \\\\\nl(k+1) = l(k) + l&#x27;(k)\\cdot ds + \\frac{l&#x27;&#x27;(k)}{3}\\cdot ds^2 + \\frac{l&#x27;&#x27;(k+1)}{6}\\cdot ds^2\n\\end{aligned}\nl(k+1)=l(k)+l′(k)⋅ds+2l′′(k)​⋅ds2+6l′′′(k)​⋅ds3l′′′=dsl′′(k+1)−l′′(k)​⟺l(k+1)=l(k)+l′(k)⋅ds+3l′′(k)​⋅ds2+6l′′(k+1)​⋅ds2​\n即\n[−l(k)+l(k+1)]−ds⋅l′(k)−ds23(l′′(k)+l′′(k+1)2)=0[-l(k) + l(k+1)] - ds\\cdot l&#x27;(k) - \\frac{ds^2}{3}(l&#x27;&#x27;(k) + \\frac{l&#x27;&#x27;(k+1)}{2})=0\n[−l(k)+l(k+1)]−ds⋅l′(k)−3ds2​(l′′(k)+2l′′(k+1)​)=0\n得到\nA=(In×nIn×nIn×nA1A1A2A1A3A4)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​​In×n​A1​A3​​In×n​A1​A2​A4​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×10n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×10n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×n\\textbf{A}_3 = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA3​=−ds⋅In−1×n​A4​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 初值等式约束\n速度规划的第一个点的初始值：l,l′,l′′l,l&#x27;,l&#x27;&#x27;l,l′,l′′​取值为linit=(l0l0′l0′′)l_{init} = \\begin{pmatrix} l_0 \\\\ l&#x27;_0 \\\\ l&#x27;&#x27;_0\\end{pmatrix}linit​=⎝⎛​l0​l0′​l0′′​​⎠⎞​​，因此\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((lmin)n×1(lmin′)n×1(lmin′′)n×1(lmin′′′⋅ds)n−1×10n−1×10n−1×1linit)6n×1\\textbf{l} = \\begin{pmatrix} \n(l_{min})_{n\\times 1} \\\\ \n(l&#x27;_{min})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{min})_{n\\times 1} \\\\\n(l&#x27;&#x27;&#x27;_{min}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nl_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmin​)n×1​(lmin′​)n×1​(lmin′′​)n×1​(lmin′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​linit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((lmax)n×1(lmax′)n×1(lmax′′)n×1(lmax′′′⋅ds)n−1×10n−1×10n−1×1linit)6n×1\\textbf{u} = \\begin{pmatrix} \n(l_{max})_{n\\times 1} \\\\ \n(l&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;_{max})_{n\\times 1} \\\\ \n(l&#x27;&#x27;&#x27;_{max}\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nl_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(lmax​)n×1​(lmax′​)n×1​(lmax′′​)n×1​(lmax′′′​⋅ds)n−1×1​0n−1×1​0n−1×1​linit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\n其中\nA5=(10⋯0)1×n\\textbf{A}_5=\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\nA5​=(1​0​⋯​0​)1×n​\n由此得到Affine constraint matrix。\n 曲率约束\nκ=((l′′+(κr′l+κrl′)tanΔθ)cos2Δθ1−κr+κr)cosΔθ1−κrl\\kappa = \\frac{(\\frac{(l&#x27;&#x27;+(\\kappa_r&#x27;l+\\kappa_rl&#x27;)tan\\Delta\\theta)cos^2\\Delta\\theta}{1-\\kappa_r} + \\kappa_r)cos\\Delta\\theta}{1-\\kappa_rl}\nκ=1−κr​l(1−κr​(l′′+(κr′​l+κr​l′)tanΔθ)cos2Δθ​+κr​)cosΔθ​\n−κmax&lt;κ≈κr1−κrl&lt;κmax正常情况下：1−κrl&gt;0\\begin{aligned}\n-\\kappa_{max} &lt; \\kappa \\approx \\frac{\\kappa_r}{1-\\kappa_rl} &lt; \\kappa_{max} \\\\\n正常情况下：1-\\kappa_rl &gt; 0 \\\\\n\\end{aligned}\n−κmax​&lt;κ≈1−κr​lκr​​&lt;κmax​正常情况下：1−κr​l&gt;0​\nκr,κr′\\kappa_r, \\kappa_r&#x27;κr​,κr′​是驾驶引导线上的点曲率和曲率的变化率，Δθ\\Delta\\thetaΔθ​是车辆航向角和rrr切线方向的夹角。为了简化复杂关系，做出了两点假设：\n\n车辆几乎平行于驱动引导线，即假定车辆的航向角与相应点处的引导线的方向相同，因此Δθ=0\\Delta\\theta=0Δθ=0。\n侧向加速度l′′l&#x27;&#x27;l′′​数值上很小（一般阶数在0.01）所以可以近似为0\n\n考虑右边：κr1−κrl&lt;κmaxκr&lt;κmax⋅(1−κrl)κr&lt;κmax−κmaxκrlκmaxκrl&lt;κmax−κr当κr&lt;0时，即右转：l&gt;κmax−κrκmaxκr当κr&gt;0时，即左转：l&lt;κmax−κrκmaxκr：\\begin{aligned}\n考虑右边：\n\\frac{\\kappa_r}{1-\\kappa_rl} &lt; \\kappa_{max} \\\\\n\\kappa_r &lt; \\kappa_{max}\\cdot (1-\\kappa_rl) \\\\\n\\kappa_r &lt; \\kappa_{max} - \\kappa_{max}\\kappa_rl \\\\\n\\kappa_{max}\\kappa_rl &lt; \\kappa_{max} - \\kappa_r \\\\\n当\\kappa_r&lt;0时，即右转：l &gt; \\frac{\\kappa_{max} - \\kappa_r}{\\kappa_{max}\\kappa_r} \\\\\n当\\kappa_r&gt;0时，即左转： l &lt; \\frac{\\kappa_{max} - \\kappa_r}{\\kappa_{max}\\kappa_r}：\n\\end{aligned}\n考虑右边：1−κr​lκr​​&lt;κmax​κr​&lt;κmax​⋅(1−κr​l)κr​&lt;κmax​−κmax​κr​lκmax​κr​l&lt;κmax​−κr​当κr​&lt;0时，即右转：l&gt;κmax​κr​κmax​−κr​​当κr​&gt;0时，即左转：l&lt;κmax​κr​κmax​−κr​​：​\n考虑左边：κr1−κrl&gt;−κmaxκr&gt;−κmax⋅(1−κrl)κr&gt;−κmax+κmaxκrlκmaxκrl&lt;κmax+κr当κr&lt;0时，即右转：l&gt;κmax+κrκmaxκr当κr&gt;0时，即左转：l&lt;κmax+κrκmaxκr：\\begin{aligned}\n考虑左边：\n\\frac{\\kappa_r}{1-\\kappa_rl} &gt; -\\kappa_{max} \\\\\n\\kappa_r &gt; -\\kappa_{max}\\cdot (1-\\kappa_rl) \\\\\n\\kappa_r &gt; -\\kappa_{max} + \\kappa_{max}\\kappa_rl \\\\\n\\kappa_{max}\\kappa_rl &lt; \\kappa_{max} + \\kappa_r \\\\\n当\\kappa_r&lt;0时，即右转：l &gt; \\frac{\\kappa_{max} + \\kappa_r}{\\kappa_{max}\\kappa_r} \\\\\n当\\kappa_r&gt;0时，即左转： l &lt; \\frac{\\kappa_{max} + \\kappa_r}{\\kappa_{max}\\kappa_r}：\n\\end{aligned}\n考虑左边：1−κr​lκr​​&gt;−κmax​κr​&gt;−κmax​⋅(1−κr​l)κr​&gt;−κmax​+κmax​κr​lκmax​κr​l&lt;κmax​+κr​当κr​&lt;0时，即右转：l&gt;κmax​κr​κmax​+κr​​当κr​&gt;0时，即左转：l&lt;κmax​κr​κmax​+κr​​：​\n综上所诉：当κr&lt;0时，即右转：l&gt;κmax+κrκmaxκr当κr&gt;0时，即左转：l&lt;κmax−κrκmaxκr：\\begin{aligned}\n综上所诉：\\\\\n当\\kappa_r&lt;0时，即右转：l &gt; \\frac{\\kappa_{max} + \\kappa_r}{\\kappa_{max}\\kappa_r} \\\\\n当\\kappa_r&gt;0时，即左转： l &lt; \\frac{\\kappa_{max} - \\kappa_r}{\\kappa_{max}\\kappa_r}：\n\\end{aligned}\n综上所诉：当κr​&lt;0时，即右转：l&gt;κmax​κr​κmax​+κr​​当κr​&gt;0时，即左转：l&lt;κmax​κr​κmax​−κr​​：​\n","categories":["算法"]},{"title":"（四）分段加加速度算法（PiecewiseJerk）之 速度规划代码实现","url":"/2023/01/31/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E9%80%9F%E5%BA%A6%E5%BE%84%E8%A7%84%E5%88%92%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"基于Apollo r5.5.0 版本代码，其实后续版本算法代码基本没有差变。\n\n 代码实现\n 速度规划代码实现\n Class PiecewiseJerkSpeedProblem\n// piecewise_jerk_speed_problem.h/* * @brief: * This class solve the path time optimization problem: * s * | * |                       P(t1, s1)  P(t2, s2) * |            P(t0, s0)                       ... P(t(k-1), s(k-1)) * |P(start) * | * |________________________________________________________ t * * we suppose t(k+1) - t(k) == t(k) - t(k-1) * * Given the s, s&#x27;, s&#x27;&#x27; at P(start),  The goal is to find t0, t1, ... t(k-1) * which makes the line P(start), P0, P(1) ... P(k-1) &quot;smooth&quot;. */class PiecewiseJerkSpeedProblem : public PiecewiseJerkProblem &#123;  ... protected:  // naming convention follows osqp solver.  // 速度规划重写了以下三个函数  void CalculateKernel(std::vector&lt;c_float&gt;* P_data,                       std::vector&lt;c_int&gt;* P_indices,                       std::vector&lt;c_int&gt;* P_indptr) override;  void CalculateOffset(std::vector&lt;c_float&gt;* q) override;  OSQPSettings* SolverDefaultSettings() override;  ...&#125;\n// piecewise_jerk_speed_problem.ccPiecewiseJerkSpeedProblem::PiecewiseJerkSpeedProblem(    const size_t num_of_knots, const double delta_s,    const std::array&lt;double, 3&gt;&amp; x_init)    : PiecewiseJerkProblem(num_of_knots, delta_s, x_init) &#123;  penalty_dx_.resize(num_of_knots_, 0.0);&#125;void PiecewiseJerkSpeedProblem::set_dx_ref(const double weight_dx_ref,                                           const double dx_ref) &#123;  weight_dx_ref_ = weight_dx_ref;  dx_ref_ = dx_ref;  has_dx_ref_ = true;&#125;void PiecewiseJerkSpeedProblem::set_penalty_dx(std::vector&lt;double&gt; penalty_dx) &#123;  CHECK_EQ(penalty_dx.size(), num_of_knots_);  penalty_dx_ = std::move(penalty_dx);&#125;\n速度规划比较特殊的地方，设定了x′x&#x27;x′的参考值xref′x&#x27;_{ref}xref′​，以及对速度的惩罚。\n PiecewiseJerkSpeedProblem::CalculateKernel()\nP=(P1P2P3)3n×3nP1=(wx_refIn−1×n−10n−1×101×n−1wx_ref+wx_end)n×nP2=((wx′_ref+Penaltyx′)In−1×n−10n−1×101×n−1wx′_ref+Penaltyx′+wx′_end)n×nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2+wx′′_end)n×n\\begin{aligned}\n\\textbf{P}=\\begin{pmatrix} \n\\textbf{P}_1 &amp; &amp; \\\\ \n&amp; \\textbf{P}_2 &amp;  \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n} \\\\\n\n\\textbf{P}_1 = \\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x\\_ref} + w_{x\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_2 = \\begin{pmatrix} \n(w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n-1 \\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\textbf{0}_{1 \\times n-1} &amp; w_{x&#x27;\\_ref}+Penalty_{x&#x27;} + w_{x&#x27;\\_end} \\\\ \n\\end{pmatrix}_{n \\times n} \\\\\n\n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}+ w_{x&#x27;&#x27;\\_end}\\\\\n\\end{pmatrix}_{n\\times n}\n\\end{aligned}\nP=⎝⎛​P1​​P2​​P3​​⎠⎞​3n×3n​P1​=(wx_ref​In−1×n−1​01×n−1​​0n−1×1​wx_ref​+wx_end​​)n×n​P2​=((wx′_ref​+Penaltyx′​)In−1×n−1​01×n−1​​0n−1×1​wx′_ref​+Penaltyx′​+wx′_end​​)n×n​P3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​+wx′′_end​​⎠⎞​n×n​​\nvoid PiecewiseJerkSpeedProblem::CalculateKernel(std::vector&lt;c_float&gt;* P_data,                                                std::vector&lt;c_int&gt;* P_indices,                                                std::vector&lt;c_int&gt;* P_indptr) &#123;  // 优化的点数  const int n = static_cast&lt;int&gt;(num_of_knots_);  // 优化的变量数目  const int kNumParam = 3 * n;  // 表示矩阵P内有效数据数量个数，即需要进行4n-1次数据赋值  // 3n + n-1  const int kNumValue = 4 * n - 1;  // 对应矩阵P  std::vector&lt;std::vector&lt;std::pair&lt;c_int, c_float&gt;&gt;&gt; columns;  columns.resize(kNumParam);  int value_index = 0;  // x(i)^2 * w_x_ref  // 对应矩阵P第一块矩阵  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[i].emplace_back(        i, weight_x_ref_ / (scale_factor_[0] * scale_factor_[0]));    ++value_index;  &#125;  // x(n-1)^2 * (w_x_ref + w_end_x)  // 终点有额外的比重  columns[n - 1].emplace_back(n - 1, (weight_x_ref_ + weight_end_state_[0]) /                                         (scale_factor_[0] * scale_factor_[0]));  ++value_index;  // x(i)&#x27;^2 * (w_dx_ref + penalty_dx)  // 对应矩阵P第二块矩阵  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[n + i].emplace_back(n + i,                                (weight_dx_ref_ + penalty_dx_[i]) /                                    (scale_factor_[1] * scale_factor_[1]));    ++value_index;  &#125;  // x(n-1)&#x27;^2 * (w_dx_ref + penalty_dx + w_end_dx)  // 终点有额外的比重  columns[2 * n - 1].emplace_back(      2 * n - 1, (weight_dx_ref_ + penalty_dx_[n - 1] + weight_end_state_[1]) /                     (scale_factor_[1] * scale_factor_[1]));  ++value_index;  auto delta_s_square = delta_s_ * delta_s_;  // x(i)&#x27;&#x27;^2 * (w_ddx + 2 * w_dddx / delta_s^2)  // 对应P3矩阵，右边项矩阵的左上角一块  columns[2 * n].emplace_back(2 * n,                              (weight_ddx_ + weight_dddx_ / delta_s_square) /                                  (scale_factor_[2] * scale_factor_[2]));  ++value_index;  // 对应P3矩阵，右边项矩阵的中间一块  for (int i = 1; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(        2 * n + i, (weight_ddx_ + 2.0 * weight_dddx_ / delta_s_square) /                       (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  // 对应P3矩阵，右边项矩阵的右下角一块，终点还有额外的比重累加  columns[3 * n - 1].emplace_back(      3 * n - 1,      (weight_ddx_ + weight_dddx_ / delta_s_square + weight_end_state_[2]) /          (scale_factor_[2] * scale_factor_[2]));  ++value_index;  // -2 * w_dddx / delta_s^2 * x(i)&#x27;&#x27; * x(i + 1)&#x27;&#x27;  // 对应P3矩阵，左边项矩阵的左下角一块  for (int i = 0; i &lt; n - 1; ++i) &#123;    columns[2 * n + i].emplace_back(2 * n + i + 1,                                    -2.0 * weight_dddx_ / delta_s_square /                                        (scale_factor_[2] * scale_factor_[2]));    ++value_index;  &#125;  CHECK_EQ(value_index, kNumValue);  // 抽取数据，同之前解读  int ind_p = 0;  for (int i = 0; i &lt; kNumParam; ++i) &#123;    P_indptr-&gt;push_back(ind_p);    for (const auto&amp; row_data_pair : columns[i]) &#123;      // 注意，数据这里会乘两倍      P_data-&gt;push_back(row_data_pair.second * 2.0);      P_indices-&gt;push_back(row_data_pair.first);      ++ind_p;    &#125;  &#125;  P_indptr-&gt;push_back(ind_p);&#125;\n PiecewiseJerkSpeedProblem::CalculateOffset()\nq=(q1q2q3)3n×1q1=(−2wx_refxref⋮−2wx_refxref−2wx_endxend−2wx_refxref)n×1，q2=(−2wx′_refxref′⋮−2wx′_refxref′−2wx′_endxend′−2wx′_refxref′)n×1，q3=(0⋮0−2wx′′_endxend′′)n×1\\begin{aligned}\n\\textbf{q} = \\begin{pmatrix} \n\\textbf{q}_1 \\\\ \n\\textbf{q}_2 \\\\ \n\\textbf{q}_3 \\\\ \n\\end{pmatrix}_{3n \\times 1} \\\\\n\n\\textbf{q}_1 = \\begin{pmatrix}\n-2w_{x\\_ref}x_{ref} \\\\\n\\vdots \\\\\n-2w_{x\\_ref}x_{ref} \\\\\n-2w_{x\\_end}x_{end} - 2w_{x\\_ref}x_{ref}\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_2 = \\begin{pmatrix}\n-2w_{x&#x27;\\_ref}x&#x27;_{ref} \\\\\n\\vdots \\\\\n-2w_{x&#x27;\\_ref}x&#x27;_{ref} \\\\\n-2w_{x&#x27;\\_end}x&#x27;_{end} - 2w_{x&#x27;\\_ref}x&#x27;_{ref}\n\\end{pmatrix}_{n \\times 1}，\n\n\\textbf{q}_3 = \\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;\\_end}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{aligned}\nq=⎝⎛​q1​q2​q3​​⎠⎞​3n×1​q1​=⎝⎜⎜⎜⎜⎛​−2wx_ref​xref​⋮−2wx_ref​xref​−2wx_end​xend​−2wx_ref​xref​​⎠⎟⎟⎟⎟⎞​n×1​，q2​=⎝⎜⎜⎜⎜⎛​−2wx′_ref​xref′​⋮−2wx′_ref​xref′​−2wx′_end​xend′​−2wx′_ref​xref′​​⎠⎟⎟⎟⎟⎞​n×1​，q3​=⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′_end​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​\nvoid PiecewiseJerkSpeedProblem::CalculateOffset(std::vector&lt;c_float&gt;* q) &#123;  CHECK_NOTNULL(q);  // 优化点的数量  const int n = static_cast&lt;int&gt;(num_of_knots_);  // 优化变量的数量，也就是矩阵q的行数  const int kNumParam = 3 * n;  q-&gt;resize(kNumParam);  for (int i = 0; i &lt; n; ++i) &#123;    if (has_x_ref_) &#123;      // 有x参考值情况下      q-&gt;at(i) += -2.0 * weight_x_ref_ * x_ref_[i] / scale_factor_[0];    &#125;    if (has_dx_ref_) &#123;      // 有x&#x27;参考值情况下      q-&gt;at(n + i) += -2.0 * weight_dx_ref_ * dx_ref_ / scale_factor_[1];    &#125;  &#125;  if (has_end_state_ref_) &#123;    // 有终点状态情况下    q-&gt;at(n - 1) +=        -2.0 * weight_end_state_[0] * end_state_ref_[0] / scale_factor_[0];    q-&gt;at(2 * n - 1) +=        -2.0 * weight_end_state_[1] * end_state_ref_[1] / scale_factor_[1];    q-&gt;at(3 * n - 1) +=        -2.0 * weight_end_state_[2] * end_state_ref_[2] / scale_factor_[2];  &#125;&#125;\n CalculateAffineConstraint()\n在父类PiecewiseJerkProblem以及定义好函数。\n PiecewiseJerkSpeedProblem::SolverDefaultSettings()\n// r5.0.0OSQPSettings* PiecewiseJerkSpeedProblem::SolverDefaultSettings() &#123;  // Define Solver default settings  OSQPSettings* settings =      reinterpret_cast&lt;OSQPSettings*&gt;(c_malloc(sizeof(OSQPSettings)));  osqp_set_default_settings(settings);  settings-&gt;alpha = 1.6;  // settings-&gt;sigma = 1e-2;  settings-&gt;rho = 0.1;  settings-&gt;eps_abs = 1e-3;  settings-&gt;eps_rel = 1e-3;  settings-&gt;eps_prim_inf = 1e-4;  settings-&gt;eps_dual_inf = 1e-4;  settings-&gt;polish = true;  settings-&gt;verbose = FLAGS_enable_osqp_debug;  settings-&gt;scaled_termination = true;  return settings;&#125;\n// v8.0.0OSQPSettings* PiecewiseJerkSpeedProblem::SolverDefaultSettings() &#123;  // Define Solver default settings  OSQPSettings* settings =      reinterpret_cast&lt;OSQPSettings*&gt;(c_malloc(sizeof(OSQPSettings)));  osqp_set_default_settings(settings);  settings-&gt;eps_abs = 1e-4;  settings-&gt;eps_rel = 1e-4;  settings-&gt;eps_prim_inf = 1e-5;  settings-&gt;eps_dual_inf = 1e-5;  settings-&gt;polish = true;  settings-&gt;verbose = FLAGS_enable_osqp_debug;  settings-&gt;scaled_termination = true;  return settings;&#125;\n 工程使用\n 速度规划Task–PiecewiseJerkSpeedOptimizer\n PiecewiseJerkSpeedOptimizer::Process()\nv5.5.0版本\nStatus PiecewiseJerkSpeedOptimizer::Process(const PathData&amp; path_data,                                            const TrajectoryPoint&amp; init_point,                                            SpeedData* const speed_data) &#123;  // path_data主要用于获取曲率  // init_point初始位置  if (reference_line_info_-&gt;ReachedDestination()) &#123;    // 如果到达终点就无需进一步计算    return Status::OK();  &#125;  CHECK(speed_data != nullptr);  SpeedData reference_speed_data = *speed_data;  if (path_data.discretized_path().empty()) &#123;    // 没有规划路径就直接退出    std::string msg(&quot;Empty path data&quot;);    AERROR &lt;&lt; msg;    return Status(ErrorCode::PLANNING_ERROR, msg);  &#125;  // 获取前面Task计算得到在ST图下的曲线,初始解  StGraphData&amp; st_graph_data = *reference_line_info_-&gt;mutable_st_graph_data();  const auto&amp; veh_param =      common::VehicleConfigHelper::GetConfig().vehicle_param();  // 设定初始边界条件  std::array&lt;double, 3&gt; init_s = &#123;0.0, st_graph_data.init_point().v(),                                  st_graph_data.init_point().a()&#125;;  double delta_t = 0.1;  double total_length = st_graph_data.path_length();  double total_time = st_graph_data.total_time_by_conf();  int num_of_knots = static_cast&lt;int&gt;(total_time / delta_t) + 1;  // 构造用于OSQP解决器的问题  PiecewiseJerkSpeedProblem piecewise_jerk_problem(num_of_knots, delta_t,                                                   init_s);  // 设定s&#x27;&#x27;, s&#x27;&#x27;&#x27;比重  const auto&amp; piecewise_jerk_speed_config =      config_.piecewise_jerk_speed_config();  piecewise_jerk_problem.set_weight_ddx(      piecewise_jerk_speed_config.acc_weight());  piecewise_jerk_problem.set_weight_dddx(      piecewise_jerk_speed_config.jerk_weight());  // 设定s, s&#x27;, s&#x27;&#x27;, s&#x27;&#x27;&#x27;边界  piecewise_jerk_problem.set_x_bounds(0.0, total_length);  piecewise_jerk_problem.set_dx_bounds(      0.0, std::fmax(FLAGS_planning_upper_speed_limit,                     st_graph_data.init_point().v()));  piecewise_jerk_problem.set_ddx_bounds(veh_param.max_deceleration(),                                        veh_param.max_acceleration());  piecewise_jerk_problem.set_dddx_bound(FLAGS_longitudinal_jerk_lower_bound,                                        FLAGS_longitudinal_jerk_upper_bound);  // 设定s&#x27;，即速度的参考值以及对应的比重  piecewise_jerk_problem.set_dx_ref(piecewise_jerk_speed_config.ref_v_weight(),                                    reference_line_info_-&gt;GetCruiseSpeed());  // Update STBoundary  std::vector&lt;std::pair&lt;double, double&gt;&gt; s_bounds;  for (int i = 0; i &lt; num_of_knots; ++i) &#123;    double curr_t = i * delta_t;    double s_lower_bound = 0.0;    double s_upper_bound = total_length;    for (const STBoundary* boundary : st_graph_data.st_boundaries()) &#123;      double s_lower = 0.0;      double s_upper = 0.0;      if (!boundary-&gt;GetUnblockSRange(curr_t, &amp;s_upper, &amp;s_lower)) &#123;        continue;      &#125;      switch (boundary-&gt;boundary_type()) &#123;        case STBoundary::BoundaryType::STOP:        case STBoundary::BoundaryType::YIELD:          s_upper_bound = std::fmin(s_upper_bound, s_upper);          break;        case STBoundary::BoundaryType::FOLLOW:          // TODO(Hongyi): unify follow buffer on decision side          s_upper_bound = std::fmin(s_upper_bound, s_upper - 8.0);          break;        case STBoundary::BoundaryType::OVERTAKE:          s_lower_bound = std::fmax(s_lower_bound, s_lower);          break;        default:          break;      &#125;    &#125;    if (s_lower_bound &gt; s_upper_bound) &#123;      std::string msg(&quot;s_lower_bound larger than s_upper_bound on STGraph!&quot;);      AERROR &lt;&lt; msg;      speed_data-&gt;clear();      return Status(ErrorCode::PLANNING_ERROR, msg);    &#125;    // 根据边界类型，重新设定s的边界条件    s_bounds.emplace_back(s_lower_bound, s_upper_bound);  &#125;  // 更新s边界  piecewise_jerk_problem.set_x_bounds(std::move(s_bounds));  // Update SpeedBoundary and ref_s  std::vector&lt;double&gt; x_ref;  std::vector&lt;double&gt; penalty_dx;  std::vector&lt;std::pair&lt;double, double&gt;&gt; s_dot_bounds;  const SpeedLimit&amp; speed_limit = st_graph_data.speed_limit();  for (int i = 0; i &lt; num_of_knots; ++i) &#123;    double curr_t = i * delta_t;    // get path_s    SpeedPoint sp;    reference_speed_data.EvaluateByTime(curr_t, &amp;sp);    const double path_s = sp.s();    x_ref.emplace_back(path_s);    // get curvature    PathPoint path_point = path_data.GetPathPointWithPathS(path_s);    // 设定与曲率相关的s&#x27;即速度惩罚系数    penalty_dx.push_back(std::fabs(path_point.kappa()) *                         piecewise_jerk_speed_config.kappa_penalty_weight());    // get v_upper_bound    const double v_lower_bound = 0.0;    double v_upper_bound = FLAGS_planning_upper_speed_limit;    v_upper_bound = speed_limit.GetSpeedLimitByS(path_s);    s_dot_bounds.emplace_back(v_lower_bound, std::fmax(v_upper_bound, 0.0));  &#125;  // 设定s的参考值，以及对应的比重  piecewise_jerk_problem.set_x_ref(piecewise_jerk_speed_config.ref_s_weight(),                                   x_ref);  // 设定惩罚比重  piecewise_jerk_problem.set_penalty_dx(penalty_dx);  // 设定s&#x27;，即速度的边界条件  piecewise_jerk_problem.set_dx_bounds(std::move(s_dot_bounds));  // Solve the problem  // 关键步骤，求解问题  if (!piecewise_jerk_problem.Optimize()) &#123;    std::string msg(&quot;Piecewise jerk speed optimizer failed!&quot;);    AERROR &lt;&lt; msg;    speed_data-&gt;clear();    return Status(ErrorCode::PLANNING_ERROR, msg);  &#125;  // Extract output  const std::vector&lt;double&gt;&amp; s = piecewise_jerk_problem.opt_x();  const std::vector&lt;double&gt;&amp; ds = piecewise_jerk_problem.opt_dx();  const std::vector&lt;double&gt;&amp; dds = piecewise_jerk_problem.opt_ddx();  for (int i = 0; i &lt; num_of_knots; ++i) &#123;    // 输出数据用于诊断分析    ADEBUG &lt;&lt; &quot;For t[&quot; &lt;&lt; i * delta_t &lt;&lt; &quot;], s = &quot; &lt;&lt; s[i] &lt;&lt; &quot;, v = &quot; &lt;&lt; ds[i]           &lt;&lt; &quot;, a = &quot; &lt;&lt; dds[i];  &#125;  speed_data-&gt;clear();  // 速度规划结果第一个点  speed_data-&gt;AppendSpeedPoint(s[0], 0.0, ds[0], dds[0], 0.0);  for (int i = 1; i &lt; num_of_knots; ++i) &#123;    // Avoid the very last points when already stopped    if (ds[i] &lt;= 0.0) &#123;      break;    &#125;    speed_data-&gt;AppendSpeedPoint(s[i], delta_t * i, ds[i], dds[i],                                 (dds[i] - dds[i - 1]) / delta_t);  &#125;  // 如果时间不够长，则补充后面的速度点(速度、加速度以及加加速度为0)直到时间够长  SpeedProfileGenerator::FillEnoughSpeedPoints(speed_data);  RecordDebugInfo(*speed_data, st_graph_data.mutable_st_graph_debug());  return Status::OK();&#125;\n SpeedProfileGenerator::FillEnoughSpeedPoints(）\nvoid SpeedProfileGenerator::FillEnoughSpeedPoints(SpeedData* const speed_data) &#123;  const SpeedPoint&amp; last_point = speed_data-&gt;back();  if (last_point.t() &gt;= FLAGS_fallback_total_time) &#123;    return;  &#125;  for (double t = last_point.t() + FLAGS_fallback_time_unit;       t &lt; FLAGS_fallback_total_time; t += FLAGS_fallback_time_unit) &#123;    speed_data-&gt;AppendSpeedPoint(last_point.s(), t, 0.0, 0.0, 0.0);  &#125;&#125;\n","categories":["算法","Apollo源码解读"]},{"title":"（三）分段加加速度算法（PiecewiseJerk）之 速度规划理论推演","url":"/2023/01/31/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88PiecewiseJerk%EF%BC%89%E4%B9%8B%20%E9%80%9F%E5%BA%A6%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E6%8E%A8%E6%BC%94/","content":"这篇文章系统推导了分段加加速度（Piecewise Jerk）算法在速度规划中的数学模型，通过构建包含横向位置、一阶导、二阶导与三阶导的优化目标函数及约束条件，将其转化为标准的二次规划问题（QP），便于使用 OSQP 求解器实现速度优化。\n\n 理论推演\n速度规划（基于ST图）代价函数：\nf=ws_ref∑i=0n−1(si−sref_i)2+(ws′_ref+Penalitys′)∑i=0n−1(si′−sref_i′)2+ws′′∑i=0n−1si′′2+ws′′′∑i=0n−2si→i+1′′′2f = w_{s\\_ref} \\sum_{i=0}^{n-1}(s_i-s_{ref\\_i})^2 + \n   (w_{s&#x27;\\_ref}+Penality_{s&#x27;})\\sum_{i=0}^{n-1}(s&#x27;_i-s&#x27;_{ref\\_i})^2 +\n   w_{s&#x27;&#x27;} \\sum_{i=0}^{n-1}s_i&#x27;&#x27;^{2} + \n   w_{s&#x27;&#x27;&#x27;} \\sum_{i=0}^{n-2}s_{i \\rightarrow i+1}&#x27;&#x27;&#x27;^{2}\nf=ws_ref​i=0∑n−1​(si​−sref_i​)2+(ws′_ref​+Penalitys′​)i=0∑n−1​(si′​−sref_i′​)2+ws′′​i=0∑n−1​si′′2​+ws′′′​i=0∑n−2​si→i+1′′′2​\nsubjectto:(s0s0′s0′′)=(sinitsinit′sinit′′)s(k)′′′=s′′(k+1)−s′′(k)dts′(k+1)−s′(k)=s′′(k+1)+s′′(k)2dts(k+1)=s(k)+s′(k)dt+s′′(k)2dt2+s′′′(k)6dt3s_bounds_.first≤s≤s_bounds_.secondds_bounds_.first≤s′≤ds_bounds_.seconddds_bounds_.first≤s′′≤dds_bounds_.second−max_s_third_order_derivative≤s′′′≤max_s_third_order_derivative\\begin{aligned}\nsubject \\quad to:\\quad \n\\begin{pmatrix} s_0 \\\\ s&#x27;_0 \\\\ s&#x27;&#x27;_0\\end{pmatrix} = \\begin{pmatrix} s_{init} \\\\ s&#x27;_{init} \\\\ s&#x27;&#x27;_ {init} \\end{pmatrix} \\\\\ns(k)&#x27;&#x27;&#x27;=\\frac{s&#x27;&#x27;(k+1)-s&#x27;&#x27;(k)}{dt} \\\\\ns&#x27;(k+1)-s&#x27;(k)=\\frac{s&#x27;&#x27;(k+1)+s&#x27;&#x27;(k)}{2}dt \\\\\ns(k+1)=s(k)+s&#x27;(k)dt+\\frac{s&#x27;&#x27;(k)}{2}dt^2+\\frac{s&#x27;&#x27;&#x27;(k)}{6}dt^3 \\\\\ns\\_bounds\\_.first\\leq s \\leq s\\_bounds\\_.second \\\\\nds\\_bounds\\_.first\\leq s&#x27; \\leq ds\\_bounds\\_.second \\\\\ndds\\_bounds\\_.first\\leq s&#x27;&#x27; \\leq dds\\_bounds\\_.second \\\\\n-max\\_s\\_third\\_order\\_derivative \\leq s&#x27;&#x27;&#x27; \\leq max\\_s\\_third\\_order\\_derivative\n\\end{aligned}\nsubjectto:⎝⎛​s0​s0′​s0′′​​⎠⎞​=⎝⎛​sinit​sinit′​sinit′′​​⎠⎞​s(k)′′′=dts′′(k+1)−s′′(k)​s′(k+1)−s′(k)=2s′′(k+1)+s′′(k)​dts(k+1)=s(k)+s′(k)dt+2s′′(k)​dt2+6s′′′(k)​dt3s_bounds_.first≤s≤s_bounds_.secondds_bounds_.first≤s′≤ds_bounds_.seconddds_bounds_.first≤s′′≤dds_bounds_.second−max_s_third_order_derivative≤s′′′≤max_s_third_order_derivative​\n\n\n位置变量sis_isi​贴近对应的启发式规划位置sref_is_{ref\\_i}sref_i​\n\n\n惩罚加速度si′′s&#x27;&#x27;_isi′′​与加加速度si→i+1′′′s&#x27;&#x27;&#x27;_{i \\rightarrow i+1}si→i+1′′′​\n\n\n 速度规划目标函数转化QP形式\n优化变量\nx=((x)n×1(x′)n×1(x′′)n×1)3n×1\\textbf{x}=\\begin{pmatrix} (x)_{n\\times1} \\\\ (x&#x27;)_{n\\times1} \\\\(x&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\nx=⎝⎛​(x)n×1​(x′)n×1​(x′′)n×1​​⎠⎞​3n×1​\n分别表示距离、速度和加速度。在ST图上对应s\ns=((s)n×1(s′)n×1(s′′)n×1)3n×1\\textbf{s}=\\begin{pmatrix} (s)_{n\\times1} \\\\ (s&#x27;)_{n\\times1} \\\\(s&#x27;&#x27;)_{n\\times1} \\end{pmatrix}_{3n\\times1}\ns=⎝⎛​(s)n×1​(s′)n×1​(s′′)n×1​​⎠⎞​3n×1​\n有3n3n3n个优化变量。\n 优化变量-距离\n(x)n×1\\begin{pmatrix} x \\end{pmatrix}_{n\\times1}\n(x​)n×1​\n\n平滑sss距离建议的srefs_{ref}sref​值近越好，目标函数：\nminimizewx_ref(x−xref)2=wx_ref(x2−2xxref+xref2)minimize \\quad w_{x\\_ref}(x-x_{ref})^2 = w_{x\\_ref}(x^2-2xx_{ref}+x_{ref}^2)\nminimizewx_ref​(x−xref​)2=wx_ref​(x2−2xxref​+xref2​)\nxref2x_{ref}^2xref2​为常量，可以省去，因此化简得：\nminimizewx_ref(x2−2xxref)minimize \\quad w_{x\\_ref}(x^2-2xx_{ref})\nminimizewx_ref​(x2−2xxref​)\n前一项wx_refx2w_{x\\_ref}x^2wx_ref​x2中的系数wx_refw_{x\\_ref}wx_ref​放入矩阵P\\textbf{P}P的第一块\nP=(wx_refIn×n)3n×3n\\textbf{P}=\\begin{pmatrix} w_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\  \\\\ \\end{pmatrix}_{3n \\times 3n}\nP=(wx_ref​In×n​​)3n×3n​\n后一项−2wxrefxrefx-2w_{x_ref}x_{ref}x−2wxr​ef​xref​x中的系数−2wx_refxref-2w_{x\\_ref}x_{ref}−2wx_ref​xref​放入矩阵q\\textbf{q}q的第一块\nq=((−2wx_refxref)n×1)3n×1\\textbf{q} = \\begin{pmatrix} (-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\  \\\\ \\end{pmatrix}_{3n \\times 1}\nq=((−2wx_ref​xref​)n×1​​)3n×1​\n其中xref=(x_bounds_.first+x_bounds_second)/2x_{ref}=(x\\_bounds\\_.first+x\\_bounds\\_second)/2xref​=(x_bounds_.first+x_bounds_second)/2，由边界决定。\n 不等约束\nx_bounds_.first≤x≤x_bounds_.secondx\\_bounds\\_.first\\leq x\\leq x\\_bounds\\_.secondx_bounds_.first≤x≤x_bounds_.second得到\nA=(In×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\  \n\\quad\n\\end{pmatrix}\nA=(In×n​​)\nl=((x_bounds_.first)n×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=((x_bounds_.first)n×1​​)\nu=((x_bounds_.second)n×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=((x_bounds_.second)n×1​​)\n 优化变量-速度\n(x′)n×1(x&#x27;)_{n\\times1}\n(x′)n×1​\n速度x′x&#x27;x′建议的xref′x&#x27;_{ref}xref′​值近越好，目标函数：\nminimizewx′_ref(x′−xref′)2=wx′_ref(x′2−2x′xref′+xref′2)minimize \\quad w_{x&#x27;\\_ref}(x&#x27;-x&#x27;_{ref})^2 = w_{x&#x27;\\_ref}(x&#x27;^2-2x&#x27;x&#x27;_{ref}+x_{ref}&#x27;^2)\nminimizewx′_ref​(x′−xref′​)2=wx′_ref​(x′2−2x′xref′​+xref′2​)\nxref′2x_{ref}&#x27;^2xref′2​为常量，可以省去，因此化简得：\nminimizewx′_ref(x′2−2x′xref′)minimize \\quad w_{x&#x27;\\_ref}(x&#x27;^2-2x&#x27;x&#x27;_{ref})\nminimizewx′_ref​(x′2−2x′xref′​)\nApollo在速度x′2x&#x27;^2x′2前面加了一个惩罚系数Penaltyx′Penalty_{x&#x27;}Penaltyx′​，这个系数取值为曲率κ\\kappaκ和曲率惩罚系数的乘积，即\nPenaltyx′=κ⋅wκ_penaltyPenalty_{x&#x27;}=\\kappa \\cdot w_{\\kappa\\_penalty}\nPenaltyx′​=κ⋅wκ_penalty​\n当车辆沿直线行驶时，曲率为0，因此这是一个针对弯道限速的惩罚系数，添加惩罚系数后目标函数：\nminimize(wx′_ref+Penaltyx′)x′2−2wx′_refxref′x′minimize \\quad(w_{x&#x27;\\_ref}+Penalty_{x&#x27;})x&#x27;^2-2w_{x&#x27;\\_ref}x&#x27;_{ref}x&#x27;\nminimize(wx′_ref​+Penaltyx′​)x′2−2wx′_ref​xref′​x′\n前一项(wx′_ref+Penaltyx′)x′2(w_{x&#x27;\\_ref}+Penalty_{x&#x27;})x&#x27;^2(wx′_ref​+Penaltyx′​)x′2中的系数wx′_ref+Penaltyx′w_{x&#x27;\\_ref}+Penalty_{x&#x27;}wx′_ref​+Penaltyx′​放入矩阵P\\textbf{P}P的第二块\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×n)3n×3n\\textbf{P}=\\begin{pmatrix} w_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ &amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \\end{pmatrix}_{3n \\times 3n}\nP=(wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​​)3n×3n​\n后一项−2wx′_refxref′x′-2w_{x&#x27;\\_ref}x&#x27;_{ref}x&#x27;−2wx′_ref​xref′​x′中的系数−2wx′_refxref′-2w_{x&#x27;\\_ref}x&#x27;_{ref}−2wx′_ref​xref′​放入矩阵q\\textbf{q}q的第二块\nq=((−2wx_refxref)n×1(−2wx′_refxref′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\ \n(-2w_{x&#x27;\\_ref}x&#x27;_{ref})_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎛​(−2wx_ref​xref​)n×1​(−2wx′_ref​xref′​)n×1​​⎠⎞​3n×1​\n其中xref′=(dx_bounds_.first+dx_bounds_second)/2x&#x27;_{ref}=(dx\\_bounds\\_.first + dx\\_bounds\\_second)/2xref′​=(dx_bounds_.first+dx_bounds_second)/2，由边界决定。\n 不等约束\ndx_bounds_.first≤x′≤dx_bounds_.seconddx\\_bounds\\_.first\\leq x&#x27; \\leq dx\\_bounds\\_.seconddx_bounds_.first≤x′≤dx_bounds_.second得到\nA=(In×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n\\quad\n\\end{pmatrix}\nA=⎝⎛​In×n​​In×n​​​⎠⎞​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​​⎠⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​​⎠⎞​\n 优化变量-加速度\n(x′′)n×1(x&#x27;&#x27;)_{n\\times 1}\n(x′′)n×1​\n加速度越小越好，目标函数：\nminimizewx′′x′′2minimize \\quad w_{x&#x27;&#x27;}x&#x27;&#x27;^2\nminimizewx′′​x′′2\n前一项wx′′x′′2w{x&#x27;&#x27;}x&#x27;&#x27;^2wx′′x′′2中的系数wx′′w{x&#x27;&#x27;}wx′′放入矩阵P\\textbf{P}P的第三块\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×nwx′′In×n)3n×3n\\textbf{P}=\\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \n&amp; &amp; w_{x&#x27;&#x27;}\\textbf{I}_{n\\times n}\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​wx′′​In×n​​⎠⎞​3n×3n​\n这里矩阵q\\textbf{q}q的第三块只在最后一行，即，终点加速度有一个约束−2wx′′xend′′-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}−2wx′′​xend′′​，因此有：\nq=((−2wx_refxref)n×1(−2wx′_refxref′)n×1(0⋮0−2wx′′xend′′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\ \n(-2w_{x&#x27;\\_ref}x&#x27;_{ref})_{n\\times 1} \\\\ \n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​(−2wx_ref​xref​)n×1​(−2wx′_ref​xref′​)n×1​⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​3n×1​\n由此得到Offset matrix。\n 不等约束\nddx_bounds_.first≤x′′≤ddx_bounds_.secondddx\\_bounds\\_.first\\leq x&#x27;&#x27; \\leq ddx\\_bounds\\_.secondddx_bounds_.first≤x′′≤ddx_bounds_.second得到\nA=(In×nIn×nIn×n)\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n\\quad\n\\end{pmatrix}\nA=⎝⎜⎜⎜⎛​In×n​​In×n​​In×n​​⎠⎟⎟⎟⎞​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​​⎠⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​​⎠⎟⎟⎟⎞​\n 优化变量-加加速度\n(x′′′)n×1(x&#x27;&#x27;&#x27;)_{n \\times 1}\n(x′′′)n×1​\n加加速度越小越好，目标函数：\nminimizewx′′′x′′′2=wx′′′(x′′(k+1)−x′′(k)ds)2=wx′′′ds2(x′′(k+1)2−2x′′(k+1)x′′(k)+x′′(k)2)\\begin{aligned}\nminimize \\quad w_{x&#x27;&#x27;&#x27;}x&#x27;&#x27;&#x27;^2 &amp; = w_{x&#x27;&#x27;&#x27;}(\\frac{x&#x27;&#x27;(k+1)-x&#x27;&#x27;(k)}{ds})^2\\\\\n&amp; = \\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(k+1)^2 - 2x&#x27;&#x27;(k+1)x&#x27;&#x27;(k) + x&#x27;&#x27;(k)^2)\n\\end{aligned}\nminimizewx′′′​x′′′2​=wx′′′​(dsx′′(k+1)−x′′(k)​)2=ds2wx′′′​​(x′′(k+1)2−2x′′(k+1)x′′(k)+x′′(k)2)​\n这样变换以后相当于目标函数降低了一阶，记矩阵P\\textbf{P}P的第三块子矩阵为P3\\textbf{P}_3P3​，则目前\nP3=wx′′In×n\\textbf{P}_3=w_{x&#x27;&#x27;}\\textbf{I}_{n\\times n}\nP3​=wx′′​In×n​\n要将上述的目标函数转换成矩阵形式并添加到矩阵P3\\textbf{P}_3P3​中去，以n=5为例进行推演。\nwx′′′ds2(x′′(2)2−2x′′(2)x′′(1)+x′′(1)2)+wx′′′ds2(x′′(3)2−2x′′(3)x′′(2)+x′′(2)2)+wx′′′ds2(x′′(4)2−2x′′(4)x′′(3)+x′′(3)2)+wx′′′ds2(x′′(5)2−2x′′(5)x′′(4)+x′′(4)2)=x′′(1)(wx′′′ds2x′′(1)−2wx′′′ds2x′′(2))+x′′(2)(2wx′′′ds2x′′(2)−2wx′′′ds2x′′(3))+x′′(3)(2wx′′′ds2x′′(3)−2wx′′′ds2x′′(4))+x′′(4)(2wx′′′ds2x′′(4)−2wx′′′ds2x′′(5))+x′′(5)wx′′′ds2x′′(5)=(wx′′′ds2x′′(1)−2wx′′′ds2x′′(2)2wx′′′ds2x′′(2)−2wx′′′ds2x′′(3)2wx′′′ds2x′′(3)−2wx′′′ds2x′′(4)2wx′′′ds2x′′(4)−2wx′′′ds2x′′(5)wx′′′ds2x′′(5))T(x′′(1)x′′(2)x′′(3)x′′(4)x′′(5))=(x′′(1)x′′(2)x′′(3)x′′(4)x′′(5))T(wx′′′ds20000−2wx′′′ds22wx′′′ds20000−2wx′′′ds22wx′′′ds20000−2wx′′′ds22wx′′′ds20000−2wx′′′ds2wx′′′ds2)(x′′(1)x′′(2)x′′(3)x′′(4)x′′(5))\\begin{aligned}\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(2)^2-2x&#x27;&#x27;(2)x&#x27;&#x27;(1)+x&#x27;&#x27;(1)^2) + \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(3)^2-2x&#x27;&#x27;(3)x&#x27;&#x27;(2)+x&#x27;&#x27;(2)^2) \\\\ +\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(4)^2-2x&#x27;&#x27;(4)x&#x27;&#x27;(3)+x&#x27;&#x27;(3)^2) +\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}(x&#x27;&#x27;(5)^2-2x&#x27;&#x27;(5)x&#x27;&#x27;(4)+x&#x27;&#x27;(4)^2) \\\\\n= x&#x27;&#x27;(1)(\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(1)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2)) + \nx&#x27;&#x27;(2)(2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3)) \\\\ +\nx&#x27;&#x27;(3)(2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4)) + \nx&#x27;&#x27;(4)(2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5)) + x&#x27;&#x27;(5)\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5) \\\\ \n= \\begin{pmatrix} \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(1)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2) \\\\ \n2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(2)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3) \\\\ \n2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(3)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4) \\\\\n2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(4)-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5) \\\\\n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2}x&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \nx&#x27;&#x27;(1) \\\\ \nx&#x27;&#x27;(2) \\\\ \nx&#x27;&#x27;(3) \\\\\nx&#x27;&#x27;(4) \\\\\nx&#x27;&#x27;(5) \\\\\n\\end{pmatrix} \\\\\n= \\begin{pmatrix} \nx&#x27;&#x27;(1) \\\\ \nx&#x27;&#x27;(2) \\\\ \nx&#x27;&#x27;(3) \\\\\nx&#x27;&#x27;(4) \\\\\nx&#x27;&#x27;(5) \\\\\n\\end{pmatrix} ^T\n\\begin{pmatrix} \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \n-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 &amp; 0 \\\\ \n0 &amp; -2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; -2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; -2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}\n\\begin{pmatrix} \nx&#x27;&#x27;(1) \\\\ \nx&#x27;&#x27;(2) \\\\ \nx&#x27;&#x27;(3) \\\\\nx&#x27;&#x27;(4) \\\\\nx&#x27;&#x27;(5) \\\\\n\\end{pmatrix}\n\\end{aligned}\nds2wx′′′​​(x′′(2)2−2x′′(2)x′′(1)+x′′(1)2)+ds2wx′′′​​(x′′(3)2−2x′′(3)x′′(2)+x′′(2)2)+ds2wx′′′​​(x′′(4)2−2x′′(4)x′′(3)+x′′(3)2)+ds2wx′′′​​(x′′(5)2−2x′′(5)x′′(4)+x′′(4)2)=x′′(1)(ds2wx′′′​​x′′(1)−2ds2wx′′′​​x′′(2))+x′′(2)(2ds2wx′′′​​x′′(2)−2ds2wx′′′​​x′′(3))+x′′(3)(2ds2wx′′′​​x′′(3)−2ds2wx′′′​​x′′(4))+x′′(4)(2ds2wx′′′​​x′′(4)−2ds2wx′′′​​x′′(5))+x′′(5)ds2wx′′′​​x′′(5)=⎝⎜⎜⎜⎜⎜⎛​ds2wx′′′​​x′′(1)−2ds2wx′′′​​x′′(2)2ds2wx′′′​​x′′(2)−2ds2wx′′′​​x′′(3)2ds2wx′′′​​x′′(3)−2ds2wx′′′​​x′′(4)2ds2wx′′′​​x′′(4)−2ds2wx′′′​​x′′(5)ds2wx′′′​​x′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​x′′(1)x′′(2)x′′(3)x′′(4)x′′(5)​⎠⎟⎟⎟⎟⎟⎞​=⎝⎜⎜⎜⎜⎜⎛​x′′(1)x′′(2)x′′(3)x′′(4)x′′(5)​⎠⎟⎟⎟⎟⎟⎞​T⎝⎜⎜⎜⎜⎜⎛​ds2wx′′′​​−2ds2wx′′′​​000​02ds2wx′′′​​−2ds2wx′′′​​00​002ds2wx′′′​​−2ds2wx′′′​​0​0002ds2wx′′′​​−2ds2wx′′′​​​0000ds2wx′′′​​​⎠⎟⎟⎟⎟⎟⎞​⎝⎜⎜⎜⎜⎜⎛​x′′(1)x′′(2)x′′(3)x′′(4)x′′(5)​⎠⎟⎟⎟⎟⎟⎞​​\n因此，P3\\textbf{P}_3P3​中需要附加上以下矩阵\n(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′′ds201×n−200n−2×1(2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′′ds2)n×n\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \n\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; \\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\n(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​ds2wx′′′​​0n−2×1​0​01×n−2​(2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​ds2wx′′′​​​⎠⎞​n×n​\n加上该矩阵后，矩阵P3\\textbf{P}_3P3​变换为\nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2)n×n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\nP3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​​⎠⎞​n×n​\n由此得到Kernel matrix\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×nP3)3n×3n\\textbf{P}=\\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​P3​​⎠⎞​3n×3n​\n 不等约束\n−max_x_third_order_derivative≤x′′′≤max_x_third_order_derivative-max\\_x\\_third\\_order\\_derivative \\leq x&#x27;&#x27;&#x27; \\leq max\\_x\\_third\\_order\\_derivative−max_x_third_order_derivative≤x′′′≤max_x_third_order_derivative\n因为\nx′′′=x′′(k+1)−x′′(k)dsx&#x27;&#x27;&#x27;=\\frac{x&#x27;&#x27;(k+1)-x&#x27;&#x27;(k)}{ds}\nx′′′=dsx′′(k+1)−x′′(k)​\n所以加加速度约束转化为加速度约束\n−max_x_third_order_derivative⋅ds≤−x′′(k)+x′′(k+1)≤max_x_third_order_derivative⋅ds-max\\_x\\_third\\_order\\_derivative\\cdot ds \\leq -x&#x27;&#x27;(k)+x&#x27;&#x27;(k+1) \\leq max\\_x\\_third\\_order\\_derivative\\cdot ds\n−max_x_third_order_derivative⋅ds≤−x′′(k)+x′′(k+1)≤max_x_third_order_derivative⋅ds\n因此得到\nA=(In×nIn×nIn×nA1)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎛​In×n​​In×n​​In×n​A1​​⎠⎟⎟⎟⎟⎟⎞​×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​​⎠⎟⎟⎟⎟⎟⎞​\n其中\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×n\\textbf{A}_1 = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA1​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 等式约束\n最终我们将会得到这样一个Affine constraint matrix\n 速度等式约束\nx′x&#x27;x′在前后两个点之间的变化要满足等式约束：\ndx′ds=x′′,存在ξ∈(k,k+1)，使得x′(k+1)−x′(k)=x′′(ξ)⋅ds\\frac{dx&#x27;}{ds}=x&#x27;&#x27;,存在\\xi \\in(k,k+1)，使得x&#x27;(k+1)-x&#x27;(k)=x&#x27;&#x27;(\\xi)\\cdot ds\ndsdx′​=x′′,存在ξ∈(k,k+1)，使得x′(k+1)−x′(k)=x′′(ξ)⋅ds\n假设x′′(ξ)=x′′(k+1)+x′′(k)2x&#x27;&#x27;(\\xi)=\\frac{x&#x27;&#x27;(k+1)+x&#x27;&#x27;(k)}{2}x′′(ξ)=2x′′(k+1)+x′′(k)​，则\nx′(k+1)−x′(k)=x′′(k+1)+x′′(k)2⋅ds  ⟺  (−x′(k)+x′(k+1))−ds2(x′′(k)+x′′(k+1))=0x&#x27;(k+1)-x&#x27;(k)=\\frac{x&#x27;&#x27;(k+1)+x&#x27;&#x27;(k)}{2}\\cdot ds \\\\\n\\iff \\\\\n(-x&#x27;(k)+x&#x27;(k+1))-\\frac{ds}{2}(x&#x27;&#x27;(k)+x&#x27;&#x27;(k+1))=0\nx′(k+1)−x′(k)=2x′′(k+1)+x′′(k)​⋅ds⟺(−x′(k)+x′(k+1))−2ds​(x′′(k)+x′′(k+1))=0\n得到\nA=(In×nIn×nIn×nA1A1A2)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1&amp; \\textbf{A}_2 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎛​In×n​​In×n​A1​​In×n​A1​A2​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×n\\textbf{A}_2 = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA2​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 距离等式约束\nxxx在前后两个点之间的变化要满足等式约束：\nx(k+1)=x(k)+x′(k)⋅ds+x′′(k)2⋅ds2+x′′′(k)6⋅ds3x′′′=x′′(k+1)−x′′(k)ds  ⟺  x(k+1)=x(k)+x′(k)⋅ds+x′′(k)3⋅ds2+x′′(k+1)6⋅ds2\\begin{aligned}\nx(k+1)=x(k)+x&#x27;(k)\\cdot ds+\\frac{x&#x27;&#x27;(k)}{2}\\cdot ds^2 + \\frac{x&#x27;&#x27;&#x27;(k)}{6}\\cdot ds^3 \\\\\nx&#x27;&#x27;&#x27;=\\frac{x&#x27;&#x27;(k+1)-x&#x27;&#x27;(k)}{ds} \\\\\n\\iff \\\\\nx(k+1) = x(k)+x&#x27;(k)\\cdot ds+\\frac{x&#x27;&#x27;(k)}{3}\\cdot ds^2 + \\frac{x&#x27;&#x27;(k+1)}{6}\\cdot ds^2\n\\end{aligned}\nx(k+1)=x(k)+x′(k)⋅ds+2x′′(k)​⋅ds2+6x′′′(k)​⋅ds3x′′′=dsx′′(k+1)−x′′(k)​⟺x(k+1)=x(k)+x′(k)⋅ds+3x′′(k)​⋅ds2+6x′′(k+1)​⋅ds2​\n即\n(−x(k)+x(k+1))−ds⋅x′(k)−ds23(x′′(k)+x′′(k+1)2)=0(-x(k)+x(k+1)) - ds\\cdot x&#x27;(k) - \\frac{ds^2}{3}(x&#x27;&#x27;(k) + \\frac{x&#x27;&#x27;(k+1)}{2})=0\n(−x(k)+x(k+1))−ds⋅x′(k)−3ds2​(x′′(k)+2x′′(k+1)​)=0\n得到\nA=(In×nIn×nIn×nA1A1A2A1A3A4)×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\quad\n\\end{pmatrix}_{\\times 3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​​In×n​A1​A3​​In×n​A1​A2​A4​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1)\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1)\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\quad\n\\end{pmatrix}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​\n其中\nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×n\\textbf{A}_3 = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA3​=−ds⋅In−1×n​A4​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\n 初值等式约束\n速度规划的第一个点的初始值：x,x′,x′′x,x&#x27;,x&#x27;&#x27;x,x′,x′′取值为xinit=(x0x0′x0′′)x_{init} = \\begin{pmatrix} x_0 \\\\ x&#x27;_0 \\\\ x&#x27;&#x27;_0\\end{pmatrix}xinit​=⎝⎛​x0​x0′​x0′′​​⎠⎞​，因此\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\n其中\nA5=(10⋯0)1×n\\textbf{A}_5=\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\nA5​=(1​0​⋯​0​)1×n​\n由此得到Affine constraint matrix。\n 最终转化结果\nminimize12xTPx+qTxsubjectto:l≤Ax≤uminimize \\quad \\frac{1}{2}x^T\\textbf{P}x+\\textbf{q}^Tx \\\\\nsubject \\quad to: \\quad \\textbf{l}\\leq \\textbf{A}x\\leq \\textbf{u}\nminimize21​xTPx+qTxsubjectto:l≤Ax≤u\n其中：\nP=(wx_refIn×n(wx′_ref+Penaltyx′)In×nP3)3n×3n\\textbf{P}=\\begin{pmatrix} \nw_{x\\_ref}\\textbf{I}_{n\\times n} &amp; &amp; \\\\ \n&amp; (w_{x&#x27;\\_ref}+Penalty_{x&#x27;})\\textbf{I}_{n\\times n} &amp;  \\\\ \n&amp; &amp; \\textbf{P}_3 \\\\\n\\end{pmatrix}_{3n \\times 3n}\nP=⎝⎛​wx_ref​In×n​​(wx′_ref​+Penaltyx′​)In×n​​P3​​⎠⎞​3n×3n​\nP3=(01×n−10(−2wx′′′ds2)In−1×n−10n−1×1)n×n+(wx′′+wx′′′ds201×n−200n−2×1(wx′′+2wx′′′ds2)In−2×n−20n−2×1001×n−2wx′′+wx′′′ds2)n×n\\textbf{P}_3=\\begin{pmatrix} \n\\textbf{0}_{1 \\times n-1} &amp; 0 \\\\ \n(-2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-1\\times n-1} &amp; \\textbf{0}_{n-1 \\times 1} \\\\ \n\\end{pmatrix}_{n \\times n}\n+\n\\begin{pmatrix} \nw_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} &amp; \\textbf{0}_{1\\times n-2} &amp; 0 \\\\ \n\\textbf{0}_{n-2\\times 1} &amp; (w_{x&#x27;&#x27;}+2\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2})\\textbf{I}_{n-2\\times n-2} &amp; \\textbf{0}_{n-2\\times 1} \\\\ \n0 &amp; \\textbf{0}_{1\\times n-2} &amp; w_{x&#x27;&#x27;}+\\frac{w_{x&#x27;&#x27;&#x27;}}{ds^2} \\\\\n\\end{pmatrix}_{n\\times n}\nP3​=(01×n−1​(−2ds2wx′′′​​)In−1×n−1​​00n−1×1​​)n×n​+⎝⎛​wx′′​+ds2wx′′′​​0n−2×1​0​01×n−2​(wx′′​+2ds2wx′′′​​)In−2×n−2​01×n−2​​00n−2×1​wx′′​+ds2wx′′′​​​⎠⎞​n×n​\nq=((−2wx_refxref)n×1(−2wx′_refxref′)n×1(0⋮0−2wx′′xend′′)n×1)3n×1\\textbf{q} = \\begin{pmatrix} \n(-2w_{x\\_ref}x_{ref})_{n\\times 1} \\\\ \n(-2w_{x&#x27;\\_ref}x&#x27;_{ref})_{n\\times 1} \\\\ \n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\n0 \\\\\n-2w_{x&#x27;&#x27;}x&#x27;&#x27;_{end}\n\\end{pmatrix}_{n \\times 1}\n\\end{pmatrix}_{3n \\times 1}\nq=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎛​(−2wx_ref​xref​)n×1​(−2wx′_ref​xref′​)n×1​⎝⎜⎜⎜⎜⎛​0⋮0−2wx′′​xend′′​​⎠⎟⎟⎟⎟⎞​n×1​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎞​3n×1​\nA=(In×nIn×nIn×nA1A1A2A1A3A4A5A5A5)(3n+3(n−1)+3)×3n  ⟺  6n×3n\\textbf{A}=\\begin{pmatrix} \n\\textbf{I}_{n\\times n}  &amp; &amp; \\\\ \n&amp; \\textbf{I}_{n\\times n} &amp; \\\\ \n&amp; &amp; \\textbf{I}_{n\\times n} \\\\\n&amp; &amp; \\textbf{A}_1 \\\\\n&amp; \\textbf{A}_1 &amp; \\textbf{A}_2 \\\\\n\\textbf{A}_1 &amp; \\textbf{A}_3 &amp; \\textbf{A}_4 \\\\\n\\textbf{A}_5 &amp; &amp; \\\\\n&amp; \\textbf{A}_5 &amp; \\\\\n&amp; &amp; \\textbf{A}_5\\\\\n\\end{pmatrix}_{(3n + 3(n-1)+3) \\times 3n \\iff 6n \\times3n}\nA=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​In×n​A1​A5​​In×n​A1​A3​A5​​In×n​A1​A2​A4​A5​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​(3n+3(n−1)+3)×3n⟺6n×3n​\nl=((x_bounds_.first)n×1(dx_bounds_.first)n×1(ddx_bounds_.first)n×1(−max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{l} = \\begin{pmatrix} \n(x\\_bounds\\_.first)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.first)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.first)_{n\\times 1} \\\\\n(-max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n\\times 1}\nl=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.first)n×1​(dx_bounds_.first)n×1​(ddx_bounds_.first)n×1​(−max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nu=((x_bounds_.second)n×1(dx_bounds_.second)n×1(ddx_bounds_.second)n×1(max_x_third_order_derivative⋅ds)n−1×10n−1×10n−1×1xinit)6n×1\\textbf{u} = \\begin{pmatrix} \n(x\\_bounds\\_.second)_{n\\times 1} \\\\ \n(dx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(ddx\\_bounds\\_.second)_{n\\times 1} \\\\ \n(max\\_x\\_third\\_order\\_derivative\\cdot ds)_{n-1\\times1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\n\\textbf{0}_{n-1 \\times 1} \\\\\nx_{init} \\\\\n\\end{pmatrix}_{6n \\times 1}\nu=⎝⎜⎜⎜⎜⎜⎜⎜⎜⎜⎛​(x_bounds_.second)n×1​(dx_bounds_.second)n×1​(ddx_bounds_.second)n×1​(max_x_third_order_derivative⋅ds)n−1×1​0n−1×1​0n−1×1​xinit​​⎠⎟⎟⎟⎟⎟⎟⎟⎟⎟⎞​6n×1​\nA1=(−11⋯−11⋯⋱⋯10⋯−11)n−1×n\\textbf{A}_1 = \\begin{pmatrix} \n-1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; -1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; -1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA1​=⎝⎜⎜⎜⎜⎜⎛​−1​1−1​1​⋯⋯⋱⋯⋯​1−1​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\nA2=−ds2(11⋯11⋯⋱⋯10⋯11)n−1×n\\textbf{A}_2 = -\\frac{ds}{2}\n\\begin{pmatrix} \n1 &amp; 1 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 1 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 1 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA2​=−2ds​⎝⎜⎜⎜⎜⎜⎛​1​11​1​⋯⋯⋱⋯⋯​11​01​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\nA3=−ds⋅In−1×nA4=−ds32(10.5⋯10.5⋯⋱⋯0.50⋯10.5)n−1×n\\textbf{A}_3 = -ds\\cdot\n\\textbf{I}_{n-1 \\times n}\\\\\n\\textbf{A}_4 = -\\frac{ds^3}{2}\n\\begin{pmatrix} \n1 &amp; 0.5 &amp; &amp; \\cdots  \\\\ \n&amp; 1 &amp; 0.5 &amp; \\cdots &amp; \\\\ \n&amp; &amp; &amp; \\ddots &amp; &amp; \\\\ \n&amp; &amp; &amp; \\cdots &amp; 0.5 &amp; 0 \\\\\n&amp; &amp; &amp; \\cdots &amp; 1 &amp; 0.5 \\\\\n\\end{pmatrix}_{n-1 \\times n}\nA3​=−ds⋅In−1×n​A4​=−2ds3​⎝⎜⎜⎜⎜⎜⎛​1​0.51​0.5​⋯⋯⋱⋯⋯​0.51​00.5​⎠⎟⎟⎟⎟⎟⎞​n−1×n​\nA5=(10⋯0)1×n\\textbf{A}_5=\\begin{pmatrix} \n1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \n\\end{pmatrix}_{1 \\times n}\nA5​=(1​0​⋯​0​)1×n​\n","categories":["算法"]},{"title":"分段加加速度路径规划OSQP仿真参数分析","url":"/2022/04/01/%E5%88%86%E6%AE%B5%E5%8A%A0%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92OSQP%E4%BB%BF%E7%9C%9F%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","content":" 分段加加速度路径规划OSQP仿真参数分析\n在自动驾驶横向路径规划中，分段加加速度模型（最小 jerk）常用于生成平滑轨迹，并以 OSQP 作为优化求解器。本文通过系统性仿真实验，分析路径规划中各种参数对轨迹形状与可行性的影响，并总结出一套实用的参数调试指南。\n\n\n\n参数名\n默认值\n建议范围\n说明\n\n\n\n\nl_weight\n1.0\n[10, 33]\n越大越贴中心线，过大不自然\n\n\ndl_weight\nmax(5.0, 初始dl²)\n[0, 10000]\n越大越直，对结果影响小\n\n\nddl_weight\n1000.0\n任意\n影响极小\n\n\ndddl_weight\n50000.0\n[50000, 500000]\n控制曲线“硬直”程度\n\n\nx_ref_weight\n10.0\n[10, 30]\n越大越接近目标线，但存在跳变\n\n\nend_state_weight_l\n1000.0\n[1000, 10000]\n控制终点位置贴合度\n\n\nend_state_weight_dl/ddl\n0.0\n任意\n基本无影响\n\n\n\n跳变提示：\n\n多个权重参数（如 l_weight、x_ref_weight）在某些区间会出现“跳变点”，即微小调整导致轨迹急剧变化，建议避开。\nx_ref_weight 在 [8.8, 9.0] 存在跳变，l_weight 在 [9, 10]、[33, 34]、[43, 44] 存在跳变。\n\n\n 默认参数\n采用单一变量原则：只改变其中一个值，其余不变。\n# state (l, dl, ddl) : tuplefirst_state = (3.0, 0., 0.)last_state = (3.5, 0., 0.)# weight (l, dl, ddl) : tupleend_state_weight = (1000.0, 0.0, 0.0)weight_x_ref = 10.0# weights &#123;l_weight, dl_weight, ddl_weight, dddl_weight, 0.0&#125;weights = np.array([1.0, max(5.0, first_state[1] * first_state[1]), 1000.0, 50000.0, 0.0])# scale_factors (l_scale_factor, dl_scale_factor, ddl_scale_factor) : tuplescale_factors = (1.0, 10.0, 100.0)default_lateral_derivative_bound = 2.0default_lateral_jerk_bound = 4.0\n 边界约束条件分析\n l_bounds根据障碍物道路构造边界\n就是障碍物边界，硬约束，需要注意的是起点一定要在约束条件以内，不然会导致计算失败(primal infeasible)；终点不一定，即终点可以在边界之外。\n# end_state (l, dl, ddl) : tuple\n\n0是个需要额外注意的情况，曲线是独特的。\n dl_bounds默认值为2.0，对曲线影响不大\n理解成横向速度。\n\n默认情况下，计算得到的dl在(−0.3,0.2)(-0.3,0.2)(−0.3,0.2)之间。\n设置default_lateral_derivative_bound太小就会导致计算失败(primal infeasible)。\n如下设置为0.19，发现会与边界相交。\n\n\n只要满足规划需求，对结果影响不大。\n ddl_bounds根据车辆性能与参考线曲率设定\n理解成车辆的转弯曲率边界，以自卸车为例，最大转弯曲率为0.1左右。体现为，计算结果的曲线能转弯的能力。\n\n值越小，拐弯能力越不行，绕障时就需要大幅度的摆动。\n\n\n dddl_bound对曲线影响不大，默认值为4.0\n\n\n对曲线影响不大。只要不为零，就不会导致计算失败(primal infeasible)。\n\ndl,ddl的上下限约束必须包括零点，即下限必须小于零，上限必须大于零，否则会造成primal infeasible求解失败。\n weights参数分析\nweights &#123;l_weight, dl_weight, ddl_weight, dddl_weight, 0.0&#125;\n无x_reference情况下：\n weight_l默认值1.0，建议区间[10,33][10,33][10,33]\n\nl_weight比重越大，越贴近中心线，整体感觉就是晚点绕障，提早回中心线，曲线越柔软；值在[0, 1.0]效果差不多；\n比重为1000已经使得曲线基本贴着边界，不可取；\n\n比重为[1,9][1,9][1,9]曲线差不多，也就是[0,9.0][0,9.0][0,9.0]，影响不大。在[9,10][9,10][9,10]存在一个跳变值，同end_state_weight_l。\n\n\n可见比重在50之后，变化不大，所以调试参数可定在[10,33][10,33][10,33]。\n\n\n比重在[33,34][33,34][33,34]之间存在跳变。\n\n比重在[34,43][34,43][34,43]之间对曲线影响不大。\n\n比重在[43,44][43,44][43,44]之间存在跳变。\n weight_dl默认值为5与初始dl平方最大值，对曲线其实影响不大\n\n\ndl_weight比重越大，整体拉得越直，[0,1000][0, 1000][0,1000]差别不大；比重为100000的曲线不平滑，不可取。\n\n[10000,100000][10000,100000][10000,100000]之间的比重，曲线过于柔软，贴近别解，不建议。\n\n比重在区间[1000,10000][1000,10000][1000,10000]，对曲线其实影响不大。车辆初始dl一般也不会超过100，也就是比重一般不会超过10000。\n weight_ddl对曲线影响不大，默认值1000.0\n\nddl_weight比重对曲线影响不大。\n weight_dddl影响结果拐弯性能，默认值50000.0，建议区间[50000.0,500000.0][50 000.0,500 000.0][50000.0,500000.0]，间隔100000.0100 000.0100000.0\n\n\n\ndddl_weight比重越小，越接近中心线，曲线越扭曲 (柔软) ，晚点绕障，提前回位；比重越大，整体曲线越平缓，感觉越 硬直 ，曲线拐弯性能越差。\n\n end_state_weight参数分析\n# weight (l, dl, ddl) : tuple\n end_state_weight_l默认值是1000，建议end_state=(0.,0.,0.)end\\_state= (0., 0., 0.)end_state=(0.,0.,0.)，对曲线影响不大\n 当end_state=(0.,0.,0.)end\\_state= (0., 0., 0.)end_state=(0.,0.,0.)\n\n该比重对曲线影响不大，比重为[0.0,10.0][0.0,10.0][0.0,10.0]，结果曲线基本一致。当比重为[100,1000000][100,1000000][100,1000000]时，末尾曲线比较靠近0.0，整体上基本一致。\n 当end_state=(0.1,0.,0.)end\\_state= (0.1, 0., 0.)end_state=(0.1,0.,0.)，建议区间[1000,10000][1000,10000][1000,10000]，特殊时候区间[100000,1000000][100000,1000000][100000,1000000]\n\n\n比重为[0,1000][0,1000][0,1000]时，结果曲线与边界相交，不建议；当然如果障碍物buffer考虑很大时，可以适当妥协。\n\n比重为[10000,100000][10000,100000][10000,100000]的结果曲线差别不大，当达到1000000时，曲线过于柔软，不建议。\n\n建议区间[1000,10000][1000,10000][1000,10000]，间隔1000，比重越大避障时，越早开始绕障，越早回位。\n\n比重也可以在[1000，2000][1000，2000][1000，2000]，间隔100，之间进行微调，比重越大避障时，越早开始绕障，越早回位。\n\n某些时候，可以采用该比重区间[100000,1000000][100000,1000000][100000,1000000]，让车在避障时远离障碍物。\n 当end_state=(3.5,0.,0.)end\\_state= (3.5, 0., 0.)end_state=(3.5,0.,0.)，建议区间[2000,10000][2000,10000][2000,10000]，特殊时候区间[10000,100000][10000,100000][10000,100000]\n\n\n比重为[0,1000][0,1000][0,1000]时，结果曲线与边界相交，不建议；当然如果障碍物buffer考虑很大时，可以适当妥协。\n\n比重为[100000,1000000][100000,1000000][100000,1000000]的结果曲线差别不大，过于柔软，不建议。\n\n存在跳变。\n\n依旧存在跳变。\n\n跳变存在在[1500,1600][1500,1600][1500,1600]之间。\n\n比重在[2000,3000][2000,3000][2000,3000]，间隔100，可以微调结果曲线。\n\n某些时候，可以采用该比重区间[10000,100000][10000,100000][10000,100000]，让车在避障时远离障碍物。\n end_state_weight_dl对曲线影响不大，默认值0.00.00.0\n\n比重越大，让曲线的末尾段斜率越接近设定值，对整体曲线的影响不大。\n end_state_weight_ddl对曲线影响不大，默认值0.00.00.0\n\n对生成路径整体影响不大。\n weight_x_ref参数分析，默认值101010，建议区间[10,30][10,30][10,30]\n\n比重越大，曲线越接近目标线。超过100，基本不满足非和谐系统的运动。取值可以考虑在[0,100][0,100][0,100]。\n\n进一步分析，可以发现在区间[0,20][0,20][0,20]曲线较为敏感，对曲影响较大。\n\n\n比重为5,6,7,85,6,7,85,6,7,8曲线较为一致，比重为9,109,109,10曲线较为一致，所以下一步分析区间[8,9][8,9][8,9]\n\n不存在过渡性，即存在跳变(跳变存在在区间[8.8,9.0][8.8,9.0][8.8,9.0])，不方便调试，所以考虑区间[10,30][10,30][10,30]。\n\n比重越大，曲线越接近目标线，越早回中心线。\n","categories":["算法"]},{"title":"非线性优化工具IPOPT安装","url":"/2025/02/04/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7IPOPT%E5%AE%89%E8%A3%85/","content":"详细记录了在 Linux（Ubuntu 20.04）环境下安装 IPOPT 及其依赖项（如 ASL、HSL、MUMPS、ColPack、Adol-C）的方法，涵盖 C++ 和 Python 两种使用场景，并附带错误排查建议和编译参数说明，是一份非常实用的安装部署手册。\n\n C++\n Ipopt安装\nLinux | Ubuntu 20.04安装ipopt和cppAD | 安装全流程+报错解决\n按照方法二，成功安装Ipot3.14.17版本\n 源码安装\n\n安装依赖\n\nsudo apt-get install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev libblas-dev \n\n创建一个存放所有跟Ipopt相关的文件夹，便于管理\n\nmkdir ~/Ipopt_pkgcd Ipopt_pkg\n\n安装ASL\n\ngit clone https://github.com/coin-or-tools/ThirdParty-ASL.gitcd ThirdParty-ASLsudo ./get.ASLsudo ./configuresudo makesudo make installcd ..\n\n安装HSL\n\ngit clone https://github.com/coin-or-tools/ThirdParty-HSL.gitcd ThirdParty-HSL# 接下来需要下载coinhsl文件，并解压到ThirdParty-HSL目录下\n下载coinhsl.zip文件，并解压到ThirdParty-HSL目录下\n在ThirdParty-HSL目录下，执行以下命令\nsudo ./configuresudo makesudo make installcd ..\n\n安装MUMPS\n\ngit clone https://github.com/coin-or-tools/ThirdParty-Mumps.gitcd ThirdParty-Mumpssudo ./get.Mumpssudo ./configuresudo makesudo make installcd ..\n\n安装Ipopt\n\ngit clone https://github.com/coin-or/Ipopt.gitcd Ipoptmkdir buildcd buildsudo ../configuresudo makesudo make testsudo make install\n\n完善环境\n\ncd /usr/local/includesudo cp coin-or coin -rsudo ln -s /usr/local/lib/libcoinmumps.so.3 /usr/lib/libcoinmumps.so.3sudo ln -s /usr/local/lib/libcoinhsl.so.2 /usr/lib/libcoinhsl.so.2sudo ln -s /usr/local/lib/libipopt.so.3 /usr/lib/libipopt.so.3\n ColPack安装\n 指令安装(验证可行)\nsudo apt-get install libcolpack-dev# 默认安装在/usr目录下\n# 查询是否安装了ColPackldconfig -p | grep ColPack\n\n 源码安装\n\n源码下载\n\ngit clone https://github.com/CSCsw/ColPack.git  #Download ColPackcd ColPack             # ColPack Root Directory\n\n安装\n\n该方法变以后的头文件和库所在位置是错误的，需要调整位置。否则，安装Adolc时会链接不到。\n\n通过autotools安装\n\ncd build/automake      # automake folderautoreconf -vif        # generate configure files based on the machincemkdir mywork           cd myworkfullpath=$(pwd)        # modify fullpath to your destination folder if need../configure --prefix=$&#123;fullpath&#125;  make -j 4              # Where &quot;4&quot; is the number of cores on your machinemake install           # install lib and include/ColPack to destination  \n\n通过cmake安装\n\nmkdir build/cmake/myworkcd build/cmake/myworkfullpath=$(pwd)        # modify fullpath to your destination folder if needcmake .. -DCMAKE_INSTALL_PREFIX:PATH=$&#123;fullpath&#125; make -j 4              # Where &quot;4&quot; is the number of cores on your machinemake install           # install the libararies\n\n如果指定v1.0.10版本(验证可行)\n\ngit checkout v1.0.10./autoconf.sh# 配置安装地址./configure --prefix=$&#123;ColPack的安装地址&#125;makesudo make install\n\n$&#123;ColPack的安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n\n\n头文件在include/ColPack/目录\n库文件在lib/目录\n\n\n可以直接修改autoconf.sh文件内容，配置安装地址\n\n\n Adolc安装\n库地址\n 使用CMake安装(目前还不成熟)\n\n 使用AutoTools安装(验证可行)\n 使用 AutoTools 进行本地安装\n\n\n执行 autoreconf -fi\n\n\n运行 configure，可能需要使用以下选项之一：\n\n--prefix=PREFIX：将库和头文件安装到 PREFIX 目录（默认：${HOME}/adolc_base）。\n--enable-sparse：构建稀疏驱动程序（默认：no）。\n--with-openmp-flag=FLAG：使用 FLAG 来启用编译时的 OpenMP（默认：none）。\n--enable-docexa：构建文档化的示例（默认：no）。\n--enable-addexa：构建额外的示例（默认：no）。\n--enable-parexa：构建并行示例（默认：no）。如果启用此选项，则需要使用 --with-openmp-flag=FLAG。\n--with-cflags=FLAGS：使用 CFLAGS=FLAGS（默认：-g -O2）。\n--with-cxxflags=FLAGS：使用 CXXFLAGS=FLAGS（默认：-g -O2 -std=c++11）。\n--with-boost=BOOST_PATH：指定已编译的 Boost 库路径，默认选择系统库（如果存在）。\n\n\n\n执行 make\n\n\n执行 make install\n默认情况下，make install 会将所有文件安装到 $&#123;PREFIX&#125;/lib 和 $&#123;PREFIX&#125;/include 目录。如果需要指定其他安装目录，可以在 configure 调用时使用 --prefix 选项。\n\n\n此过程会在适当的目录中生成所有必需的makefile。执行 ./configure --help 可以查看其他可用选项的详细信息。\n 非本地安装\n如同在 INSTALL 文件中提到的，可以使用 --prefix=PATH 配置选项将 adolc 软件包安装到与 $&#123;HOME&#125;/adolc_base 不同的目录。这通常用于全局安装。常见的路径包括 /usr 和 /usr/local/，并且还有其他路径也会被使用。通过提供额外的 configure 选项，可以对安装目录进行更精细的控制。详情请参见 ./configure --help。\n执行 make install 完成安装时，目标目录必须具有写权限。确保你拥有相关权限，否则可能会得到意外结果。\n如果需要多个用户共享库文件，全局安装可能会非常有用。通过将库路径添加到 /etc/ld.so.conf，就可以避免使用 LD_LIBRARY_PATH 和 -L 链接选项。在许多情况下，例如 PATH=/usr/local，还可以避免在编译源代码时使用 -I 指令。\n 安装指令(验证可行)\n# 1. 下载源代码git clone https://github.com/coin-or/ADOL-C.gitcd ADOL-C/# 2. 切换到所需版本分支git checkout releases/2.7.2# 3. 执行前期准备（需要AutoTools工具）autoreconf -fi# 4. 配置安装目录和所需驱动CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib \\./configure --prefix=$&#123;Adolc想要安装地址&#125; --enable-sparse --with-colpack=$&#123;ColPack的安装地址&#125;# 5. 编译make# 6. 安装make install\n\n$&#123;Adolc想要安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n$&#123;ColPack的安装地址&#125;本人位置是/home/lxp/projects/l2_data_plot_tool/data_plot_tool/third_party\n\n注意：\n\n需要切换发布版本，比如releases/2.7.2，否则autoreconf -fi会执行失败\n需要指定CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib，否则会出现yes/lib64等异常路径，导致失败。(通过设置 CPPFLAGS 和 LDFLAGS 环境变量明确指定 ColPack 的路径来配置 ADOL-C)\n\n\n验证是否成功链接上ColPack库: \n\nldd libadolc.so\n\n\n Python\nc++与python非线性规(优)划（化）工具\n在Ubuntu + Anaconda环境下安装pyomo与ipopt：\n## 进入虚拟环境conda update condaconda update anacondaconda install -c conda-forge pyomoconda install -c conda-forge pyomo.extrasconda install -c conda-forge coincbcconda install -c conda-forge ipopt\n 拓展知识\n 编译参数CPPFLAGS、CFLAGS、LDFLAGS的理解\n\n\nCPPFLAGS: 预处理器需要的选项 如：-I(大写i指定头文件路径)\nCFLAGS：编译的时候使用的参数–Wall –g -c\nLDFLAGS：链接库使用的选项–L -l(大写L指定动态库的路径，小写L指定动态库的名称)\n\n\n\n\nCFLAGS表示用于C编译器的选项\nCXXFLAGS表示用于C++编译器的选项\n这两个变量实际上涵盖了编译和汇编的两个步骤\n\n\n\n\nCPPFLAGS：指定头文件(.h)的路径，如：CPPFLAGS=-I/usr/include -I/path/include。\n\n安装一个包时会在安装路径下建立一个include文件夹;\n当安装过程中出现故障时，试着把曾经安装的包的include文件夹增加到该变量中来。\n\n\n\nLDFLAGS：gcc等编译器会用到的一些优化參数，也能够在里面指定库文件的位置。\n使用方法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n\n每安装一个包，一定会在安装文件夹里建立一个lib文件夹。\n假设已经安装了某个包，而在安装另一个包时，它愣是说找不到，那就将那个包的lib路径增加的LDFALGS中试一下。\n\n\n\nLIBS：告诉链接器要链接哪些库文件。如LIBS = -lpthread -liconv\n\n简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。\n有时候LDFLAGS指定-L尽管能让链接器找到库进行链接。可是运行时链接器却找不到这个库。假设要让软件运行时库文件的路径也得到扩展，那么我们须要增加这两个库给-Wl,R：\n假设在运行./configure曾经环境变量设置export LDFLAGS=&quot;-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib&quot;\n\n注意环境变量设置等号两边不能够有空格，并且要加上引号（shell的使用方法）。\n那么运行configure以后。Makefile将会设置这个选项，链接时会有这个參数，编译出来的可运行程序的库文件搜索路径就得到扩展了。LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib\n\n\n\n\n\n","categories":["算法","Linux软件开发"]}]